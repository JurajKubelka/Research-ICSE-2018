# -*- coding: utf-8-unix ; mode: org ; font-lock-multiline: t ; eval: (auto-fill-mode -1) ; eval: (flyspell-mode 1) ; eval: (visual-line-mode 1) -*-
#+TITLE: The Road to Live Programming: Insights From the Practice
#+CATEGORY: Exploratory Study
#+LANGUAGE: en
#+PROPERTY: RootDir1 ./
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="transcript.css" />
#+OPTIONS: toc:nil author:nil c:nil creator:nil date:nil title:nil timestamp:nil

* Sessions June 2014
** Session S2 with P2, unfamiliar (Roassal2 Menu background color)
   :PROPERTIES:
   :VideoFile: videos/S2-P2.m4v
   :FUEL: dflow/S2-P2.fuel
   :VIDEO-START-TIME: 2014-07-02T16:59:55.623033-04:00
   :Familiar: 0
   :SESSION-ID: S2
   :PARTICIPANT-ID: P2
   :END:
*** Tool Usage
1. 00:00-01:14 c"rest-time"
2. 01:14-02:04 c"dynamic-tool"
3. 02:04-09:46 c"static-tool"
4. 09:46-12:18 c"dynamic-tool"
5. 12:18-17:53 c"static-tool"
6. 17:53-18:06 c"dynamic-tool"
7. 18:06-18:15 c"static-tool"
8. 18:15-18:25 c"dynamic-tool"
9. 18:25-19:06 c"static-tool"
10. 19:06-19:37 c"dynamic-tool"
11. 19:37-21:58 c"static-tool"
12. 21:58-22:15 c"dynamic-tool"
13. 22:15-22:34 c"static-tool"
14. 22:34-22:58 c"dynamic-tool"
15. 22:58-23:04 c"static-tool"
16. 23:04-23:46 c"dynamic-tool"
17. 23:46-24:13 c"static-tool"
18. 24:13-24:34 c"dynamic-tool"
19. 24:34-26:00 c"static-tool"
20. 26:00-26:35 c"dynamic-tool"
21. 26:35-27:41 c"static-tool"
22. 27:41-28:11 c"dynamic-tool"
23. 28:11-29:02 c"static-tool"
24. 29:02-29:13 c"dynamic-tool"
25. 29:13-29:22 c"static-tool"
26. 29:22-29:54 c"dynamic-tool"
27. 29:54-30:36 c"static-tool"
28. 30:36-31:46 c"dynamic-tool"
29. 31:46-32:24 c"static-tool"
30. 32:24-32:43 c"dynamic-tool"
31. 32:43-36:44 c"static-tool"
32. 36:44-37:04 c"dynamic-tool"
33. 37:04-37:56 c"static-tool"
34. 37:56-39:59 c"dynamic-tool"
35. 39:59-40:15 c"dynamic-tool"
36. 40:15-41:08 c"static-tool"
37. 41:08-41:52 c"dynamic-tool"
38. 41:52-44:37 c"static-tool"
39. 44:37-45:04 c"dynamic-tool"
40. 45:04-45:58 c"static-tool"
41. 45:58-46:05 c"dynamic-tool"
42. 46:05-46:28 c"static-tool"
43. 46:28-46:49 c"dynamic-tool"
44. 46:49-47:16 c"static-tool"
*** Transcript
1. 00:00-00:39 Starts DFlow.
2. 00:39-01:15 he reads the task from the email.
3. 01:15-01:59 Q"How does the current solution works? (e8) What does the failure look like?" Qe8 Executes and understands the example snippet of code in Workspace, Used tools: Workspace, RTView. He closes the RTView window.
4. 01:59-03:00 GQ"(17) What does the declaration or definition of ~menu:submenu:background~ look like?", he press CMD+m, only one method -> Nautilus Browser. He observes the method.
5. 03:00-04:36 <<s10link1>> He has the first hypotesis that he could put ~color:~ method on ~RTMenuItem~ object. Q"Is it correct to put ~color:~ method in the ~menu:submenu:background~ method? Does ~RTMenuItem~ object keeps color?" Q3 c"answered-question" c"miss-opportunity" C"I think this is the case, where he could start. But he likely preferes to check all possibilities, then make changes. He is back with the idea at [[s10link6][14:13]] and [[s10link6a][14:28]], but he never realizes it." He wants to check his hypotesis. 
   1. 03:04-04:07 GQ"(17) What does the declaration or definition of this look like?" Observes ~RTMenuItem~, what methods it has, interested in ~rawmenu~ instance variable. Used tools: Nautilus N2, Accesses to rawmenu A1
      1. 03:06 S"Lets see the class ~RTMenuItem~ here. ... How do I do that [see the class]? CMD+B?" 
      2. 03:44-04:07  S"Who is accessing the ~rawmenu~ thing [instance variable]?" (Two methods) Q"(15) Where is this ~rawmenu~ variable or data structure being accessed?" Q15
   2. 04:07-04:16 S"Who are senders of ~rawmenu~ method?" GQ"(12) Where is this method called or type referenced?" -> One user -> Nautilus N3
   3. 04:16-04:36 He observes ~RTMenuGroup>>add:~ method.
6. 04:36-04:48 he arranges windows
7. 04:48-21:57 He observes other places that could keep background color Q"Where can I keep color information? Is there any 'color' information? (3) Where is there any code involved in the implementation of this behavior?" Q3
   1. 04:48-05:12 Back in browser 1 with ~menu:submenu:background~ because there is not color in previous observation, S"I am going to look at ~createParentMenu:background:~" Q"(17) What does the declaration or definition of ~createParentMenu:background:~ look like?" Q17 -> one implementation -> Nautilus (4/4)
   2. 05:12-06:16 Observing other senders of the first method from nautilus 1, Used tools: Nautilus 4
      1. 05:12-05:14 S"It is in RTMenuBuilder [the createParentMenu:background:]" GQ"(11) Who implements this interface or these abstract methods?"
      2. 05:14-05:28 Because of a Pharo 3 error, he loosed the implementation -> new browser again
      3. 05:28-06:00 <<s10link2>> Found ~createBackgroundFor:color:~ method which was just above the previous method (Nautilus (4/4)) GQ"(6) What are the parts of this type?" S"This is probably something I should not try to do, because it is pretty low level ..." c"miss-opportunity" C"I think this is exactly what he should do. And he does it at [[s10link11][21:11]]."
      4. 06:00-06:16 Q17 He observes ~createParentMenu:~  GQ"(6) What are the parts of this type?"
   3. 06:16-06:20 Q"What does ~RTMenu~ class represent?" Q6 he clicks on ~RTMenu~ class but does not observe it much.
   4. 06:20-07:12 <<s10link3>> He clicks on ~RTMenuBuilder~, then ~createParentMenu:~ method. In Nautilus 4 jumped to RTMenu class then back to ~RTMenuBuilder>>createParentMenu:~ GQ"(17) What does the declaration or definition of this look like?". S"[No, ] it is a label" He also observes ~createParentMenu:background:~, but more ~createParentMenu:~. c"miss-opportunity" C"Here he can see how to use color."
   5. 07:12-09:47 Q"What is the relation between ~RTMenu*~ classes?" Q22 he observes ~RTMenuItem~ class and its methods. C"Hard to know if it is answered question."
      1. 08:19-08:41 he arrange windows.
      2. 08:41-09:47 <<s10link4>> Q"What does ~RTMenu~ looks like?" Q6. He observes ~RTMenu~ methods. C"He could see ~showSubmenuOf:~ that is important for him (see [[s10link7a]])." c"miss-opportunity"
         1. 09:10 S"It is good I have not so deep class hierarchy"
   6. 09:47-14:28 <<s10link5>> he goes to the workspace. c"observer" C"The observer has observed that the API of example snippet is confusing and suggested to modify a bit the example in order to understand parameters. This is something P2 should found out yourself as he mentioned. And at the end of the session he said it was really helpful." Using: workspace, RTView
      1. 10:31-10:38 he changes a bit the snippet and executes it. Q"How does the code works?" Q44 he can see changes.
      2. 10:38-11:02 Q"How was the thing [RTView on the example] before?" GQ"(34) How did the example look like recently?" he understands that he has two menus instead of one.
      3. 11:02-14:28 he observes ~menu:submenu:background:callback:~ method definition Q17 revalidating the new facts and the impact to the task. Used tools: Nautilus 1, Workspace
         1. 11:40-14:28 S"So there are two things:" Q"Should the color specified here goes just for the items?" GQ"(38) How should I implement this behavior?" the API is not clear and he has to decide how to interpret it.
            1. 12:54-13:02 Q"What is the superclass of ~RTMenuBuilder~?" Q8 It is ~RTBuilder~.
            2. 13:02-14:13 Observing RTMenuBuilder method names. Used tools:  Nautilus 1 GQ"(17) What does the declaration or definition of this look like?" namely: ~menu:submenus:background:callback:~, ~menu:submenu:background:callback:~.
            3. 14:13-14:28 <<s10link6>> S"Likely the simples think is to have the color propagate to items" Q"What is the best way to implement the behavior?" Q3
   7. 14:28-15:49 <<s10link6a>> he browses previous methods in order to check his thoughts and how to implement it. Q"Is the idea of adding instance variable ~color~ here correct?" Q38
      1. 14:20 S"I am looking if there are [basically in all 5 classes] a color information, but it is not"
      2. 14:30 S"I would like to add a color instVar to MenuItem, but it does not feel right"
      3. 14:47 S"Maybe the color is in the view"
   8. 15:49-16:04 goes to ~RTMenu>>item~ and asks for senders GQ"(12) Where is this method called or type referenced?". He expected there will be a lot of items senders, but he was surprised that not that many (39). There are 3 senders that belongs to ~RTMenu*~ classes.
   9. 16:04-16:41 <<s10link7>> Jumped to RTMenu>>add:, then showSubmenuOf: GQ"(17) What does the declaration or definition of this look like?" C"This is the first time he is interested in this important method."
      1. S"Here I have labels as graphical representations." C"Actually answer to. _Answered after almost 17 minutes._"
      2. <<s10link7a>> He found out ~showSubmenuOf:~ important (focus point) and then rearanged the space
   10. 16:41-17:09 he arranges the windows.
       1. c"ide-improper-behavior" a small bug on Senders of
   11. 17:09-17:16 he states that in ~showSubmenuOf:~ method he could put the background color
       1. 17:14 <<s10link8>> S"Here I could plug the color information #showSubmenuOf:"  C"_Answered where to put the color._"
   12. 17:16-17:35 <<s10link9>> he can see in ~menu:callback:~ method code =lbl color: Color black= and he supposes that it could be used for background color. c"false-assumption" C"It is a font color."
   13. 17:35-18:05 c"confidence" Q"Does the ~color:~ message call change background color of submenu items?" Q23 c"answered-question"
       1. 17:35-17:54 he writes it into ~showSubmenuOf:~ method.
       2. 17:54-18:05 and executes the snippet. There is no visible change.
   14. 18:05-18:25 then he tries =label background: Color pink=, with ~MessageNotUnderstood~. c"debugger" Q"Does the ~background:~ message call change background color of submenu items?" Q23
   15. 18:25-18:45 he removes the changed line in ~showSubmenuOf:~.
   16. 18:45-20:37 S"I am trying to get if some of these guys [variables in ~showSubmenuOf:~ method] get a color." Q"Who from those guys [variables in a method] has color?" Q25 c"answered-question" C"He did not find anything."
       1. 18:45-19:06 he writes =self halt=.
       2. 19:06-19:22 and executed the snippet.
       3. 19:22-19:24 in the c"debugger" he observes temporary variables: ~l~ Q"What is the value of ~l~ variable?" Q27
       4. 19:24-19:29 Q"What is the ~l~ variable's type?" D"He uses debugger in order to understand its type." Qe5
       5. 19:29-20:37 Q"Does the ~l~ object (~TRLabelShape~ class) keep background color?" Q6 c"answered-question" C"No, it does not keep background color."
          1. 19:29-19:45 Q"What is the ~TRLabelShape~ object about?" Qe5 D"Uses debugger in order to get variable type." c"debugger"
          2. 19:45-20:00 He browses ~TRLabelShape~ class. Q17.
          3. 20:00-20:10 He closes the c"debugger". He observes super class. Q7. 
          4. 20:10-20:37 Q17 he observes ~TRObject~ class, then ~TRShape~, then ~TRLabelShape~.
   17. 20:37-20:43 he goes to ~menu:callback:~ method and he observes =lbl color: Color black= line.
   18. 20:43-21:11 <<s10link10>> he goes to ~menu:background:callback:~ method where he can see ~createBackgroundFor:color:~ message call. C"After [[s10link2][15 minutes]] he finds out that he needs to use it."
   19. 21:11-21:57 <<s10link11>> he copy-pastes ~createBackgroundFor:color:~ method body into ~showSubmenuOf:~ and then he formats the pasted lines. c"miss-opportunity-was-before" c"false-assumption" C"He introduces an error that is not visible in ~RTView~ window; all the background boxes are rendered at the bottom of the main menu."
8. 21:57-22:19 W1 tried the example Q"Does my change works?" Q42 c"confidence" , it was without an error, but without visible effect S"It is weird. I need to understand more the think." C"Actually the effect is partially visible in ~RTView~, because the background boxes have a alpha canal and with every new click, the background is darker."
9. 22:19-31:18 <<s10link20>> Q"How does the code work? Why it does work as expected?" Q25 c"answered-question"
   1. 22:19-22:35 GQ"(17) What does the declaration or definition of this look like?" -> back in S1 he observes the pasted code.
   2. 22:35-22:54 <<s10link12>> After closing the example he executed again trying to inspect it but without a success. Q"How can I explore/inspect the graphical window? What is the object structure of the RTView UI?" Q27 c"ide-confusion" C"The IDE could offer halos or inspect from menu." c"halos" c"abandoned-question" c"halos-negative"
   3. 22:54-23:24 he writes =self halt= in S1, in W1 executed example -> c"debugger" DBG2 Q"Is this code called?" Q29 and executes the snippet. S"OK this code is called" D"He uses debugger in order to ensure if the code (part of method) is called."
   4. 23:24-23:44 exploring box in EyeTreeInspector I1 Q"How does this instance of ~TRBoxShape~ looks like?" Q27 S"I have the shape thing here" closes I1 and close c"debugger" DBG2. D"He uses debugger in order to understand if box variable is well set and if it is object he expects."
   5. 23:44-24:01 he observes the copied code in ~createBackgroundFor:color:~ then in ~showSubmenuOf:~
   6. 24:01-24:53 <<s10link13>> Q"What is the behavior/responsability of this ~addAnimation:~ code?" Q17 Commenting =self halt= and ~addAnimation:~ in order to understand what is its responsibility, in W1 executing the example again, first on previously opened ~TRView~, then for sure on a new one. c"abandoned-question" c"miss-opportunity" C"I am not sure if he understands the effect of the code."
   7. 24:53-25:07 <<s10link14>> S"I do not to put it [box] here [label of the main menu]." He found a bug in the pasted code, where the temporary variable names corresponded with the names in the method ~showSubmenuOf:~ c"false-assumption" C"Actually he does not need the line with ~TRConstraint~."
   8. 25:07-26:01 Q"How do the recent ~showSubmenuOf:~ method versions look like?" GQ"(25) How do the recent method versions look like?" he observes changes. Reverted to his first change he made and tried the example in W1
   9. 26:01-26:37 <<s10link15>> GQ"(23) How does the example work?" he executes the snippet. S"It works." C"Apparently he wants to get a working version and write the changes again in order to understand in what moment it does not work."
   10. 26:37-27:41 <<s10link16>> then he copy&pasted the code again from N4->S1 with change: S"I have to use l and not lbl" C"He still does not understand the code, because he translate ~l~ after ~box~."
   11. 27:41-28:01 he executes the snippet with result S"not too bad" because he had a visible result, although not a desired one. S"I like it :-)" Q"How my code changes work? Does it solve the task?" Q44
   12. 28:01-29:03 <<s10link17>> S"So it is more or less the right idea, but somehow it goes to another direction", observing in S1 why Q"Which part of code is responsible for this behavior [box placement]?" Q25 S"these lines should go before those ones" c&p in S1 c"false-assumption" C"He is not aware that ~addAnimation:~ happens asynchronously." 
   13. 29:03-29:36 In W1 executed the example Q"How my code changes work? Does it solve the task?" Q44 and lost any visible change as he had before, so he got back the lines in S1 and tried the example in W1 C"It does not solve the task, but he is satisfied with a visible effect."
   14. 29:36-30:14 <<s10link18>> S"I do not have idea how to delete those boxes" who are generating next to each other. Back in S1 Q"How can I delete the boxes (background)?" Q25 c"abandoned-question" C"He finds out how to fix the box position."
   15. 29:36-30:14 He observes ~showSubmenuOf:~ method. Q17 
   16. 30:14-30:36 S"I can do the same [addAnimation] for the box." he changes the code.
   17. 30:36-31:18 <<s10link19>> he executes the snippet. The box is finally were it is expected. He tried several times to move the menu from the corner because there was partially hidden. S"It works except the things [boxes] are not deleted and the color is pink, not blue."
10. 31:18-35:31 <<s10link21>> Q"How to make the think [box] disappeared?" GQ"(28) How to access the objects from here?" S"I am looking how to get the right color and how to make the think disappeared." c"abandoned-question" C"He thinks it is complicated task. He prefers to solve color propagation instead."
    1. 31:18-33:26 he observes ~createBackgroundFor:color:~ and ~showSubmenuOf:~ methods and explains what he thinks about it; what he has to do next. S"It is going to be complicated because the box is local variable here"
    2. 33:26-35:31 S"If I want to close it, I need to find where the label disappear and find the box there" (reachability question) Q"Where the menu items disappear? Where is this behavior?" Q3 c"abandoned-question"
       1. 33:26-33:54 S"I am going to see if RTMenuItem has something like click event." browsing in N4 Q"Does menu item has something like click event?" Qe4 He found ~TRMouseClick~ and callback parameter variable in N4.
       2. 33:54-35:31 Q"And does the submenu have also callback?" Q15 c"abandoned-question"
          1. 33:54-35:09 Q"Where is the submenu created?" Q3 He finds in ~menu:submenu:background:callback:~ that the main menu is collected among all fixed shapes; it is a weird solution which works now, S"but I could do something like that too for now"
          2. 35:09-35:31 Q"Where is it [callback input variable] set up?" Q3 c"abandoned-question" C"Likely abandoned question because he raised another one: how to solve the tasks using current knowledge."
11. 35:31-47:16 <<s10link22>> S"I am thinking that the closing issue is a little bit complicated, better to focus on the color propagation", S"So I have to think how to get it from this guy [RTMenuBuilder>>menu:submenu:background:callback: in N4] to this guy [showSubmenuOf: in S1]" Q"How to get the color information from here to here? How to access the objects from here?" Q28 C"he asks this question before and that time he had a good idea at the beginning the session at [[s10link1][03:00-04:36]]."
    1. 35:31-36:08 he thinks about his needs.
    2. 36:08-37:01 S"With one menu instead of two menus, I will have just blue color, I guess" Q"How the behavior changes if I write example that way?" Q34 c"prototype", he checked it in W1 by changing the example
    3. 37:01-37:36 Q"What class it is [of ~showSubmenuOf:~ method]?" Qe4 from S1 new Nautilus N7. It is ~RTMenuBuilder~ class.
    4. 37:36-38:23 Q"What is the type of this instance variable?" Qe5 He writes =self halt= in ~showSubmenuOf:~ in other to explore ~lbl~ variable; he executes the snippet. From the c"debugger" he explores the ~lbl~; S"ok, it is black, so it is the text". It is ~TRLabelShape~. D"He uses debugger in order to understand what variable is about (type) and what it holds (color)."
    5. 38:23-39:06 <<s10link23>> he explores instance variables of ~lbl~ in E1 -> canvas -> fixedShapes: S"Ok, the box shape is here with the right color" He finds the way to find a color; he could reach it from lbl -> canvas -> fixedShapes -> a box. C"Quite complex solution, he could use the idea from [[s10link1][03:00-04:36]]."
    6. 39:06-39:54 S"create background is here" he observes ~createBackgroundFor:color:~. He states there is no link between label and box (background). 39:54 S"When it is done [the box] there is nothing linking to the label."
    7. 39:54-40:13 c"confidence" Q"Is there any TRConstraint object?" GQ"(14) Is this class instantiated?" by allInstances. No, there is not.
    8. 40:13-41:16 S"Maybe I could take a box which is close to the label"
    9. 41:16-41:49 Q"Can I find a box using position?" Q28 He writes in the previous inspector =self position= trying if they [box and label] have a position.
    10. 41:49-44:40 he changes ~showSubmenuOf:~ method introducing ~color~ method variable.
    11. 44:40-45:05 he executes the snippet and obtains c"debugger" with a breakpoint. Q"Where is the breakpoint?" Qx"Not really question about application." He finds out that he did not accept the previous changes. D"This debugger was unexpected and he understands that something is wrong with his source code."
    12. 45:05-45:58 <<s10link24>> He fix the code and accepts the changes. c"ide-confusion" C"The square brackets are apparently not well visible. I remember that P4 in the November's session had problems to see them in pair."
    13. 45:58-46:08 he executes the snippet and he can see that it is a correct color, only alpha canal is different.
    14. 46:08-46:32 He remember something about ~alpha:~ message and he changes the ~showSubmenuOf:~ method accordingly.
    15. 46:32-47:16 he executes the snippet. It works except background deletion: S"for the deleting we could do the same hunting solution" S"On other hand the requirement is that the background appears, there was nothing about deleting it, right? :-D"
12. 47:16-59:40 The Session finished, the rest is interview.
** Session S11 with P4, familiar (Roassal 3D API same as in Roassal2)
   :PROPERTIES:
   :VideoFile: videos/S11-P4.m4v
   :FUEL: dflow/S11-P4.fuel
   :VIDEO-START-TIME: 2014-06-23T15:03:00.097426-04:00
   :Familiar: 1
   :SESSION-ID: S11
   :PARTICIPANT-ID: P4
   :END:
*** Tool Usage
1. 00:00-01:32 c"rest-time"
2. 01:32-05:15 c"static-tool"
3. 05:15-05:46 c"dynamic-tool"
4. 05:46-06:13 c"static-tool"
5. 06:13-06:17 c"dynamic-tool"
6. 06:17-10:46 c"static-tool"
7. 10:46-11:14 c"dynamic-tool"
8. 11:14-11:35 c"dynamic-tool" Test Runner
9. 11:35-12:07 c"dynamic-tool"
10. 12:07-12:30 c"static-tool"
11. 12:30-12:54 c"dynamic-tool"
12. 12:54-13:20 c"static-tool"
13. 13:20-14:20 c"dynamic-tool"
14. 14:20-14:24 c"static-tool"
15. 14:24-17:34 c"dynamic-tool"
16. 17:34-18:48 c"static-tool"
17. 18:48-19:03 c"dynamic-tool"
18. 19:03-19:14 c"static-tool"
19. 19:14-20:30 c"dynamic-tool"
20. 20:30-21:55 c"static-tool"
21. 21:55-22:06 c"dynamic-tool"
22. 22:06-22:25 c"static-tool"
23. 22:25-23:36 c"dynamic-tool"
24. 23:36-25:00 c"static-tool"
24. 25:00-25:06 c"dynamic-tool"
24. 25:06-26:17 c"static-tool"
25. 26:17-27:27 c"example-tool"
26. 27:27-27:45 c"static-tool"
27. 27:45-28:08 c"example-tool"
28. 28:08-28:46 c"dynamic-tool"
29. 28:46-29:38 c"example-tool"
30. 29:38-30:34 c"static-tool"
31. 30:34-30:40 c"example-tool"
32. 30:40-30:50 c"static-tool"
33. 30:50-30:54 c"example-tool"
34. 30:54-38:04 c"dynamic-tool"
35. 38:04-38:23 c"example-tool"
36. 38:23-38:39 c"rest-time"
37. 38:39-38:44 c"dynamic-tool" Test Runner
38. 38:44-41:50 c"static-tool"
39. 41:50-42:11 c"dynamic-tool"
40. 42:11-43:32 c"static-tool"
*** Transcript
1. 00:00-01:34 he explains what he does. S"Roassal3D should allow one to define shapes using metrics on model objects. And currently, shape may be defined on RTElement, which is not great." He is familiar with Roassal3D. S"I do not know technical details."
2. 01:34-02:13 <<s1link12>> He see some method that he should consider later. He writes a comment about it. It is not related to the task.
3. 02:13-04:16 He writes a test that defines the issue.
   1. 02:30-02:55 he searches for existing test cases. Qe6
      1. Q"Is there a test for the shape? Is there a test called R3ShapeTest?" Qx"Parent question" B,FC
      2. Q"Is there a CubeShapeTest?" Qx"Parent question" B
   2. 02:55-04:16 <<s1link1>> he creates ~R3CubeShapeTest~ class with ~testBasic~. S"I do not know if this feature is already tested or not. I could check it further, but you know, let's write one test. It is cheap."
   3. 04:16-04:30 he executes the test case. It works.
4. 04:30-04:51 <<s1link2>> He decides to check if the feature is already tested, but there is too many users of ~R3CubeShape~. Q"Is this feature tested?" Qe6 QT
   1. 04:30-04:41 Q"Is the R3CubeShape class referenced in a test?" Q12 AN S"I do not know which test I should modify about that. There was too many references." He wrote another one. C"The test case was found at minute 20:15."
5. 04:51-05:15 he writes ~testBasicWithMetrics~ test case.
6. 05:15-05:25 Q"Does the test case crash?" Qe7 BT, AN Yes, there is a c"debugger" DBG D"He uses debugger in order to understand why test case fails. He checks method return value and concludes that it is incorrent behavior."
7. 05:25-05:30 Q"What is the return value of the method el width?" Q27 AN PT in c"debugger" DBG He checks the return value of =el width=. D"He uses debugger for evaluating code."
8. 05:30-05:46 He explains what is wrong about the current API.
9. 05:46-06:13 he writes ~testBasicWithMetricsOnElement~ test case.
10. 06:13-06:17 Q"Does the test case crash?" Qe7 BT, AN Yes S"This is something I have to implement."
11. 06:17-06:30 he cleans the space.
12. 06:31-22:50 c"tdd" <<s1link13>> He browses ~RTShape~ class because the API he wants to implement in Roassal3D is done in Roassal2. And he wants to follow the same API. He compares Roassal3d and Roassal2 APIs and adapts it. He implements ~depthElement:~, ~depth:~
    1. 06:30-06:37 Q"Where is the definition of ~RTShape~?" FC Q17
    2. 06:37-06:40 Q"Which subclass has defined ~width~ and ~height~?" Q10 B
    3. 06:40-06:48 Q"Which superclass of R3Cube shape has instance variables width height, and depth?" Q10 B
    4. 06:48-07:02 Q"How does the methods height: heightElement: and heightFor:  look like?" Q17 B
    5. 07:10-07:14 Q"What is the name of input variable in heightElement:?" Qe2 B CP
    6. 07:45-07:47 Q"What is the definition of height: method?" Q17 B CP
    7. 07:55-07:57 Q"What is the name of input variable in height:?" Qe2 B CP
    8. 08:10-09:07 <<s1link3>> c"observer" The observer did not resist to point out an error in the code which could be revealed later when someone decide to use Roassal3D without Roassal. It is about ~r3Value:~ message call in ~depth:~ method.
       1. 08:34-08:44 Q"What is the last method I have edited before?" Qe9 B
       2. 09:05-09:07 Q"How does the methods depth: looks like?" Q17 B CP
    9. 09:07-10:27 he implements the same methods for ~height~.
       1. 09:27-09:35 Q"What is the input variable name of the recently edited method like heightElement:?" Qe2 B CP
       2. 09:40-09:44 Q"What is the comment of the recently edited method like heightElement:?" Q17 B CP
       3. 09:44-10:15 Q"What is the input variable name of the recently edited method like width:?" Qe2 B CP
    10. 10:27-10:46 he implements the same methods for ~width.~
        1. 10:27-10:34 Q"What is the method definition of height: looks like?" Q17 B CP
13. 10:46-11:15 he tests the new API and fixes the written test cases
    1. 10:46-10:52 Q"Does the recently written test cases pass now?" Qe7 BT AN No
    2. 10:52-10:59 one test case does not pass because he used a wrong message calls inside. Q"Why the test case has not passed?" Qe8 in c"debugger" DBG, AN"A wrong method was used" D"He observers why test case fails. He changes code inside the debugger."
    3. 11:07-11:10 Q"Does the fixed test case pass now?" Qe7 BT AN Yes
       1. He asked 4 times, likely in order to celebrate the work. (3 seconds of duration)
14. 11:15-22:50 <<s1link14>> He executes all Roassal3D test cases and fix them.
    1. 11:15-11:30 Q"Are all the Roassal3D tests green?" Qe7 TR
    2. 11:30-11:35 <<s1link4>> An inspector appears, but it should not. He thinks it is related to a tracker. But it is hard to understand where it comes from. He closes it.
    3. 11:35-11:45 Q"Why this test does not pass?" Qe7 TR -> c"debugger" DBG, AN S"They are broken because of my changes" D"He observes in the debugger failed code. He has to change code, that is not in stack, so he does not do much in the debugger."
    4. 11:50-11:55 He fixes the task case S"Let's fix that" Q"What is the definition of the test case?" Q17 TR->c"debugger" DBG D"He use debugger in order to clarify that it fails because of his recent change."
    5. 12:05-12:10 Q"What is the ~setUp~ of the test case?" Q17 TR->browse test->B
    6. 12:10-12:19 <<s1link5>> He introduced a bug to the setUp which is not apparent.
    7. 12:30-12:35 Q"Are all the Roassal3D tests green?" Qe7 TR
    8. 12:44-13:03 Q"Why the test case fails?" Qe8 TR->c"debugger" DBG, AN S"This is the same problem", B he fixes the test cases. D"He identifies in the debugger, that there is the same problem he fixed recently in another test case."
    9. 13:03-13:18 Q"What is the ~setUp~ of the test case?" Q17 B
    10. 13:20-13:22 Q"Does the test case pass?" Qe7 BT
    11. 13:23-13:29 <<s1link6>> C"There is a ~testApplyLayout~ test case that has already quite complex assert check. He prefers to check it later." Q"Why the test case fails?" Qe8 c"debugger" DBG, AN"Decided to look at other failing tests" D"He was observing the failing reason, but he closes it and goes to another failing test case."
    12. 13:29-13:35 Q"Does the other failing tests already pass?" Qe7 B, AN"No"
    13. 13:36-14:18 <<s1link7>> He tests ~testEdgesFrom~ c"observer" C"Actually observer asks him what is the problem about. He executes the test case again in order to explain it and in that moment he finds issue. There is ~roValue:~ message call instead of ~r3Value:~. Yet another help because of observer's intervention." Q"Why the test case fails?" Qe7 BT->c"debugger" DBG D"He observes values, evaluates expressions, fix source code." 
        1. 14:15-14:18 Q"What is the return value of the expression?" Q27
        2. 14:20-14:24 Q"Where the method roValue: is used?" Q12 B->KN->B"One sender"
    14. 14:33-14:39 Q"Are the red test cases pass now?" Qe7 BT"Everything is OK except ~testApplyLayout~, not really sure why."
    15. 14:41-19:21 <<s1link8>> He does not know if ~testApplyLayout~ fails because of his changes or it has neither  worked before. He forgot to execute tests before. He decides to fix it. Q"Why the testApplyLayout test fails?" Qe8 B
        1. S"I do not know if this test was red before my changes or not ... I do not thing so" Another developer in the room answered it was not.
        2. 14:20-14:23 Q"What is the return value of the expression?" Q27 PT in c"debugger" DBG D"He evaluates expression."
        3. 15:30-15:34 Q"What is the graphical representation of this test?" Qe8 ~builder open~ in c"debugger" DBG D"He uses debugger environment in order to observe objects. He opens RTView considering if it is correct figure."
        4. 15:38-15:42 <<s1link9>> Q"Does it looks like a right thing? Why not" Q41 c"false-assumption" He inspect view and observes scenery. He is excited about it, but he does not see that this is not intended composition.
        5. 16:02-16:05 Q"How does the ~setUp~ looks like?" Q17 B
        6. 16:10-16:14 Q"What is the return value of the expression?" Q27 PT in c"debugger" DBG D"He evaluates code, observes why the test case fails, change source code."
        7. 16:55-17:02 <<s1link10>> S"I believe the test has been wrong and the code is actually OK." c"false-assumption" C"Actually there is a problem about the test. It seems that the boxes should be above the red one."
        8. 17:15-17:18 <<s1link11>> Q"What is the graphical representation of this test?" Qe8 ~builder open~ in c"debugger" DBG He has doubt because he can see that other assertions does not work in the same test. D"He evaluates code and observes RTView."
           1. 17:22-17:27 Q"Why the red thing is not below?" Qx"Same as parent question." in the view S"I think the red thing should be below. ... Maybe it was OK before."
        9. 17:34-17:37 Q"What is the original version of the method I have changed?" GQ"(35) How do the recent method versions look like?" B -> RC He revert the changes.
        10. 17:50-18:48 He investigates the ~applyLayout~ method asking if the error is somewhere inside. He also thinks that maybe it is not worth to fix it, because the ~R3CityBuilder~ is going to be replaced by a new implementation.
            1. 17:50-17:53 Q"What is the definition of the method ~applyLayout~?" Q17 B -> KM -> IM 3 methods
            2. 18:24-18:27 Q"What are other methods of the class ~B3CityBuilder~?" Q6 IM -> B
            3. 18:30-18:35 Q"Does this method ~baseElement~ create a new object?" Q17
            4. 18:35-18:48 <<s1link12>> c"false-assumption" He changed code according the false assumption, B C"I think he is not really interested in deep understanding of the problem. He just try first thoughts and if a test pass, he could be happy."
        11. 18:48-18:51 Q"Does the test case pass now?" Qe7
        12. 18:51-18:56 Q"What is the graphical representation of this test?" Qe8 ~builder open~ in c"debugger" DBG he sees that he results is worst then before. D"He evaluates code and observes RTView."
        13. 19:10-19:13 Q"What is the original version of the method I have changed?" GQ"(35) How do the recent method versions look like?" B -> RC He reverts the changes in ~applyLayout~ method.
        14. <<s1link13>> "Let us move on. I believe this test is obsolete"
    16. 19:14-19:20 Q"Are all the tests pass?" Qe7 TR, AN"NO"
    17. 19:20-19:23 <<s1link9>> There is still the same inspector and he does not like it, but it is hard to reveal why it happens. Q"Why do I have here this window?" Q32 (hard to answer because it does not happen when each test executed)
    18. 19:22-19:32 he fixes ~testShapeSize~ test case Q"Why this test fails?" Qe8 TR->c"debugger" DBG D"He observes why test case fails and change source code."
    19. 19:40-19:43, 20:16-20:19 he fixes other tests: ~testShapeUsingModel~ At 19:52 <<s1link10>> he sees that there is a test case that he wrote at the beginning; so there is an overlap between test cases. Q"Does this test pass?" Qe7 TR
    20. 20:18-20:23 Q"Does all the test pass?" Qe7 TR there are still 3 test cases to fix
    21. 20:30-21:05 he decides to ignore the ~testApplyLayout~ test case and mark it as expected failure. Q"Where I should write that it is an expected failure?" Q38 B, then he get disoriented and went back to RT, to browse the test method -> B
    22. 21:05-21:35 c"chatter" He writes ~expectedFailure~ method and comments that ~R3CityBuilderTest~ should be removed.
        1. 21:05-21:10 Q"Should this class be removed?" Q38 Unsatisfied question because he needed to discuss with another developer to decide.
    23. 21:55-22:02 Q"Does all the test pass?" Qe7 TR There are two test
    24. 22:03-22:10 Q"Why this test still fails?" Qe8 QT
        1. 22:03-22:10 Q"Did I wrote the previous method well?" Q17 RT->B He renames ~expectedFailure~ into ~expectedFailures~.
    25. 22:25-22:28 Q"Does the class tests pass?" Qe7 B Yes.
    26. 22:31-22:36 Q"Does all the tests pass?" Qe7 TR There are two; apparently there is a one that fails only when executed with others.
    27. 22:50 <<s1link11>> He says, that he finished his tasks, the new API is implemented and test fixed. the two failing test cases are not related to the task.
15. 22:50-23:25 Q"Why this test fails?" Qe8 <<s1link15>> TR, there were two tests which does not fails when executed separately, but fails when executed together with other tests. -> unsatisfied answer.
16. 23:40-23:44 He commits the changes. Q"What changes I have made to this package?" Q35
17. 23:44-26:10 He mentions that he made test only for one shape and he considers if he should do more tests.
    1. 23:55-24:03 Q"Should I test other shapes?" Q38 Only raised, unanswered
    2. 24:03-25:00 he finishes the commit.
    3. 25:00-26:10 <<s1link16>> he observes other shape classes considering if there is something why it should not work
       1. 25:00-25:06 Q"Does the other shapes work after the change?" Qe7 tested by executing an example
       2. 25:06-25:15 previous QT Q"What are the differences between the shapes in Roassal related to height and weight?" Q34 B
       3. 25:19-25:22 Q"How do look like the tests I have wrote recently?" Q35 B
       4. 25:34 <<s1link17>> P12 points out that he checks shapes of Roassal2.
       5. 25:45-26:09 Q"What are the other [sphere] shapes?" Q9 B, actually P12 commented what are the other shapes are, and what are differences between two sphere shapes.
18. 26:10-29:18 c"example" Q"What are the differences between two sphere shapes?" Q34 B, Roassal 3D Example Browser -> B. He executed the example observing the objects. P12 explains the difference. Participant wants to see some examples. He executes one in ~R2RoassalExample~ class.
    1. 27:27-27:42 Q"How I should initialize the class?" Q41 TQ to two questions
       1. 27:27-27:33 Q"What the class looks like?" Q17 B
       2. 27:33-27:42 Q"What their methods looks like?" Q6 B
    2. 27:50-28:57 c"prototype" c"test" <<s1link18>> Q"What is a 'good' input value for the method ~recursionLevel:~?" Q34 B estimated to 5 without deep knowledge -> save image -> there were problem with example execution because of the input value c"false-assumption" Value 5 is too much. There is a problem to stop the computation; Pharo does not respond well. He writes 2 in the end. He observes differences between shapes.
19. 29:40-29:50 Q"What should be the initial value for the instance variable?" Q41 B P12 says 1.
20. 30:00-30:09 Q"What the internals [methods] of the class look like?" Q6 B He observes ~R3IcoSphereShape~ class
21. 30:16-30:19 Q"What is the implementation of the ~renderBaseShape:sharedGeometry:~ method?" Q17 B,KM,B
22. 30:22-30:28 Q"Do you think it [method implementation] is OK?" Q42 B P12 answers: Yes
23. 30:28-31:19 He decides to revert previous version of the example method and create a new method with the new code.
    1. 30:35-30:39 Q"How does the example looks like?" Q17 B
    2. 30:40-30:50 Q"What was the recent version of the method?" Q35 B, RC
    3. 31:03-31:19 Q"How does the example looks like?" Q17 W He observes difference between shapes.
24. 31:19-31:28 Q"Do you think 3 [input value] will be too much?" Q41 P12 answers: No. W, TE He changes the example and plays with different values for ~recursionLevel:~.
25. 31:28-35:00 Q"What is the difference between sphere objects?" Q34 W, TE He observes rendered shapes.
    1. he changes snippet and adds popup.
    2. 33:20-33:27 Q"Does addInteraction: method returns the object?" Q17 W, KM Yes, it returns.
26. 35:00-36:25 he puts the snippet into a ~R3RoassalExample~
27. 36:25-36:55 Q"How these two examples differ?" Q34 W, TE P12 says that there are two different models for ~lightingModel:~ Participant tests both examples.
28. 36:55-43:32 He refactors ~R3CubeShapeTest~ and creates ~AbstractShapeTest~ and others to test other shapes. He commits 
    1. 38:20-38:43 Q"Does all the tests pass?" Qe7 TR
    2. 38:50-39:15 Q"How do I want to continue on this class I have made recently?" Q38 B, deleted the class to continue on another one created before.
    3. 41:07-41:13 Q"What was the name of the recent class I have play with?" GQ"(e8) How are the recently browsed/observed entities called?" B
    4. 41:50-42:07 Q"Does all the tests pass?" Qe7 TR
29. 43:32 The session finished.
** Session S13 with P6, familiar (Replace Growl for Live Robot Programming UI)
   :PROPERTIES:
   :VideoFile: videos/S13-P6.m4v
   :FUEL: dflow/S13-P6.fuel
   :VIDEO-START-TIME: 2014-06-30T11:04:20.594631-04:00 
   :Familiar: 1
   :SESSION-ID: S13
   :PARTICIPANT-ID: P6
   :END:
*** Tool Usage
1. 00:00-00:47 c"rest-time"
2. 00:47-04:50 c"testing-behavior"
3. 04:50-09:19 c"static-tool"
4. 09:19-09:54 c"static-tool" Monticello Browser
5. 09:54-18:08 c"static-tool"
6. 18:08-18:19 c"dynamic-tool"
7. 18:19-18:33 c"static-tool"
8. 18:33-19:00 c"dynamic-tool"
9. 19:00-19:06 c"static-tool"
10. 19:06-19:19 c"dynamic-tool"
11. 19:19-23:31 c"static-tool"
12. 23:31-26:23 c"testing-behavior"
13. 26:23-26:59 c"dynamic-tool"
14. 26:59-27:41 c"testing-behavior"
15. 27:41-32:19 c"static-tool"
16. 32:19-32:54 c"testing-behavior"
17. 32:54-33:12 c"dynamic-tool"
18. 33:12-33:21 c"static-tool"
19. 33:21-33:42 c"testing-behavior"
20. 33:42-34:56 c"static-tool"
21. 34:56-35:14 c"testing-behavior"
22. 35:14-37:16 c"static-tool"
23. 37:16-37:48 c"testing-behavior"
24. 37:48-39:08 c"rest-time"
25. 39:08-47:49 c"static-tool"
26. 47:49-48:49 c"testing-behavior"
27. 48:49-49:05 c"static-tool"
28. 49:05-49:28 c"testing-behavior"
*** Transcript
1. 00:00-00:44 start DFlow.
2. TAKS 1: Change error handler
3. 00:44-03:52 he explains the task. He wants to improve error handling, to be able to save code (save button). He shows the handling issue. He is familiar with the source code.
4. 03:52-23:30 He makes an infrastructure to be able to do the error handling better
   1. 04:46-05:31 he prepares the his space.
   2. 05:31-08:46 He creates ~LRPErrorHandler~.
   3. 05:50-10:22 he implements singleton
      1. 05:50-07:08 <<s9link1>> Q"Where to put singleton variable?" Q38 B QT He is always confused about using ~classVariableNames:~ or class side instance variable. C"Interesting that he did it recently, but he cannot remember where." c"false-assumption" C"He decides to use ~classVariableNames:~ but it is better to use class side instance variable. He finds out this issue at [[s9link2][09:13]].
         1. 06:06-07:08 Q"Where did I have used singleton before?" Q1 B, UNQ He decides to find another singleton example c"example" to check the right solution. c"unanswered"
      2. 07:08-08:46 he creates accessor for the ~instance~. He defines new class ~LRPDummyErrorHander~
      3. 08:46-09:13 he creates instance setter ~instance:~
      4. 09:13-09:15 <<s9link2>> He remembered he did it in another package which was not loaded in the image. There is a playground with a snippet that has a code =LRPEV3Bridge disconnect=; it helps him to remember this code.
      5. 09:15-09:50 Q"What is the code of the package which is not loaded in the image?" Q17 MB and Snapshot Browser He decides to load the packages with the ~LRPEV3Bridge~ class. He finds out that it is class side instance variable. He decides to do it the same way in order to be consistent.
      6. 09:50-10:22 <<s9link3>> he changes the code of ~LRPErrorHandler~. He has no idea what is the difference.
   4. 10:22-12:37 he defines ~LRPErrorHandler~ API
      1. 11:04-11:16 Q"How the error handling is now implemented in ~LRPInterpeter~?" Q23 He need to know how the current handling is defined now in order to define new API. There is a protocol with 5 methods that ~LRPErrorHandler~ has to implement.
      2. 11:16-11:45 Q"How the error handling methods look like?" Q17 he observes source code of ~errorBlock:~, ~eventHasNotBool:value:~, ~eventNotFound:machine:~, ~machineNotFound:~, ~stateNotFound:machine:~
      3. 11:45-12:37 he defines the API on ~LRPErrorHandler~ class.
         1. 12:20-12:22 Q"Are the names of the methods right ones?" Qe2 OQ While copying the methods he mentions this question, but he did not consider it much.
   5. 12:37-13:45 he defines the same method for ~LRPDummyErrorHander~ that does not do anything
      1. 13:15-13:18 Q"What are the subclass responsibility methods?" Qe3 B He copy pastes the method names from one browser to another.
   6. 13:45-23:30 refactors current error handling behavior into a new class
      1. 13:45-14:34 he explains what to do next and creates ~LRPGrowlErrorHandler~ that will follow the current error handling behavior.
      2. 14:34-15:12 <<s9link4>> c"ide-improper-behavior" he would like to move methods from one class to another, but it does not work.
      3. 15:12-16:38 he copy-pastes the methods into ~LRPGrowlErrorHandler~.
         1. 16:10-16:15 Q"Are the methods I have created (copied) correct?" Q42 B There was a small issue about displayed methods, so he checkes if the methods he has already copy-pasted are correct.
         2. 16:17-16:23 Q"What method I have not copied yet?" Qe3 B he compares method names in order to know what he has already copy-pasted.
      4. 16:38-23:30 know he need to refactor the old error handling methods from ~LRPInterpeter~ and all the calls of this method should call the new one.
         1. 16:54-17:27 he changes the default error handler instance into ~LRPGrowlErrorHandler~.
         2. 17:27-17:55 Q"Who calls these guys [methods]?" Q12 B he explains that he needs to replaces methods where the error handlers are called. He asks for ~errorBlock:~ senders; there are 10.
         3. 17:55-18:08 he replaces code in ~interpretBlock:withScope:~ method.
         4. 18:08-18:15 Q"Does it returns my singleton?" Q27 in B -> II  He want to know if =LRPErrorHander instance= return the desired object. Yes, it returns.
         5. 18:16-19:18 <<s9link5>> Q"Does my singleton properly handle the error?" Q42 in Inspector He checks if ~errorBlock:~ method behaves as expected. He says that he does not know how to easily build test for UIs. He knows there are frameworks for it, but S"It is about an excuse, but I do not have time to spend lot of time on that. I know it is going to fights me at some point." 
            1. 18:18-18:35 Q"What is the method I could test?" Qx"Not really related to application, but to memory failure." B He does not remember properly the ~errorBlock:~ method name, so he checks it in the browser.
            2. 18:57-19:05 Q"What does the method do with the input variable?" Q20 B he checks again the ~errorBlock:~ method code.
         6. 19:18-19:45 <<s9link6>> he wants to change other occurrences but then he finds out, that they are from another package.
            1. 19:27-19:40 Q"What happens here? Should I change something here?" Q17 BS
         7. 19:45-19:53 Q"Can I remove the method?" Q42 B he removes the ~errorBlock:~ method from ~LRPInterpeter~.
         8. 19:53-19:58 Q"What are the senders of the method?" Q12 B he asks for ~eventHasNotBool:value:~ senders in order to replace the usage as before.
         9. 19:58-20:23 Q"What should I change in this method?" Q17 B he observes code and changes ~checkWith:~ method.
         10. 20:30-20:35 Q"Can I remove the method?" Q42 B he removes the method
         11. 20:35-20:40 Q"What are the senders of the method?" Q12 B senders of ~eventNotFound:machine:~
         12. 20:40-20:48 Q"What should I change in this method?" Q17 B he finds out that it is the one he just changed in ~checkWith:~
         13. 20:57-21:02 Q"What are the senders of the method?" Q12 B Senders of ~machineNotFound:~ method
         14. 21:02-21:12 Q"What are methods of my interest?" Q12 BS he observes both ~machineNotFound:~ senders
         15. 21:12-21:33 This code is ugly Q"What does the method do?" Q17 BS
         16. 21:52-22:50 Q"Can I remove the method?" Q42 B he wants to remove ~machineNotFound:~ method but the dialog says that there are two senders and he changed only one.
             1. 22:03 I have changed only one think, let us check it again
             2. 22:06-22:50 Q"What are the senders of the method?" Q12 B he observes both senders, but everything is fine.
         17. 22:50-22:53 Q"What are the senders of the method?" Q12 B Senders of ~stateNotFound:machine:~. Only 1 sender.
         18. 22:53-23:06 he changes the ~setCurrentState:actions:~ method.
         19. 23:06-23:30 he removes the ~stateNotFound:machine:~ method and the protocol tool.
5. 23:30-27:08 he tests the current solution
   1. 23:30-25:35 <<s9link7>> Q"Does my changes works [manual testing]?" Q42 TE in their application S"Because we do not have any test, we have to test it manually." He tests individual error handlings.
   2. 25:35-26:10 Q"Can we write test for it?" Q38 He thinks if he can writes test cases, he states that he could need to test what happens in the UI.
   3. 26:20-27:08 Q"Does my changes works [manual testing]?" Q42 TE in their application He changes the singleton of error handler. He tests it in his application
      1. 26:48-26:53 <<s9link8>> Q"Did I implement the methods in that class?" Q17 B he is not sure if he implemented methods for ~LRPDummyErrorHander~ class.
6. 27:08-30:25 he needs to get rid of dependences between UI and Interpreter packages. 
   1. 27:08-27:58 he changes the default error handler into ~LRPDummyErrorHander~
   2. 27:58-28:04 he moves ~LRPGrowlErrorHandler~ into UI package
   3. 28:04-28:42 he writes a comment for ~LRPGrowlErrorHandler~ class.
   4. 28:42-29:51 He writes comment for ~LRPErrorHandler~ and ~LRPDummyErrorHander~ classes.
   5. 29:51-30:25 <<s9link9>> he shows that he always writes class comments.
7. 30:35-37:41 <<s9link9>> he needs to use Growl error handler whenever UI is used (opened).
   1. 30:25-31:39 Q"Where I should set-up (initialize) UI error handler?" Q38 B He wants to set Growl error handler when the UI is opened. He search for a place where he could set the singleton.
      1. 30:47-31:39 Q"Do I consider the Spec staff?" Qx"He answers it without observing anything." B he answer it without searching anything C"There is a phone call."
   2. 31:39-32:20 he create ~initialize~ method in ~LRPUI~ class where he set up the singleton.
   3. 32:20-32:40 Q"Does my changes works [manual testing]?" Q42 TE in their application. He checks if the ~initialize~ method works. But it does not work as expected.
   4. 32:40-36:25 Q"Why it does not work?" Qe8
      1. 33:00-33:10 Q"What is the error handler [the instance variable]?" Q27 He finds out that the error handler is still the dummy one.
      2. 33:15-33:33 Q"Is the method ~initialize~ called?" Q31 B, TE He puts =self halt= into ~initialize~ method. He can see that it is not called. He did not expect it.
      3. 33:33-36:25 Q"Why the method ~initialize~ is not called?" Q30 he observes the ~initialize~ of ~LRPUI~ class
         1. 34:00-34:27 Q"How does the ~initialize~ method looks like in the superclass?" Q17 B then of ~ComposableModel~ class
         2. 34:30-34:43 Q"Did I write the name of method correctly?" Qe2 B he copy-pastes the ~initialize~ method name. It is the same name.
         3. 34:43-34:56 he changes ~initialize~ method
         4. 34:56-34:59 Q"Is the ~initialize~ method called?" Q31 he opens the application; not, it is not called
         5. 34:59-35:20 S"This is really surprising, now I am totally lost."
         6. 35:20-35:38 Q"How does the class looks like [methods' definitions]?" Q17 B He browses ~LRPInterpeter~ class and its methods.
         7. 35:38-35:45 <<s9link10>> Q"What is the definition of ~openOnInterpreter:~ method?" Q17 B Here he can see that ~LRPUI~ class is obsolete. He should use ~LRPUserInterface~ class.
         8. 35:49-36:25 Q"Why do I have two classes here?" Q35 B He does not understand why there are both classes. He explains that he did a lot of refactoring before, but he did not removed the old one.
   5. 36:25-37:00 he removes ~LRPUI~ and defines ~initialize~ on ~LRPUserInterface~.
      1. 36:44-36:48 Q"What were we doing before?" Qx"Not really about application." B He copy-pastes error initialization from a workspace.
   6. 37:00-37:17 Q"Is there another dead code around?" Q6 B he wonders if there is any other dead code, that he should remove. He does not think so.
   7. 37:17-37:41 Q"Does my changes works [manual testing]?" Q42 TE in their application. He tests the code and it works.
8. TASK 2: Build User Interface for ~LPRGrowlErrorHandler~.
   1. 37:41-39:00 he has a rest, tea, he explains what he has to do.
   2. 39:00-40:05 S"We need a ~ComposableModel~." He creates new class ~LRPErrorHandlerUI~. C"He is familiar with ~ComposableModel~ framework."
   3. 40:05-40:31 he writes a class comment.
   4. 40:31-41:59 <<s9link12>> he explains how he will construct the UI. He creates ~initializeWidgets~ C"He misspell the method name, he wrote ~intializeWidgets~."
      1. 41:10-41:18 <<s9link11>> Q"What are the names of instance variables I have just created?" Q17 B He does not remember the instance variable names he created in the ~LRPErrorHandlerUI~ class. He browses it in the other browser. Anyway it is interesting that he wrote ~errorList~ and ~cleanButton~ instead of ~errorlist~ and ~cleanbutton~.
   5. 41:59-42:14 He browses ~LRPErrorHandlerUI~ class and removes ~errorlist~ and ~cleanbutton~ instance variables.
   6. 42:14-42:35 he creates accessors. 
   7. 42:35-43:05 Q"How to set the label for this button?" Q38 TQ he wants to define button label, but he does not remember API.
      1. 42:40-43:05 c"example" Q"Where have I written the code like this?" Q4 B He finds an example in his recent code in ~LRPProgramEditor~ class.
   8. 43:05-43:22 he edits ~initializeWidgets~ method.
   9. 43:22-44:10 <<s9link13>> Q"Is the method name miss-spelled?" Qe2 B There should be the override indication. And he writes a new method named still with a typo.
      1. 43:50-44:02 Q"How it is written in the upper class?" Q17 B CP He checks how it is written in the super class and copy-pastes the name.
   10. 44:10-44:42 he renames method protocol name.
   11. 44:42-46:20 he defines ~initializePresenter~
       1. 44:55-46:09 Q"How to make the desired buttons behavior?" Q38 TQ He observes example in his ~LRPProgramEditor~ class.
          1. 45:20-46:09 Q"What the method I should call here?" Qx"Same as parent question." TQ
             1. 45:35-46:00 Q"How does the class ~ComposableListModel~ looks like?" Q17 B (in the end was ~ListModel~ class) He does not remember API of this class, so he browses it. 
             2. 46:00-46:09 Q"How does the method items: looks like?" Q17 B He finds out that he need to set ~items:~.
   12. 46:20-47:47 He needs to define a layout for the defining UI.
       1. 46:33-47:05 Q"How can I define the UI Spec layout?" Q38 TQ he checks in ~LRPProgramEditor~ class how ~defaultSpec~ methods looks like.
       2. 47:05-47:13 he copy-pastes the code.
       3. 47:13-47:19 <<s9link14>> Q"What is the name of the instance variable I have recently created?" Q17 B He does not remember how the instance variables are called, he browses ~LRPErrorHandlerUI~ class definition.
   13. 47:47-48:35 Q"Does my implementation works correctly?" Q42 W, TE He writes a code in workspace =LRPErrorHanderUI openWithSpec= and executes it. It raises the c"debugger" with ~MessageNotUnderstood~ of ~openWithSpec~. D"Debugger serves only as indication that the code is not valid. He closes the debugger and fixes the code."
       1. 48:00-48:17 Q"What is the method's name I should call?" Q5 W, CS The code completion tool helps him to recall that is it called ~openWithSpec~.
       2. 48:23-48:30 Q"Why it fails?" Qe8 W, c"debugger" DBG He actually does not search for this information, he recalls it and fixes the snippet. He should call it on instance. D"Explained above."
   14. 48:35-49:04 he observes UI and states that he should change layout, but it works. He fixes ~defaultSpec~ method.
   15. 49:04-49:11 Q"Does my implementation works correctly?" Q42 W, TE Yes, now it has a better layout.
9. 49:28 Session finished. Then follows interview.
** Session S1 with P1, unfamiliar (Implements double click in Roassal2)
   :PROPERTIES:
   :VideoFile: videos/S1-P1.m4v
   :FUEL: dflow/S1-P1.fuel
   :VIDEO-START-TIME: 2014-06-27T15:56:19.227227-04:00
   :Familiar: 0
   :SESSION-ID: S1
   :PARTICIPANT-ID: P1
   :END:
*** Tool Usage
1. 00:00-00:20 c"rest-time"
2. 00:20-02:28 c"dynamic-tool"
3. 02:28-04:33 c"static-tool"
4. 04:33-04:45 c"dynamic-tool"
5. 04:45-06:36 c"static-tool"
6. 06:36-06:47 c"rest-time" problems with source code (*.sources)
7. 06:47-07:15 c"static-tool"
8. 07:15-09:35 c"rest-time" problems with source code (*.sources)
9. 09:35-14:44 c"static-tool"
10. 14:44-15:02 c"dynamic-tool"
11. 15:02-31:20 c"static-tool"
12. 31:20-31:45 c"static-tool" he searches for examples in Java on the Internet
13. 31:45-32:21 c"static-tool"
14. 32:21-32:49 c"static-tool" internet
15. 32:49-34:11 c"static-tool"
16. 34:11-35:33 c"dynamic-tool"
17. 35:33-36:24 c"static-tool"
18. 36:24-37:36 c"static-tool" on the internet
19. 37:36-38:00 c"static-tool"
20. 38:00-38:14 c"dynamic-tool"
21. 38:14-38:44 c"static-tool"
22. 38:44-39:09 c"dynamic-tool"
23. 39:09-41:34 c"static-tool" internet
24. 41:34-44:50 c"static-tool"
# 24. 41:34-48:18 c"static-tool"
# 25. 48:18-48:46 c"dynamic-tool"
# 26. 48:46-51:13 c"static-tool"
# 27. 51:13-51:26 c"dynamic-tool"
# 28. 51:26-52:57 c"static-tool"
# 29. 52:57-53:17 c"dynamic-tool"
# 30. 53:17-53:52 c"static-tool"
*** Transcript
1. 00:00-00:21 He starts DFlow
2. 00:21-01:55 Observer explains the tasks with prepared example c"easy-to-reproduce". He executed and tried the working example. W c"workspace" Explaining how to do think-aloud protocol. He was observing the example. W c"workspace"
3. 01:55-26:35 He explores the code Q25 c"static" c"answered-question" 
   1. 01:55-02:27 Observing the example W c"workspace" GQ"(25) How does the example work?" c"easy-to-reproduce"  c"answered-question" 
      1. 01:53 <<s7link1>> He observes that there are two prefixes RT and TR, he says that it is a strange, but he does not explores why it is like that.
      2. Q"How does the example looks like?" Qx"Similar to the parent question." W c"workspace"
      3. Q"How does it change the color?" Qx"Similar to the parent question." W c"workspace"
   2. 02:27-03:30 Q"How is the TRMouseClick implemented?" He have seen the class hierarchy and implementation of each method in order to understand what it does and how it works. B c"browser" GQ"(6) What are the parts of this type?"  c"answered-question" 
      1. 02:40-03:10 What is the purpose of these methods? B c"browser"
         1. 02:40-02:43 <<s7link2>> Q"What is [input variable] anObject?"  c"answered-question"  B c"browser" UNQ C"It was not apparent what is the type of input variable called anObject" GQ"(18) What are the arguments to this function?"
            1. 02:55 He found in initialisation that anObject is boolean value. B c"browser"
      2. 03:20 S"The class ~TRMouseClick~ and their methods does not say more about their purpose."
         1. 03:20-03:30 I suppose he was looking for some behavior related to triggering of the event: GQ"(3) Where is there any code involved in the implementation of this behavior?"  c"unanswered-question" 
   3. 03:30-26:35 <<s7link3>> S"I do not know how this block [when:do:] is executed and how it receives the event. No s cmo le [a este bloque en when:do:] llega el evento." -> Q"Where is this input value [block] used?" He wants to know when the event is triggered (it means where the block is used). C"Interesting he did not tried self halt technique." GQ"(15) Where is this variable or data structure being accessed?" c"abandoned-question" C"Once he found where ~TRMouseClick~ is instantiated, he changed focus."
      1. 03:35-05:18 As he did not found any event triggering in the TRMouseClick class, he decided to look at ~when:do:~ implementation Q"How is the ~when:do:~ method implemented?" W c"workspace" KM IM(10) GQ"(17) What does the declaration or definition of this look like?"  c"answered-question" 
         1. 03:50-05:18 TQ Q"Which class corresponds to my method call when:do:?" IM Actually he then forgot about IM window, because he found the method in B c"browser". GQ"(e4) Which method implementation corresponds to my question?" c"answered-question" 
            1. 04:30-04:54 <<s7link4>> S"The class does not have when:do: method." IM C"When the expected class is not mentioned in the ImplementorsOf Browser, it is not apparent what method is of the interest."
               1. 04:34-04:45 As it is not apparent what method he should look at, he asked Q"What instance has this variable?" GQ"(e5) What is the type of this variable?" W c"workspace" II, S"It is RTElement." c"answered-question" 
               2. 04:45-04:54 Then he browses the class RTElement Q"What does the definition looks like?" B c"browser" GQ"(6) What are the parts of this type?" c"answered-question" 
            2. 04:54-05:51 Then he asked Q"Where is the implementation of when:do: for the class RTElement?" B c"browser" GQ"(e1) Where the method is defined in the type hierarchy?" c"answered-question" 
               1. 04:55 S"It does not have the method."
               2. 04:57-04:59 Q"Does it have the superclass?" Q8 S"No." B c"browser" c"answered-question" 
               3. 04:59-05:00 <<s7link5>> Q"Does it have the other superclass?" Q8 S"Yes." B c"browser" c"answered-question" 
            3. 05:18 he goes back to IM to confirm that it is the class he were looking for.
      2. 05:18-05:56 <<s7link7>> interested who is ~self announcer~ Q"What is the return value of the method announcer?" GQ"(e5) What is the method's return value?" as he closed the browser before, he had to open it again to find the class with ~when:do:~ B c"browser"  c"answered-question" 
      3. 05:56-06:11 as the ~when:do:~ calls announcer when:do: he is interested in this implementation Q"How does the method look likes?" GQ"(17) What does the declaration or definition of this look like?" c"answered-question" 
         1. 06:11-09:40 <<s7link6>> he found out there are problems with the PharoV30.sources file. This is the time he spent to fix this issue on his computer.
         2. 09:40-10:45 Q"How the TRMouseClick knows when the click happens?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?" c"unanswered-question" 
            1. 09:40-10:15 he was observing the class Announcer and methods called deep from when:do: GQ"(17) What does the declaration or definition of this look like?"  c"answered-question". Then he understood that the Announcer comes with Pharo not with Roassal. So he asked: 
            2. 10:15-10:30 Back in the ~TRAnnounceableObject~ observing the methods around ~when:do:~ Q6  c"answered-question" 
            3. 10:30-10:45 He goes through the method call (to Announcer's methods) again in order to understand where the block is stored. GQ"(25) How the behavior is distributed over the types?" B c"browser"
      4. 10:45-11:05 Then back in the definition of RTMouseClick asked Q"How the class RTMouseClick is related to the Announcer?"  GQ"(22) How are these types or objects related? (whole-part)"  c"answered-question"
         1. 10:55-11:05 Q"What is the superclass of it?" GQ"(8) Where does this type fit in the type hierarchy?", S"OK it is subclassed from Announcement." B c"browser" c"positive-progress"  c"answered-question" 
      5. 11:05-17:08 back on Announcer Q"How it [Announcer] knows when to announce the event TRMouseClick (when do a click)?" GQ"(25) What is the behavior that these types provide together and how is it distributed over the types?"  c"unanswered-question" 
         1. 11:31-12:10 solving low battery.
         2. 12:10-12:50 <<s7link8>> Q"Where are the registered announcements triggered? Who calls those announcements?" GQ"(15) Where is this variable or data structure being accessed?" observing all Announcer's methods. c"answered-question" 
            1. 12:50-13:40 Q"Who calls the method subscriptions?"  GQ"(12) Where is this method called or type referenced?"  B c"browser" SN observing all the senders c"answered-question" 
            2. 13:59-14:44 as he observing the methods Q"When it calls aValuable value?" GQ"(15) Where is this variable or data structure being accessed?" c"abandoned-question"
               1. 14:05-14:09 <<s7link10>> he observes ~announce:~ method Q17 c"miss-opportunity" c"answered-question" 
               2. 14:21-14:44 <<s7link9>> c"observer" The observer asked him if he understood well that the objective is to have class ~TRMouseDoubleClick~. It is so hard not to interact, I tend to behave as in a pair programming session. Because of that interuption he went back to ~TRMouseClick~ class observing the methods.
                  1. 14:40 <<s7link11>> he identifies that ~announce:~ is likely the method that triggers the events.
                  2. This question changes his focus.
               3. 14:44-15:35 back in the workspace thinking about a solution
         3. 15:35-16:53 <<s7link14>> c"miss-opportunity" C"He could read ~mouse*:~ methods and understand how the events are triggered." He was observing other classes in the package Trachel-Core and found ~TRMorph~. GQ"(3) Where is there any code involved in the implementation of this behavior?" As he said accidentally he found this object with methods ~mouse<something>~. He was still thinking about the ~Announcer~ and how and when it raise the ~TRMouseClick~ event. B c"browser"
         4. 16:53-17:08 Closing the Browser with ~Announcer~ stating S"Announcer does not trigger anything.", summarizing his findings.
      6. 17:10-17:49 <<s7link12>> Q"When are the events [RTMouseClick] called?"  GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"  c"answered-question"  browsing methods in TRElement and superclasses, then finally found announce: method and stated S"Here it is."
      7. 18:10-19:07 Q"Who calls the method announce: inside the Roassal package?" GQ"(12) Where is this method called or type referenced?" B c"browser" -> SN(206) C"As he did not found anything interesting in the Roassal, he was listing other senders and maybe because of similarities between RT for Roassal and TR for Trachel he looked at Trachel objects." c"unanswered-question" 
         1. 18:55-21:55 <<s7link13>> When in SN(206) in ~TRCompositeShape>>announce:~ stated S"Someone has to create this event." GQ"(21) Who creates this object assigned to method's input variable?" c"abandoned-question"
            1. 19:07-21:55 <<s7link15>> Observing how the Announcer deliver the event.
               1. 20:09 S"Announcement class handle the announcement."
               2. 20:10-20:35 <<s7link14>> Q"Who implements ~handlesAnnouncement:~ method?" GQ"(11) Who implements this interface or these abstract methods?" B c"browser" C"He searches for ~handlesAnnouncement:~ method in ~TRMouseClick~ class hierarchy. But on the instance class, not on class side. He could ask for all implementors." c"abandoned-question" c"lost"
               3. 20:35 S"I am lost." closing the browser with RTMouseClick when did not found what he has expected. He expected that each announcement class implements ~handlesAnnouncement:~.
               4. 20:35-21:37 summarizing what he found out and browses all the classes and methods involved.
               5. 21:41 He found the method ~handlesAnnouncement:~
      8. 22:05-22:45 <<s7link16>> Q"Who call announce: when someone makes the mouse click?" Q13 He thinks it is Morph who manage the event triggering. C"He concludes well how the ~TRMouseClick~ is triggered." c"positive-progress" c"unanswered-question" 
         1. 22:30-22:45 Asking for senders Q"Who call announce:"?  GQ"(12) Where is this method called or type referenced?" B c"browser" -> SN(206)
            1. 22:35-22:45 <<s7link17>> S"I am looking for a morph who sends announcements (events) to Roassal." -> Q"Is there a Morph which sends announcements (calls method announce:) to an Roassal object?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"  SN(206) he found Morph stating S"OK" and closing the SN. c"miss-opportunity" C"He could check ~TRMorph~."  c"unanswered-question" 
            2. Likely unsatisfied answer.
      9. 22:50-24:45 Q"Who creates the instance of ~TRMouseClick~?"  GQ"(21) How are instances of these types created and assembled?" TQ  c"answered-question" 
         1. 22:50-23:45 Q"Who reference the ~TRMouseClick~ in Trachel?"  GQ"(12) Where is this method called or type referenced?" from W c"workspace" -> B c"browser" -> class references (41)  c"answered-question" 
            1. 23:10-23:45 <<s7link18>> He clicks on ~TRMorph>>rtMouseClick:~ method. Q17  c"answered-question" 
         2. 23:45-24:05 c"observer" Observer asked what he is thinking about. And he started explaining it.
      10. 23:43-26:35 Q"What are the yellow, red, blue methods about?  What is the difference?" GQ"(34) How does the system behavior vary over these types or cases?" He wants to know what ~blueButtonChanged~, ~redButtonChanged~, ~yellowButtonChanged~ do. What information they provide.
          1. 23:43-26:35 He observers ~rtMouseClick:~ Q17  c"answered-question" 
          2. 24:44-25:00 He found it in ~rtMouseClick:~ c"positive-progress" and as he found some if statements depending on ~blueButtonChanged~, he asked Q"What is the declaration of the method?" GQ"(17) What does the declaration or definition of this look like?" He reads method comment.  c"answered-question" 
          3. 25:00-26:35 observing ~MouseEvent~ class. Q6  c"answered-question" 
4. 26:35-30:00 <<s7link19>> S"I expect a double click method in the ~MouseEvent~ class. I expect that Morph supports double click by default. But it looks like it does not support it." -> Q"Is there a method managing double click?" GQ"(5) Is there an entity named something like this in that unit (project, package, or class, say)?" Then he expects to write something like ~evt isDoubleClick ifTrue: ...~. c"false-assumption" C"Morph supports double click."  c"wrongly-answered-question" 
   1. 27:35-28:53 Q"Why it says anyMask: 4? What is anyMask: about?"  GQ"(25) What is the behavior that these types provide together and how is it distributed over the types?" B c"browser" -> implementor of -> B c"browser". he did not understood the code which is low level (bit manipulation).
   2. Likely unsatisfied questions because he then went to ask following:
5. 30:00-30:12 <<s7link20>> Q"Who sends ~rtMouseClick:~?" GQ"(12) Where is this method called or type referenced?". S"Here it is" C"He likely did not understood much the implementation in mouseDown: as there is some kind of indirect setup of events handling." c"miss-opportunity" C"He could check what ~waitForClickOrDrag:event:selectors:threshold:~ is about."
6. 20:12-30:26 Q"Why it [TRMorph] has these methods [mouseDown:, mouse...]?" GQ"(25) What is the purpose of the method?" S"Ahh, because it is subclass of Morph"
7. 30:26-30:37 Q"Does the Morph has the method mouseDown:?" GQ"(6) Does this type override the method?"
8. 30:37-31:10 Then he started observing other methods Q"How does the Morph implements double click?" GQ"(5) Is there an entity named something like this in that unit (project, package, or class, say)?" B c"browser" S"It does not implement."
9. 31:10-44:50 S"OK. I know how I will do it. It is not supported and I have to implement it." Q"How can I implement the double click event?" Q38
   1. 31:21-32:50  <<s7link21>> Q"How it is implemented in Java?" GQ"(4) Is there a precedent or exemplar for this?" browsing in Web. S"I have an idea how to do it, but I want to check my idea with an existing implementation."
      1. 31:45-32:22 He found that java event has getClickCount method. Q"Does the Morph or MouseClick has something like getClickCount?" GQ"(5) Is there an entity named something like this in that unit (project, package, or class, say)?"  looking for instance variables. S"It does not have such information". B c"browser"
   2. 33:45 he closed all the old windows.
   3. 34:00-34:33 <<s7link22>> Q"What is the type of this event [evt]?" asking in ~rtMouseClick:~ by writing ~self halt~. C"This is the first time he uses =self halt=."  GQ"(18) What are the arguments to this function?" W c"workspace" -> executing the example -> c"debugger" DBG seeing the evt S"Is MouseButtonEvent". D"He puts breakpoint in order to know if a particular code is executed. Then he also observes variable values." He were also observing the instance GQ"(27) How does this data structure look at runtime?" in order to compare it with the following: 
   4. 34:45-34:52 Q"What happens with double click?" he closed the previous c"debugger" DBG and made double click. GQ"(34) How does the system behavior vary over these types or cases?" He received two DBGs. D"He uses breakpoint in order to know if the code is called on double click. He also observes if variable has same values."
   5. 34:53-35:20 Q"Is the event variable [evt] of the same type as the one before?" in c"debugger" DBG. GQ"(18) What are the arguments to this function?" S"Yes. it is the same type." Then he close the DBGs. D"He observes if the variable value is the same as in single-click use case before."
   6. 35:20-36:22 He was summarizing how to implement it.
   7. 36:22-41:34 <<s7link23>> Back in the Web trying to find how it is implemented in Java because he thinks it is not implemented in Morph. He found DoubleClickDetector. Meanwhile he is thinking and comparing about three ideas how to implement double click. c"false-assumption"
      1. 37:40-38:00 One of the ideas was about utilizing TimeStamp. So he observes how it looks like Q"How does the definition of TimeStamp look like?" GQ"(6) What are the parts of this type?" B c"browser"
      2. 38:00-39:25 He is playing with DateTime in order to understand how to get a timestamp in order to know how precise it is Q"How precise is the timestamp?  (milliseconds?  nanoseconds?)" GQ"(23) How is this feature or concern (object ownership, UI control, etc.)  implemented?" 
         1. 38:15-39:25 He is observing Date class Q"How it calculates the actual time?" GQ"(6) What are the parts of this type?".
            1. 38:44-39:08 ~Date today~ in W c"workspace" II Q"How does the object looks like?" GQ"(27) How does this data structure look at runtime?" he do not understand much the string defining the date.
            2. 39:08-39:25 Back in the browser to see the time he saw before. Cannot find the code on the web page.
      3. 39:25-41:34 Asking on the Web for "java MouseEvent source code" in order to know Q"How or when it resets the click counter?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?". He have found it does not say how to compute click count or reset click count. It just knows the number.
         1. 41:10-41:34 Another question "MouseEvent java how measure the click count" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"
         2. Unsatisfied answers.
   8. 41:34-43:38 Back in Pharo in TRMorph>>rtMouseClick: as he wants to implement click counter as an instance variable to TRMouseClick, he is asking Q"Who creates the event [evt in rtMouseClick: evt]? Or When it is created?" GQ"(21) How are instances of these types created and assembled?"
      1. 41:52-42:20 <<s7link24>> To answer it he is asking Q"Who call rtMouseClick:?" GQ"(12) Where is this method called or type referenced?" B c"browser", only one method called RTMorph>>mouseClick:. Then observing its implementation Q"How does the definition looks like?" GQ"(6) What are the parts of this type?"
      2. 42:20-42:52 Q"Who call mouseDown:?" GQ"(12) Where is this method called or type referenced?" B c"browser" SN(37) Observing the methods in SN. Then he found method Morph>>click and decided to browse it GQ"(6) What are the parts of this type?" in B c"browser". Q"How does the Morph class looks like?  Does it do something related to mouse event creation?" GQ"(3) Where is there any code involved in the implementation of this behavior?"
      3. 42:52-43:22 <<s7link25>> He founds ~doubleClick:~ in the same list of class methods. Q"How does the method doubleClick: looks like?" GQ"(6) What are the parts of this type?"
      4. 43:22-43:38 Q"Who implements the doubleClick:fromMorph:?"  GQ"(17) What does the declaration or definition of this look like?" B c"browser" IM(3) which he found in the method doubleClick:
      5. I think he forgot about this question as he found another scent (doubleClick: method).
   9. 43:38-43:58 He think that TRMorph should rewrite doubleClick:  Q"Does the TRMorph implements doubleClick: method?" GQ"(11) Who implements this interface or these abstract methods?" B c"browser" c"positive-progress"
   10. 43:58-44:18 Then he found handleMouseMove: and other handle* methods on TRMorph and he is interested if on Morph is something like handleMouseDoubleClick: Q"Does Morph class have method called something like handleMouseDoubleClick:?"  GQ"(5) Is there an entity named something like this in that unit (project, package, or class, say)?" B c"browser" S"No."
   11. 44:18-44:50 As he has not found the expected method he is interested of Q"What does handlesMouseDown: do?" GQ"(6) What are the parts of this type?" B c"browser"
10. 44:50 The session finished.
** Session S3 with P3, unfamiliar (Roassal2 Menu background color, add edgesToAll: messages)
   :PROPERTIES:
   :VideoFile: videos/S3-P3.m4v
   :FUEL: dflow/S3-P3.fuel
   :VIDEO-START-TIME: 2014-07-10T14:56:33.66767-04:00
   :Familiar: 0.5
   :SESSION-ID: S3
   :PARTICIPANT-ID: P3
   :END:
*** Tool Usage
1. 00:00-02:11 c"rest-time"
2. 02:11-02:28 c"dynamic-tool"
3. 02:28-03:23 c"static-tool"
4. 03:23-03:40 c"dynamic-tool"
5. 03:40-07:41 c"static-tool"
6. 07:41-08:07 c"dynamic-tool"
7. 08:07-12:56 c"static-tool"
8. 12:56-13:49 c"dynamic-tool"
9. 13:49-14:09 c"static-tool"
10. 14:09-14:53 c"dynamic-tool"
11. 14:53-17:11 c"static-tool"
12. 17:11-17:19 c"dynamic-tool"
13. 17:19-19:22 c"static-tool"
14. 19:22-21:10 c"dynamic-tool"
15. 21:10-23:25 c"static-tool"
16. 23:25-24:02 c"dynamic-tool"
17. 24:02-24:32 c"static-tool"
18. 24:32-24:45 c"dynamic-tool"
19. 24:45-26:44 c"static-tool"
20. 26:44-27:25 c"dynamic-tool"
21. 27:25-28:20 c"rest-time"
22. 28:20-29:15 c"dynamic-tool"
23. 29:15-31:33 c"static-tool"
24. 31:33-34:21 c"dynamic-tool"
25. 34:21-35:05 c"static-tool"
26. 35:05-35:27 c"example-tool"
27. 35:27-35:46 c"static-tool"
28. 35:46-35:55 c"example-tool"
29. 35:55-37:22 c"static-tool"
30. 37:22-41:25 c"dynamic-tool"
31. 41:25-41:35 c"static-tool"
32. 41:35-47:54 c"dynamic-tool"
33. 47:54-48:11 c"static-tool"
34. 48:11-48:25 c"dynamic-tool"
*** Transcript
1. 00:00-01:16 He starts DFlow and reads the task.
2. 01:16-02:12 He decided download the latest version of Roassal 2 from Monticello.
3. 02:13-02:25 He is observing and executing the example with the bug. Q"How does the bug looks like?" GQ"(e8) What does the failure look like? " W c"workspace" c"confidence"
4. 02:34-02:40 observing ~RTMenuBuilder~ Q"How does RTMenuBuilder look like?" GQ"(17) What does the declaration or definition of this look like?"
5. 02:40-02:50 and he immediately observes (only names) the other classes in the package Builder-Menu. Q"What are other classes in the package Builder-Menu? (EFP1) What are the other types in that unit (package)?" Q6 B
6. 02:50-06:30 Then he went back to see the implementation of ~menu:submenu:background:callback:~ Q"How does the implementation of menu:submenu:background:callback: look like?" GQ"(17) What does the declaration or definition of this look like?"
   1. 03:02-03:15 Then he is focused on aColor input variable and asking where it is used Q"Where the input variable aColor is used?" GQ"(15) Where is this variable or data structure being accessed?" and he found that it is only used for parent menu. B
   2. 03:15-03:40 then he goes to W trying to change input variables of color. Q"What does happen with different colores?" GQ"(34) How does the system behavior vary over these types or cases?" W c"workspace" c"prototype" S"It works only once" it means only the first definition of the color is used. Then he tries to switch the colors and tries the example once more, stating S"This color is only for the parent menu."
   3. 03:40-04:11 Observing the method and line with TRMenuItem, where he immediately adds new method ~color: aColor~. GQ"(38) Where should this branch be inserted or how should this case be handled?" B
   4. 04:11-04:53 <<s11link1>> Then he browses the RTMenuItem class and writes accessors ~color:~ and ~color~, and instance variable ~color~. C"He changes directly changes the code comparing to S10 where the user hesitated for a long time to change the code."
   5. 04:53-06:30 then back in the method ~menu:submenu:...~ he asks Q"At what time it opens parentMenu? Or How is the open action on parentMenu implemented?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?" B
      1. 05:05-05:16 <<s11link2>> Then he browses the ~createParentMenu:~ in order to understand the implementation Q"How does the createParentMenu: look like?" GQ"(17) What does the declaration or definition of this look like?" B and see line with ~showSubmenuOf:~ stating S"Here it is, on click it calls showSubmenuOf:." B C"He identifies after a few minutes the important method for his change tasks; in comparison to session S10."
      2. 05:16-06:30 he browses the ~showSubmenuOf:~ understanding how it is implemented GQ"(17) What does the declaration or definition of this look like?". Stating S"I suppose that lbl is parent menu. If it is opened, then on the click the menu is closed. Here it creates the menu items."
         1. 06:10 He states S"I do not understand much this part of the method showSubmenuOf:"
         2. 06:18 S"I believe here the menu items are created"
         3. 06:22 S"And here the positions are set"
7. 06:30 he states in method ~showSubmenuOf:~ S"here I have to add background."
8. 06:35-08:08 he asks Q"How is the background created for the parent menu?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"
   1. 06:39-06:44 goes to method ~createParentMenu:background:~ observing the implementation where he see another method Q"How does the method look like?"  GQ"(17) What does the declaration or definition of this look like?" which creates background
   2. 06:44-07:05 then he asks Q"Why it does not do the same things [parent menu label and background color] at the same time? (d3) Why was this code implemented this way?" Q25
      1. 06:55-07:05 goes to method ~createParentMenu:~ GQ"(17) What does the declaration or definition of this look like?"  stating S"I think it should be simply a label [TRLabelShape]" GQ"(20) What data is being modified in this code?"
      2. 07:05-08:08 <<s11link3>> then he goes to method ~createBackgroundFor:color:~ GQ"(17) What does the declaration or definition of this look like?" observing the implementation. C"Since now he knows how to create a background."
         1. 07:15-07:32 he is surprised that the color has hardcoded alpha canal asking Q"Is it because of some style? (US1) Why is this feature implemented that way?" Q25 S"I do not know."
         2. 07:32-08:08 Then c"observer" asks him what does he do not know. If I remember, I have not understood what he said. And he is explaining that when the menu is created it uses two shapes. He remembers that in Roassal 1 it was possible do this with one shape. He believes that in Roassal 2 one element can have only one shape. C"Apparently people are confused between TR (Roassal2) or TR (Trachel) package. Or maybe it is confusing because it is not common to manipulate with Trachel shapes in Roassal 2 package."
9. 08:08-12:55 <<s11link4>> Back in ~showSubmenuOf:~ thinking how to implement the background here. Then he starting to write and thinking GQ"(1) Which type represents this domain concept or this UI element or action?" C"he starts to modify the code."
   1. 08:55-09:12 This item variable should be RTMenuItem. Q"What type is the temporary variable ~item~?" Qe5 B
      1. 09:06-09:12 Then he asks who implements ~execute:~ which is called on the ~item~ Q"What type is the item variable?"  GQ"(17) What does the declaration or definition of this look like?" C"In order to understand what type a variable is, ImplementorOf strategy is used". B -> IM(9) S"It is RTMenuItem"
   2. 09:12-10:40 <<s11link5>> Then he believed that ~m~ is TRLabelShape ~createBackground: m color: item color~ C"As Pharo is not static typed, he usually suppose the type according to context."
   3. 10:40-11:00 He is checking if the implementation is correct by seeing what he wrote in ~showSubmenuOf:~ GQ"(23) How is this feature or concern (object ownership, UI control, etc.)  implemented?"
   4. 11:00-11:28 Then he moved to next lines of the method ~showSubmenuOf:~ and thinking about the animation and how he should alter code here. Q"How the backgrounds should be processed here?" GQ"(42) What will be (or has been) the direct impact of this change?"
   5. 11:28-12:55 altering the code and stating that S"this index is going to help me to know which background I should use", then S"I suppose that I should do the same animation with background as it is done with label." GQ"(38) Where should this branch be inserted or how should this case be handled?"
      1. 12:38-12:41 He asks Q"What is temporary variable p?" GQ"(17) What does the declaration or definition of this look like?"  answering immediately as he already thought about it before S"Ahh, the position."
10. 12:55-13:06 <<s11link6>> as he done all the changes on some degree of estimation, he stated S"I am going to save the image, just for sure (in case it fails)". Then he moves to Workspace trying the example. c"workspace" c"confidence" Q"Does my implementation works? Does it solve the task?"  GQ"(44) Will this completely solve the problem or provide the enhancement?"
11. 13:06-13:45 <<s11link7>> S"No, there is an error" when c"debugger" DBG appeared. Q"What is this bug about?" GQ"(32) Under what circumstances is this method called or exception thrown?" in DBG D"Debugger appears because of an error. He observes code, who is receiver (variable) of the message. He understand it and closes the debugger. No changes."
    1. 13:36-13:45 stating S"This [method createBackgroundFor:color:]  does not return the shape." then he closes the c"debugger" DBG
12. 13:45-14:08 Moves in Browser to see method ~createBackgroundFor:color:~ and observing the implementation Q"How is the method implemented?" GQ"(17) What does the declaration or definition of this look like?" Then altering the implementation by adding return statement.
13. 14:08-14:53 <<s11link8>> back in W c"workspace" c"confidence" running the example Q"Does my implementation works? Does it solve the task?" GQ"(44) Will this completely solve the problem or provide the enhancement?" The background works but it does not disappear when the menu is closed. Stating S"Here is an error. The background should also disappear."  Closing the W
14. 14:53-15:08 then goes in B to method ~showSubmenuOf:~ asking Q"Where is the feature which hides the menu items?" GQ"(3) Where is there any code involved in the implementation of this behavior?" S"Here it is, the method ~hideItems~."
15. 15:08-16:04 Asking Q"How does the method ~hideItems~ look like?"  GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?" by pressing KM goes directly to B with the method stating S"Here is the method in RTMenu". C"As the variables' types are not apparent instead of going directly to the desired implementation the programmer asked who implements this method by asking for all implementors of the method ~hideItems~." Q"Who implements this method?"  GQ"(11) Who implements this interface or these abstract methods?"
    1. 15:56 Stating S"Here the label is removed. So I should remove the background here too.", then closing B with the method
    2. 16:04 S"I should keep open the browser with ~hideItems~" he opens it again
16. 16:04-18:27 Back in B with ~showSubmenuOf:~ saying S"I have to keep the reference for this background." Q"How should I alter the code here?" GQ"(38) Where should this branch be inserted or how should this case be handled?"
    1. 16:18-17:18 S"Here is something strange. I have here a reference to menu" looking at the code ~item menu: m~ comparing with method ~hideItems~, asking Q"Does RTMenuItem have a reference to RTMenu?" GQ"(22) How are these types or objects related? (whole-part)" browsing the class, stating S"Here is menu" visiting ~menu~ method and then S"And here is method ~rawmenu~."
       1. 16:43-17:18 Then back in ~hideItems~ asks Q"What happens if I change the code like this? I use only rawmenu." GQ"(42) What will be (or has been) the direct impact of this change?" writing ~item rawmenu remove~.
          1. 17:10-17:18 going to W c"workspace" c"confidence" running the example Q"Does the changed code work?" GQ"(34) How does the system behavior vary over these types or cases?" and stating S"Apparently it is removed too."
    2. 17:18-17:40 back in ~hideItems~ S"I need simply this code and a reference to background" writing ~item background remove~. S"Something like this I need. I believe."
    3. 17:40-18:27 <<s11link9>> back in ~showSubmenuOf:~ changing the code in order to store background in the ~item~. B
       1. 18:00-18:27 checking the implementation by explaining what the code do Q"Is the new written code correct?" GQ"(42) What will be (or has been) the direct impact of this change?" and finally stating the only missing think is the methods ~background~ and ~background:~. B
17. 18:27-19:22 goes to RTMenuItem in order to create the methods ~background~ and ~background:~ B
    1. 18:51-18:58 as he writing ~background: <something>~ asks Q"What is the input variable? aColor? What is the type of method's input value?" GQ"(18) What are the arguments to this function?" then S"Ahh. aShape." remembered
18. 19:22-20:50 <<s11link10>> back in W c"workspace" c"confidence" executing the example Q"Does the code solve the task?" GQ"(44) Will this completely solve the problem or provide the enhancement?"
    1. 20:02-20:20 trying more complicated example with two parent menus asking Q"How should I change the example to have two parent menus?" GQ"(43) What will the total impact of this change be?"
    2. 20:20-20:50 executing the more complex example Q"Does it works?" GQ"(44) Will this completely solve the problem or provide the enhancement?"
19. 20:50 <<s11link11>> finishing the task 1
20. Task 2 "change the menu items layout, which right now is centered and is not visible on the border of window.
21. 20:50-21:10 Understanding the task in W c"workspace" and listening to c"observer" who is explaining the task
22. 21:10-21:20 goes to browser asking Q"Where is the layout implemented?" GQ"(3) Where is there any code involved in the implementation of this behavior?" S"It should be here [in method ~showSubmenuOf:]. Yes it is here."
23. 21:10-21:35 observing the code asking Q"How it is positioned?"  GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"  S"Everything is fine, just this line [~p~ variable] should be set differently"
24. 21:35-23:25 asking Q"How should I change this code? What should I sum up here?" GQ"(38) Where should this branch be inserted or how should this case be handled?" S"I think I should write something like this ~lbl width - menu width~ and
25. 23:25-23:30 then goes to W c"workspace" c"confidence" to try it Q"Does my changes solve the task?" GQ"(44) Will this completely solve the problem or provide the enhancement?" W -> c"debugger" DBG S"No. It does not have width" D"Debugger indicates there is an error."
26. 23:30-24:11 Qe8 he opens the debugger in order to understand why it fails. c"debugger" DBG D"He observes in the debugger why it fails, variable values."
    1. 23:30-23:53 and he asks Q"Who has something like width?" GQ"(3) Is there an entity named something like this in that unit (project, package, or class, say)?" 
    2. 23:53-23:56 in c"debugger" DBG by PT asking Q"What is the value of this ~lbl width~?" GQ"(19) What are the values of these arguments at runtime?"
    3. 23:56-24:11 back in B with ~showSubmenuOf:~ asking Q"What is this lbl?" GQ"(17) What does the declaration or definition of this look like?" stating S"Ahh. This lbl is the parent menu"
    4. The original question is not valid now.
27. 24:11-24:29 Asking Q"Who is the menu item? Which variable keeps menu item?" GQ"(17) What does the declaration or definition of this look like?" S"It should be ~l~" and writing code.
28. 24:29-24:45 back in W c"workspace" c"confidence" trying the example Q"Does my changes solve the task?" GQ"(44) Will this completely solve the problem or provide the enhancement?" S"Almost."
29. 24:45-27:00 back in B with ~showSubmenuOf:~ asking Q"Why it is not correct? Why it behaves like that?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.)  implemented?" S"I think it is divided by 2. But let us think a bit more" C"I guess this is the situation when he was nervous because of the observer and kind of 'math' task".
    1. 25:20-26:45 analysing the code and thinking what is the point and how the point is computed, then he changes the code, asking B
    2. 26:45-27:00 Q"Does it solve the task?" GQ"(44) Will this completely solve the problem or provide the enhancement?" in W c"workspace" c"confidence" executing the example S"Yes. It solves"
30. 27:00 <<s11link12>> Task 2 is finished.
31. 27:30 Task 3: c"observer" asking to work on the task 3 about RTMondrianViewBuilder
32. 28:00-28:38 copying the code example y trying how it works Q"How does the example code works?" GQ"(25) How does the example work?" W c"workspace" c"confidence"
33. 28:38-29:03 copying another example of API he should implement and asking Q"Does it works? It should not." GQ"(25) How does the example work?" W c"workspace" c"confidence" -> c"debugger" DBG D"Indicates that example code really does not work. No real use of the debugger."
34. 29:03-31:34 asking Q"Why it does not work?" GQ"(e8) What does the failure look like?" observing the example in W
    1. 29:15-29:25 Q"Do we have this method ~edgesToAll:~?" GQ"(11) Who implements this interface or these abstract methods?"  S"Yes we have." W IM B
    2. 29:25-29:54 then observing the method Q"(17) How does the ~edgesToAll:~ look like?" GQ"(17) What does the declaration or definition of this look like?" B S"But I do not understand it much"
    3. 29:54-30:30 interested in calling method ~edgesFrom:toAll:~ Q"(17) How does the method ~edgesFrom:toAll~ looks like?"  GQ"(17) What does the declaration or definition of this look like?" B KM IM(3)
    4. 30:30-31:34 interested in calling method ~edges:from:toAll:~ Q"(17) How does the method ~edgesFrom:toAll~ looks like?"  GQ"(17) What does the declaration or definition of this look like?"  IM(3) KM B
       1. 31:05-31:11 interested how fromBlock input variable is used Q"Where in this method is the fromBlock used?" GQ"(15) Where is this variable or data structure being accessed?"
       2. 31:11-31:34 Q"And how fromBlock is used? How does it work? How the other input variables are used?" GQ"(20) What data is being modified in this code?" S"Here are all the objects, but it does not say more"
    5. Unsatisfied question and he started again from the example. C"Apparently he did not tried to read method's comment as it is in English and is quite long. This is my second observation when English is not understood or ignored likely because the participants are not that much strong in English."
35. 31:34-34:21 <<s11link13>> Back in W c"workspace" c"confidence" with the example asking Q"Why it fails?"  GQ"(e8) What does the failure look like?" W -> c"debugger" DBG observing the stack and finding the method ~edges:from:toAll:~ where he was recently. D"He observes call graph, variable values at each stack line. He tries to understand how it works and why it does not work in that particular case."
    1. 32:05-32:14 S"I do not know how to do this. I do not understand much this code." As he did not understand the method he is trying to find another way to move forward.
    2. 32:14-32:35 S"I am going to explore [in DBG] the ~objects~ variable" c"debugger" GQ"(27) How does this data structure look at runtime?", then ~toAllBlock~,
    3. 32:35-34:00 <<s11link14>> then he spend time looking for the value of ~object~. C"Likely the input value of a block is not present in the list of variables." So he spent a lot of time searching for the value. Beside he could evaluate it directly by pressing CMD+I. Instead he was looking on other stack frames. Finally he found the answer in another method ~rtValue:~ stating S"It is #yourself (= a symbol)." c"debugger" DBG
    4. 34:00-34:21 then he ask Q"What does it [#yourself object] not understand?" GQ"(e8) What does the failure look like?"
       1. 34:05-34:12 he again reads the code ~anObject perform:  self~, S"anObject is #yourself" Q"What is self?" GQ"(19) What are the values of these arguments at runtime?" S"self is #dependentClasses"
       2. 34:19-34:21 S"I do not understand it well" and closes the c"debugger" DBG
    5. 34:21 As he do not understand the code ~aSymbol perform:  aSymbol2~ he closed the c"debugger" DBG without understand it.
36. 34:21-34:40 back in W with the example comparing the working example and task's example. GQ"(36) What is the difference between these similar parts of the code (e.g., between sets of methods)?"
37. 34:40-34:48 asking Q"Is there an example of ~edgesToAll:~ method in order to know how it is used?" GQ"(12) Where is this method called or type referenced?" W KN but there is no use of it. Apparently, because it is something he should fix. I think the code was copied from Roassal1 but never fixed to the new Roassal2 model. He event tried the KN several times.
38. 34:48-37:07 <<s11link15>> and Q"Is there an example of ~edgesFrom:~ method in order to know how it is used?" GQ"(4) Is there a precedent or exemplar for this?" W KN SN(8)
    1. 35:00 stating S"The majority are ~edgesFrom: #superclass~ as he saw first two methods"
    2. 35:03 S"Here is different example. Yes this is something more interesting."
    3. 35:03-35:28 c"example" executing the code he found from SN(8) in order to know what does it do Q"What is this example about? What does it produce?" GQ"(25) How does the example work?" after observing the aRTView window with the result stating S"I do not understand it much" and closing the aRTView window.
    4. 35:28-25:38 back in SN(8) says S"But it is another builder, it is not RTMondrianViewBuilder" and goes to another method on the list
    5. 35:38-35:43 S"Here is another example"
    6. 35:43-35:55 executing the example c"example" from IM(8) and observing the aRTView window Q"What is this example about?" GQ"(25) How does the example work?", then closing the aRTView window stating S"It is much better" and going back to IM(8)
    7. 35:55-36:48 observing the example c"example" in method ~nestedTrees~
       1. 36:15-36:41 asking Q"What is this method ~//~? Modulo?"  GQ"(17) What does the declaration or definition of this look like?"  IM(8) KM getting another IM(8) S"Ahh reminder [founded the word in the comment]. Yes. It is modulo." and closing the IM(8)
    8. 36:48-36:55 goes to another listed method (example)  c"example" in IM(8) called ~radialTreeLayout~.
    9. 36:55-37:04 goes to another "example" c"example", in that case test method called ~testEdgesFrom~
    10. 37:04-37:07 goes to the last method in IM(8) called ~testEdgesFromAndEdgesFromTo~  c"example"
    11. 37:07 closing IM(8). I think unsatisfied with the examples he found.
39. 37:07-37:14 Back in the W with the example asking Q"What is the #superclass symbol (method) about? Who implements it?" GQ"(11) Who implements this interface or these abstract methods?" W KM IM(9) and closing it as it is not something he need to know
40. 37:14 Back in the W and
41. 37:24-37:28 c"confidence" c"workspace" executing the code W GQ"(31) Which execution path is being taken in this case?" -> c"debugger" DBG and without closing the DBG D"He can see what he has seen before. He is going to repeat his observation."
42. 37:28-37:32 back in W saying S"I do not understand much this example."
43. 37:32-48:16 back in the c"debugger" DBG in the stack frame of a block in method ~buildEdgesFromObjects:from:toAll:using:inView:scope:~ and stating S"Here I can understand more what should I do [in order to solve the task]." Q"What can I do here in order to solve the task?" GQ"(38) Where should this branch be inserted or how should this case be handled?" D"He observes call graph, variable values at each stack line. He tries to understand how it works and why it does not work in that particular case."
    1. 37:50-38:08 observing value of ~objects~ in c"debugger" DBG saying S"Before [in Roassal 1] the block was used no a selector [symbol] is used]."
    2. 38:08-38:19 reading the method name ~buildEdgesFromObjects:from:toAll:using:inView:scope:~ and its input variables Q"What is the method about?" GQ"(25) What is the behavior that these types provide together and how is it distributed over the types?" and saying S"Too much generic this method" c"debugger" DBG
    3. 38:19-38:45 <<s11link16>> back thinking about ~objects~ and others variables in c"debugger" DBG Q"What are the values of these variables at runtime?"  GQ"(19) What are the values of these arguments at runtime?"
    4. 38:45-39:50 goes to another stack frame with method ~buildEdgesFromObjects:from:toAll:using:inView:scope:~ S"I am trying to understand the code", S"I would like to understand when it [~rtValue:~] is called" Q"When/why the method ~rtValue:~ is called?" GQ"(32) Under what circumstances is this method called or exception thrown?" S"I do not understand it" browsing around the stack frames.
       1. 39:34 c"ide-error" C"observation: I think there is a bug in the debugger because it should display a symbol when observing ~toAllBlock~ variable"
       2. 39:44-39:50 <<s11link17>> S"I believe this ~toAllBlock rtValue: object~ should returns me the elements which are manipulated then here" Q"What type does this statement returns?" GQ"(e5) What is the method's return value?" C"Unsatisfied question as it is quite 'meta' method."
       3. Unsatisfied question, he does not understand the code.
    5. 40:00-40:32 but Q"What is this ~object~?" GQ"(e5) What is the type of this variable?" going to upper method in the stack and answering S"it is #yourself symbol"
    6. 40:50-41:10 but he is not satisfied with the symbol, he thinks it should be something else
    7. 41:10-41:25 then thinking this ~objects~ should give me the objects so I can then call the method ~dependentClasses~ back in W with the example GQ"(41) How can we know that this object has been created and initialized correctly?"
    8. 41:25-41:35 Q"Is the dependentClasses implemented?" GQ"(11) Who implements this interface or these abstract methods?" W KM B
    9. 41:41-41:46 S"The problem is that here [object variable] it does not receive what it should receive"
    10. 41:46-42:06 diving down in the c"debugger" DBG stack Q"Why it does not receive correct values?" GQ"(21) How are instances of these types created and assembled?" S"Because the ~objects~ is an array with #yourself"
        1. 41:56-42:06 observing the ~objects~ variable down the c"debugger" DBG stack Q"Why ~objects~ is array with one symbol and not array of objects I need?" GQ"(21) How are instances of these types created and assembled?"
           1. 42:06 He founds it is hard coded in ~edgesToAll:~ method.
    11. 42:06-48:16 GQ"(38) Where should this branch be inserted or how should this case be handled?"
        1. 42:14 S"Now I should take some decision" staying in c"debugger" DBG
        2. 42:32 S"But I still do not understand the code much."
        3. 42:38-42:44 observing ~objects~ variable Q"What is the value of objects at runtime?" GQ"(19) What are the values of these arguments at runtime?" answering it in c"debugger" DBG
        4. 42:44 <<s11link18>> C"I think ~edgesFrom:toAll:~ should pass ~object~ argument to the second argument of the called method."
        5. 42:50-42:56 Q"What is the value of object variable?" GQ"(19) What are the values of these arguments at runtime?" answering it in c"debugger" DBG
        6. 42:56-43:00 observing ~objects~ variable Q"What is the value of objects at runtime?" GQ"(19) What are the values of these arguments at runtime?" answering it in c"debugger" DBG
        7. 43:00-43:33 S"Now I want to find out where I could put #dependentClasses" GQ"(38) Where should this branch be inserted or how should this case be handled?" observing ~edgesFrom:toAll:~ method in c"debugger" DBG
        8. 43:51 <<s11link19>> S"I am blocked. I do not know how to continue."
        9. 43:51-45:17 Q"Where I could change the code that way that in the moment of asking ~toAllBlock rtValue: object~ the method ~rtValue:~ receives object, not a symbol?" GQ"(38) Where should this branch be inserted or how should this case be handled?"
           1. 45:00-45:17 S"Maybe instead of having there #yourself I could send the objects which should be there" thinking in c"debugger" DBG in method ~edgesToAll:~
           2. 45:17 S"but it is something I do not understand" browsing the stack in c"debugger" DBG
           3. Unsatisfied question
        10. 45:17-47:12 observing methods in c"debugger" DBG and variables looking for any "scent" which could help him to move forward, asking also Q"Is there any value which could help me to understand how it works?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?" S"Variable ~objects~ does not say me anything. The value #yourself is something I do not understand."
            1. 46:00-46:20 then observing other variables Q"What are values of these variables?" GQ"(27) How does this data structure look at runtime?" c"debugger" DBG
            2. 46:20-46:33 S"There is aGroup" Q"When is this variable used?" GQ"(15) Where is this variable or data structure being accessed?"
            3. 46:33-46:45 Q"How aGroup is used?" Q20 reading the method which is send to the aGroup instance.
            4. 46:45-47:12 then thinking about fromElement variable and asking again Q"What is the value of ~toAllBlock~?" GQ"(27) How does this data structure look at runtime?"
        11. 47:20-47:45 observing ~toAllBlock rtValue: object~ saying S"I could write fromElement instead of object" then he say S"I do not know. I have to try it."
        12. 47:45-48:06 opening from c"debugger" DBG browser with the method he wants to change and doing the change in B, then closing the c"debugger" DBG
        13. 48:06-48:16 Q"Does the change work?" GQ"(42) What will be (or has been) the direct impact of this change?" in W executing the example. S"It does not work. It is nil." as he see new c"debugger" DBG D"Debugger window indicates that his change does not work. The session finishes, so he does not use this debugger."
    12. As he did not solve it and the session finished we could say it is unsatisfied question.
44. 48:25 The session terminates.
** Session S12 with P5, familiar (Panel Analizador SOA application)
   :PROPERTIES:
   :VideoFile: videos/S12-P5.m4v
   :FUEL: dflow/S12-P5.fuel
   :VIDEO-START-TIME: 2014-06-30T15:44:0.306393-04:00
   :Familiar: 1
   :SESSION-ID: S12
   :PARTICIPANT-ID: P5
   :END:
*** Tool Usage
1. 00:00-01:12 c"testing-behavior"
2. 01:12-03:04 c"static-tool" Oracle JDeveloper
3. 03:04-03:26 c"testing-behavior"
4. 03:26-03:46 c"static-tool"
5. 03:46-04:02 c"static-tool" Oracle JDeveloper
6. 04:02-04:30 c"static-tool"
7. 04:30-04:37 c"testing-behavior"
8. 04:37-05:55 c"dynamic-tool"
9. 05:55-06:10 c"static-tool" NotePad++ observes a XML file.
10. 06:10-06:40 c"dynamic-tool"
11. 06:40-08:24 c"static-tool"
12. 08:24-08:39 c"dynamic-tool"
13. 08:39-08:44 c"testing-behavior"
14. 08:44-10:50 c"static-tool"
15. 10:50-11:03 c"static-tool" Oracle JDeveloper
16. 11:03-11:14 c"static-tool"
17. 11:14-11:29 c"testing-behavior"
18. 11:29-11:37 c"static-tool"
19. 11:37-11:51 c"testing-behavior"
20. 11:51-16:52 c"static-tool" he observes his tool and source code
21. 16:52-17:36 c"dynamic-tool"
22. 17:36-17:40 c"static-tool"
23. 17:40-18:41 c"dynamic-tool"
24. 18:41-19:52 c"testing-behavior"
25. 19:52-20:03 c"dynamic-tool"
26. 20:03-20:46 c"static-tool" Oracle JDeveloper
27. 20:46-21:09 c"testing-behavior"
28. 21:09-22:14 c"dynamic-tool"
29. 22:14-23:41 c"static-tool"
30. 23:41-23:59 c"dynamic-tool"
31. 23:59-25:35 c"static-tool"
32. 25:35-25:56 c"dynamic-tool"
33. 25:56-26:20 c"static-tool"
34. 26:20-26:53 c"testing-behavior"
35. 26:53-27:26 c"static-tool"
36. 27:26-27:35 c"static-tool" Oracle JDeveloper
37. 27:35-27:40 c"static-tool"
38. 27:40-27:42 c"testing-behavior"
39. 27:42-27:59 c"dynamic-tool"
40. 27:59-29:35 c"static-tool" Oracle JDeveloper
41. 29:35-29:42 c"dynamic-tool"
42. 29:42-33:37 c"static-tool" He opens book Pharo by Example 1 and internet
43. 33:37-34:21 c"static-tool"
44. 34:21-34:40 c"static-tool" Pharo by Example
45. 34:40-35:01 c"dynamic-tool"
46. 35:01-40:44 c"static-tool"
47. 40:44-41:04 c"static-tool" Oracle JDeveloper
48. 41:04-43:30 c"static-tool"
*** Transcript
1. 00:00-03:25 he is explaining in his application Panel Analizador SOA (PASOA) what he is doing to do.
   1. 01:22 In Oracle JDeveloper (OJD), explaining XML relations of element inputVariable
   2. Task: to display why a variable is related with a function
2. 03:26-05:50 composing initial information
   1. 03:26-03:40 opening B to see class ~BPVariable~ which likely represents ~inputVariables~ presented before. Observing its definition of instance variables. GQ"(6) What are the parts of this type?"
   2. 03:40-03:48 Pointing to ~xslType~ in B which represents the schema
   3. 03:48-04:04 <<s8link1>> c"playground" then going to OJD and then copying the value of ~messageType~ to W in order to see it and having it as a reference. Q"What is the value of the ~messageType~ instance variable at runtime?" GQ"(27) How does this data structure look at runtime?"
   4. 04:35-05:50 going to PASOA and inspecting ~inputVariable~ which is instance of ~BPVariable~ going to see the value of ~xslType~. The value is a ~BPXSDElement~ instance, then observing its structure Q"How does the values of this object look like at runtime?" GQ"(27) How does this data structure look at runtime?", going deep to ~myDocument~, as he see that it is wrong objects, goes to see another instance variable ~parent~, here looking at ~fullPath~. Its value is a filename. Q"What is the filename of XSD schema related to this variable called ~inputVariable~ at runtime?" GQ"(27) How does this data structure look at runtime?"
   5. c"observation: Most of the time he spent by explaining it to me, he could do it faster without this recording, I think. But I am not sure about it."
3. 05:50-06:05 opening the XSD file in Notepad++
4. 06:10-06:40 back in Pharo, in the inspector with ~inputVariable~ looking for a element name Q"What is the name of this element?  What is the value of name variable at runtime?". GQ"(27) How does this data structure look at runtime?" It is called "process" and observing ~lstElements~
   1. 06:30-06:40 Q"What is the value of ~lstElements~ variable at runtime?" GQ"(e5) What is the type of this variable at runtime?" in order to see its value which is a ~BPXSDComplexType~.
5. 06:40-07:20 back in B to see the structure of objects which has for XSD. Q"What is the class structure for XSD?" GQ"(7) Which types is this type a part of?"
6. 07:20-08:26 <<s8link2>> c"playground" opening Workspace writing notes of what he has to do
7. 08:35-09:05 goes to PASOA to see the name of the visualization he wants to change Q"What is the name of the visualization I want to change?" GQ"(1) Which type represents this domain concept or this UI element or action?"
   1. 08:43-09:05 goes to B to see the related visualization class called ~BPVCBProcessNormalLayout~
8. 09:05-09:30 observing its method ~executeVisualization:~ GQ"(6) What are the parts of this type?"
9. 09:30-09:41 opening another B to see ~BPProcess~ class to see its instance variables GQ"(26) What is the 'correct' way to use or access this data structure?"
10. 09:41-11:33 he says S"but here I think I do another think. I look for ~allWSDLs~." He is understanding what information he has to look for and how. Q"How can I retrieve all the information I need in this object structure?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"
    1. 10:00-10:40 S"I think the ~bpRelations~ is a collection" going to implementation of ~allWSDLs~ method. Q"(17) How does the implementation of ~allWSDLs~ look like?" GQ"(17) What does the declaration or definition of this look like?" finding that the implementation is a bit different that he thought.
    2. 10:40-11:03 he says that this implementation has some disadvantage going to OJD to clarify the objects structure and stating S"If I have a WSD which is not used, I will not be able to reference it in my visualization". GQ"(26) What is the 'correct' way to use or access this data structure?"
    3. 11:03-11:33 back in B, then to PASOA to clarify his thoughts and understanding that everything is fine.
    4. c"observation: It looks like everything was about understanding the object structure and how to retrieve the information he wants to aggregate."
11. 11:33-13:50 back in B with ~executeVisualization~ thinking where to do change to the code GQ"(38) Where should this branch be inserted or how should this case be handled?"
    1. 12:12-14:04 writing the code
       1. 13:50 S"I do not know what size I will use, for now a default one, then I will verify it"
12. 14:04-16:12 S"I have to verify that ~var allElements~ has all its elements." Q"Does the function ~allElements~ returns all the elements I need in my code?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"
    1. 14:10 goes in B to see ~BPVariable~ class
    2. 14:35 and implements here new method ~allElements~
13. 16:12-25:56 Now ~allElements~ method return empty collection and I am going to check it as it is. GQ"(42) What will be (or has been) the direct impact of this change?"
    1. 16:28-16:53 goes to ~BPVariableTest>>testBuildRelations~ in B, changing the definition
    2. 16:53-20:05 testing from B the test case Q"Does my solution works?" GQ"(44) Will this completely solve the problem or provide the enhancement?" which produces an error -> c"debugger" DBG Q"Why it fails?" GQ"(e8) What does the failure look like?"
       1. 17:15-17:40 observing in c"debugger" DBG's inspector the variables in order to find out the error. He thinks he has not written well the element's name ~inputVariable~. Q"Is the element's name I have written correct?" GQ"(36) What is the difference between these similar parts of the code (e.g., between sets of methods)?" But finding it is correct.
       2. 17:40-17:45 executing the test again Qe7
       3. 17:45-18:10 GQ"(e8) What does the failure look like?"
          1. 17:45-17:55 observing ~lstv~ variable Q27 and
          2. 17:55-18:10 checking in evaluator what expression ~lstv at: inputVariable~ returns Q"What is the method's return value at runtime?" GQ"(27) What is the method's return value?". And finds it returns what he expected.
       4. 18:10-18:41 says the problem is on the next line with ~v~ variable exploring it GQ"(27) How does this data structure look at runtime?" in the c"debugger" DBG's inspector, then saying that this code line does not have sense in that case.
       5. 18:41-20:05 to check his thoughts goes to PASOA to see the visualization GQ"(34) How does the system behavior vary over these types or cases?"
          1. 18:50-19:03 <<s8link3>> c"playground" then goes to W with his notes he has to do for this task and adds more information
          2. 19:03-19:52 <<s8link4>> understanding what to do using POSOA visualization and B with ~BPVCBProcessNormalLayout~
          3. 19:52-20:05 back in c"debugger" DBG asking Q"Why ~inputVariable~ does not have any relation?" GQ"(27) How does this data structure look at runtime?" and deciding to change XML definition
    3. 20:05-20:44 goes to OJD in order to change XML definition. It should simplify his testing for now. Q"How can I simplify my test case for now?" GQ"(22) How are these types or objects related? (whole-part)"
    4. 20:44-22:16 closing and opening POSOA and closing c"debugger" DBG to see the changes he made into XML.
       1. 21:10-21:22 inspecting ~inputVariable~ in order to see its relations ~lstRelations~ GQ"(27) How does this data structure look at runtime?" which is empty. S"It seams that the relation does not work well."
       2. 21:22-21:37 <<s8link5>> and in W with notes writing that he needs to test it
       3. 22:16 S"that this issue is not my objective now, but it limits me in my task."
       4. c"observation: I suppose he forgot about the simplification as it likely does not serve to him because of relation error."
    5. 22:16-22:40 checking if he really needs it or can live without it for now while looking at ~executeVisualization~ in B GQ"(34) How does the system behavior vary over these types or cases?".
    6. 22:40-23:41 goes to B with test case ~testbuildRelations~, then comparing two similar tests in order to know which can serve him better Q"Which test case serves me better?" GQ"(35) What are the differences between these files or types?"
       1. 23:23-23:41 while he is reading the second test case, he found out that one line of code can be simplified a bit. So he rewrite it and test it.
       2. c"observation: at that moment he likely decided to use the second test case."
    7. 23:41-23:59 the test does not work Q"Does the test work as I expect?" GQ"(42) What will be (or has been) the direct impact of this change?", but as he sees in c"debugger" DBG it fails later after the change and says S"We are very good. Estamos sper bien."
    8. 23:59-25:34 changing the rest of the test case in B
    9. 25:34-25:56 executing the test case GQ"(44) Will this completely solve the problem or provide the enhancement?" and looking why it fails. He expects that it fails and in c"debugger" DBG checking his expectations. Q"Does it fails as I expects?"  GQ"(e8) What does the failure look like?" S"Perfect. It is what I was expecting." Then checking in inspector if the variable is really empty Q"What is the value of the variable ~lstElements~?" GQ"(27) How does this data structure look at runtime?".
14. 25:56-43:02 S"Now we are going to return where we were before" It means to B with ~allElements~. Q"How we can implement this feature?" GQ"(38) Where should this branch be inserted or how should this case be handled?"
    1. 26:18-26:58 then goes to PASOA and passing around the PASOA and B with ~BPVCBProcessNormalLayout~ summarizing what he needs.
    2. 26:58-29:28 back in B with ~allElements~ thinking Q"How can I receive the needed values here?" GQ"(26) What is the 'correct' way to use or access this data structure?" thinking it could be received as a tree structure.
       1. 27:27-29:28 goes to OJD to check his hipotesis
          1. 27:35-28:00 he forgot where he should search for it (the file name) and he is going back to Pharo to find the information. Inspecting ~inputVariable~ in PASOA -> ~xsdType~ -> ~parent~ -> ~fullPath~ GQ"(27) How does this data structure look at runtime?"
          2. 28:00-28:56 navigating in OBJ to find the file from ~fullPath~
          3. 28:56-29:28 observing the XSD definition and stating I need a tree structure in Pharo
    3. 29:28-34:40 <<s8link6>> Q"How we can implement tree structure in Pharo?"  GQ"(1) Which type represents this domain concept or this UI element or action?" c"abandoned-question" C"He was not able to answer it."
       1. 29:42-31:27 c"example" <<s8link7>> going to see an example in book Pharo By Example Q"Is there any example how to use tree structure?"  GQ"(4) Is there a precedent or exemplar for this?"  cannot find anything.
       2. 31:27-33:37 <<s8link8>> going to the Web asking "tree in pharo". He found a video exactly about it, but for some reason he was not interested. Searching for "tree in pharo examples", then "tree class in pharo examples", then "tree map class in pharo examples", then "tree map class in smalltalk examples" Q"Is there any example how to use tree structure?" GQ"(4) Is there a precedent or exemplar for this?"
       3. 33:37-34:01 <<s8link9>> going to Pharo image, opens Workspace, writing ~tree~ and looking what code completion lists, then tries the same with ~Tree~ and found ~TreeMap~ GQ"(5) Is there an entity named something like this in that unit (project, package, or class, say)?"
       4. 34:01-34:20 but apparently what code completion offered was not class name, maybe name of a package.
       5. 34:20-34:40 back on the Web, searching for a PDF he found saying S"It is imposible that there is not something that simple as a tree class."
       6. c"observation: I think unsatisfied question. And I think he did not wanted tree structure."
    4. 34:40-43:02 back in Pharo image thinking how to implement it Q"How can I collect all the elements from this objects structure I need?" GQ"(26) What is the 'correct' way to use or access this data structure?". Going to ~BPXSDElement~ and writing ~allElements~
       1. 37:35 Q"What is the best way to implement it?" Qx"Similar to the parent question."
       2. 38:44 he finished ~allElements~ method and goes to implement one required ~fillElementIn:~
       3. 38:44-39:46 writing ~fillElementIn:~ in ~BPXSimpleType~
       4. 39:46-40:06 and also ~addElements~. c"observation: actually here he introduced an error which returns him an object instead of a collection. He wrote ~^ OrderedCollection new add:  self~. But this is something what code critics reveals."
       5. 40:06-43:02 going to another class ~BPXSDComplexType~ writing
          1. 40:06-40:30 as he forgot the method ~fillElementIn:~ name he went back to ~BPXSDElement~ to see it Q"What is the method name I want to implement?" GQ"(12) Where is this method called or type referenced?"
          2. 40:30-43:02 as he is thinking how to implement ~fillElementIn:~ GQ"(38) Where should this branch be inserted or how should this case be handled?", observes instance variables of the class Q"What is the structure of the class?" GQ"(6) What are the parts of this type?"  which have ~xsdSequence~
             1. 40:45-41:04 He goes to OJD to see complex type here checking the element's structure Q"What is the structure of the XML element?" GQ"(6) What are the parts of this type?"
             2. 41:04-42:22 back in Pharo a thinking how to implement it and then he finishes the implementation
             3. 42:22-43:02 moving around the classes where he recently implemented the methods ~allElements~ and ~fillElementIn:~ GQ"(38) Where should this branch be inserted or how should this case be handled?" and finally copying ~allElements~ from ~BPXSDElement~ to ~BPXSDSecuence~ saying S"It is literally equal"
15. 43:02-43:30 he is thinking about to test it, going to a test case which could serves him. GQ"(44) Will this completely solve the problem or provide the enhancement?"
16. 43:30-45:25 the session finished. He explains what he should do next. He finishes the session by himself. I had not to say anything.
** Session S4 with P7, unfamiliar (Fix SVGPath movement)
   :PROPERTIES:
   :VideoFile: videos/S4-P7.m4v
   :FUEL: dflow/S4-P7.fuel
   :VIDEO-START-TIME: 2014-06-24T10:38:45.772105-04:00
   :Familiar: 0.5
   :SESSION-ID: S4
   :PARTICIPANT-ID: P7
   :END:
*** Tool Usage
1. 00:00-01:41 c"rest-time"
2. 01:41-02:57 c"static-tool"
3. 02:57-06:41 c"dynamic-tool"
4. 06:41-13:03 c"static-tool"
5. 13:03-14:15 c"dynamic-tool"
6. 14:15-16:40 c"static-tool"
7. 16:40-16:46 c"dynamic-tool"
8. 16:46-16:50 c"static-tool"
9. 16:50-17:18 c"dynamic-tool" Test Runner
10. 17:18-18:08 c"static-tool"
11. 18:08-18:10 c"dynamic-tool"
12. 18:10-18:43 c"static-tool"
13. 18:43-18:45 c"dynamic-tool"
14. 18:45-19:25 c"static-tool"
15. 19:25-20:17 c"dynamic-tool"
16. 20:17-20:30 c"static-tool"
17. 20:30-21:02 c"dynamic-tool"
18. 21:02-21:24 c"static-tool"
19. 21:24-22:04 c"dynamic-tool"
20. 22:04-22:24 c"static-tool"
21. 22:24-22:28 c"dynamic-tool"
22. 22:28-26:25 c"static-tool"
23. 26:25-27:54 c"dynamic-tool"
24. 27:54-28:34 c"static-tool"
25. 28:34-30:03 c"dynamic-tool"
26. 30:03-34:02 c"static-tool"
27. 34:02-34:24 c"dynamic-tool"
28. 34:24-34:29 c"static-tool"
29. 34:29-35:45 c"dynamic-tool"
30. 35:45-37:04 c"static-tool"
31. 37:04-37:28 c"dynamic-tool"
32. 37:28-39:21 c"static-tool"
33. 39:21-40:35 c"dynamic-tool"
34. 40:35-43:29 c"static-tool"
35. 43:29-44:16 c"dynamic-tool"
36. 44:16-44:36 c"static-tool"
37. 44:36-45:49 c"dynamic-tool"
38. 45:49-47:25 c"static-tool"
39. 47:25-47:29 c"dynamic-tool"
40. 47:29-47:41 c"static-tool"
41. 47:41-48:11 c"dynamic-tool"
42. 48:11-48:42 c"static-tool"
43. 48:42-49:34 c"dynamic-tool"
*** Transcript
1. 00:00-01:21 Preparation of the image (DFlow)
2. 01:21-02:13 Explanation of the problem
3. 02:20-06:07 <<s2link1>> problem reproduction and identification of the focus point (~translateBy:~ message).
   1. 02:20-06:07 c"prototype" he wants to write a code which reproduces the problem Q"How the failure looks like?" GQ"(e8) What does the failure look like?". He is writing the code to the Workspace c"workspace"
      1. 02:26-02:54 he looks for an existing example with TRSVGPath Q"Is there any example using TRSVGPath?" GQ"(4) Is there a precedent or exemplar for this?"
         1. 02:26-02:54 he presses CMD+N Q"Where the class is referenced?" GQ"(12) Where is this method called or type referenced?" and he observes 12 methods. He decides to use one and copy it to Workspace.
      2. 03:15-05:01 he wants to understand what happens if a translation is send to the shape Q"How the translation behave using ~TRSVGPath~?" GQ"(34) What does the method call produce at runtime?"
         1. 03:30-04:05 c"workspace" he executes the example and inspect c"inspector" the object ~TRCanvas~ Q"How does it look like at runtime?" GQ"(27) How does this data structure look at runtime?"
         2. 04:05-04:13 he looks for a shape in the object structure c"inspector" Q"Where is the SVG shape in the object structure?" GQ"(28) How can data be passed to (or accessed at) this point in the code?"
         3. 04:13-05:01 executing ~self translateBy: 30@30~ in order to see what happens. And he observes the TRCanvas revealing that nothing happens. c"inspector"
      3. 05:01-06:07 he wants to understand how it behaves (how it differs) using ~TRBoxShape~ Q"How the translation behavior differ between ~TRSVGPath~ and ~TRBoxShape~?" GQ"(34) How does the system behavior vary over these types or cases?"
         1. 05:10-05:41 he opens another Workspace c"workspace" copying the SVG example and changing the shape.
         2. 05:41-05:57 he executes and inspects c"inspector" the example and he looks for the ~TRBoxShape~ in the inspector. Q"How does it look like at runtime?" GQ"(27) How does this data structure look at runtime?"
         3. 05:57-06:07 he writes and executes the ~self translateBy: 30@30~ in the c"inspector". And he finds out it works.
4. 06:07-06:40 he cleans the space -> he closes all the obsolete windows.
5. 06:40-12:00 <<s2link2>> code observation in order to identify the bug
   1. 06:40-08:14 he wants to compare the implementations of ~translateBy:~ method on classes ~TRBoxShape~ and ~TRSVGPath~ Q"How do the ~translateBy:~ implementation differ between ~TRBoxShape~ and ~TRSVGPath~?" GQ"(34) How does the system behavior vary over these types or cases?"
      1. 06:55-07:19 he goes to ~TRBoxShape~ implementation and he observes there is not an implementation of ~translateBy:~ method. He goes to the super class ~TRAbstractBoxShape~ and then to ~TRShape~ where he finds the method. Q"Where is the ~translateBy:~ method implemented?" GQ"(e1) Where is the method defined in the type hierarchy?"
      2. 07:19-07:28 he goes to ~TRSVGPath~ to check if it has its own implementation of ~translateBy:~ and he finds it has one.
      3. 07:28-08:14 he observes the ~TRSVGPath>>translateBy:~ implementation in order to understand what does it do. Q"Where is the ~translateBy:~ method implemented?" GQ"(e1) Where is the method defined in the type hierarchy?"
         1. 07:50-07:59 he observes the ~rectangle~ variable, he asks where the variable is used resulting that it is defined on the class ~TRSVGPath~ Q"Where the instance variable ~rectangle~ is declared?" GQ"(15) Where is this variable or data structure being accessed?".
   2. 08:14-08:46 he goes to ~TRShape~ observing ~translateTo:~ and compares it with ~translateBy:~. Q"How the methods differ?"  GQ"(36) What is the difference between these similar parts of the code (e.g., between sets of methods)?" He concludes both calls method ~position:~
   3. 08:46-09:00 he goes to ~position:~ Q"How does the implementation of ~position:~ looks like?" GQ"(17) What does the declaration or definition of this look like?" and he observes it.
   4. 09:00-09:30 he concludes that both shapes ~RTBox~ and ~TRSVGPath~ stores the position in ~matrix~ instance variable and he supposes that it may not used.
   5. 09:30-10:40 he observes how the ~matrix~ is used on ~TRBoxShape~ Q"How and where the ~matrix~ is used on ~TRBoxShape~?" GQ"(15) Where is this variable or data structure being accessed?". There 11 references. He sees it is used in ~includePoint:~ which is not the method he is interested in now. And it is used in ~drawOn:~, the method he is interested in.
   6. 10:40-11:11 he is interested how ~matrix~ is used on ~TRSVGPath~ Q"How and where the ~matrix~ is used on ~TRSVGPath~?" GQ"(15) Where is this variable or data structure being accessed?" He finds it is not used in ~drawOn:~ method.
   7. 11:11-11:27 he checks where method ~matrix~ is called Q"Where the ~matrix~ method is called?" GQ"(12) Where is this method called or type referenced?" It is not used.
   8. 11:27-12:00 he concludes that it likely does not work because the ~matrix~ is not considered in ~TRSVGPath>>drawOn:~
6. 12:00-14:02 <<s2link3>> first code changes and testing the hipotesis c"transition-7"
   1. 12:00-12:55 he makes changes ~TRSVGPath>>drawOn:~
   2. 12:55-14:02 he goes to Workspace c"workspace" c"confidence" interested if it solves the problem Q"Does my changes solve the task?" GQ"(44) Will this completely solve the problem or provide the enhancement?". He executes the code and finds the shape in the inspector c"inspector" and executes ~self translateBy: 30@30~. It works, but he also realized that the shape has another position comparing to the beginning of the session.
7. 14:02-14:20 c"test" He redoes his changes in ~TRSVGPath>>drawOn:~ in order to write a test case. 
8. 14:20-18:45 <<s2link4>> He wants to write the test case c"test-case" c"tdd" c"transition-3"
   1. 14:30-14:50 he is interested if there are some test cases related to ~TRSVGPath~ Q"Are there test cases related to ~TRSVGPath~?" GQ"(e6) Is this entity or feature tested?"
      1. 14:40-14:50 he asks for ~TRSVGPath~ references Q"Where the class ~TRSVGPath~ is referenced?" GQ"(12) Where is this method called or type referenced?" (12 results) but he do not see any test case (something like ~TRSVGPathTest~)
   2. 14:50-16:00 he looks for how and where ~TRBoxShape~ is tested. Q"Are there test cases related to ~TRBoxShape~?"  GQ"(e6) Is this entity or feature tested?"
      1. 14:50-16:00 he goes to the ~TRBoxShape~ definition and asks for its references Q"Where the class ~TRBoxShape~ is referenced?" GQ"(12) Where is this method called or type referenced?" He has 45 references. One called ~TRShapeTest>>testPosition~ is the interesting one.
   3. 16:00-16:53 he observes 3 tests related to position ~testPosition~, ~testPositionDefault~, ~testPositionWithFloats~ and he decides to make the same for the ~TRSVGPath~. He wrotes one ~testPositionDefaultSVGPath~.
   4. 16:53-17:18 He decides to check all the test related to package ~Trachel~ and ~Roassal2~. He opens Test Runner, all 429 tests pass. Q"Does the test in packages ~Trachel~ and ~Roassal2~ pass?" GQ"(e7) Do the test cases pass?"
   5. 17:18-18:08 he is back in the Browser and he creates another test called ~testPositionSVG~.
   6. 18:08-18:10 He checks if it fails directly from the Browser Q"Does the test ~testPositionSVG~ fails?"  GQ"(e7) Do the test cases pass?"
   7. 18:10-18:43 he wrotes another test ~testPositionWithFloatsSVGPath~ and
   8. 18:43-18:45 he tests if it fails Q"Does the test ~testPositionWithFloatsSVGPath~ fails?"  GQ"(e7) Do the test cases pass?" He has two new failed tests
9. 18:45-45:29 <<s2link5>> Fixes the code in order to have green test cases
   1. 18:45-19:25 He goes to the ~TRSVGPath>>drawOn:~ and he includes the previous modification he made before.
   2. 19:25-19:28 He executes the test ~testPositionSVG~ Q"Does the test ~testPositionSVG~ pass?" GQ"(e7) Do the test cases pass?"  with a failure (a debugger window).
   3. 19:28-20:05 He observers the failure in the c"debugger". Q"Why it fails?" GQ"(e8) What does the failure look like?"
      1. 20:00-20:05 he checks the variable value. Q"What is the value of the variable ~pathString~?" GQ"(19) What are the values of these arguments at runtime?" It is nil. And he understands he has to improve the test case.
   4. 20:05-20:30 he goes to the test definition and adds new line with path definition.
   5. 20:30-20:32 he executes the test case Q"Does the test ~testPositionSVG~ pass?" GQ"(e7) Do the test cases pass?". It fails.
   6. 20:32-45:29 He observes where it fails. Q"Why it fails?" GQ"(e8) What does the failure look like?"
      1. 20:40-20:45 c"runtime" c"transition-4-from-tdd" He executes in the c"debugger" ~svg position~ Q"What is the return value of the method ~position~?" GQ"(19) What are the values of these arguments at runtime?"
      2. 20:45-21:00 c"ide-error" he observes the rest of the test case method and he decides to write more asserts into the test.
      3. 21:00-21:24 he wrotes the code c"tdd" c"transition-1"
      4. 21:24-21:26 Q"Does the test ~testPositionSVG~ pass?" GQ"(e7) Do the test cases pass?". No.
      5. 21:26-45:29 Q"Why it fails?" GQ"(e8) What does the failure look like?" c"runtime" c"transition-4-from-tdd"
         1. 21:35-21:40 In the c"debugger" he evaluates ~svg position~. Q"What is the return value of the method ~position~?" GQ"(19) What are the values of these arguments at runtime?"
         2. 21:40-22:04 He thinks why it happens and he decides to explore how the position is manipulated in the code.
         3. 22:04-20:24 he improves the test case ~testPositionWithFloatsSVG~ according to changes made in ~testPositionSVG~.
         4. 22:24-22:26 He wants to check if the test ~testPositionWithFloatsSVG~ is yellow instead of red now. Q"Does the test ~testPositionWithFloatsSVG~ pass?"  GQ"(e7) Do the test cases pass?". It is yellow as he expected.
         5. 22:26-22:41 he goes back to ~testPositionSVG~ method and then he wants to know implementation of ~position~ method. Q"How does the ~position~ method looks like?" GQ"(17) What does the declaration or definition of this look like?" KM -> IM(58)
         6. 22:41-23:25 he observes implementations belonging to ~TRShape~ subclasses and concludes the position for SVG is computed from ~matrix~. He closes IM(58).
         7. 23:25-23:48 in B he observes implementation of ~TRSVGPath>>translateTo:~ Q"How does the declaration of ~TRSVGPath>>translateTo:~ look like?" GQ"(17) What does the declaration or definition of this look like?"
         8. 23:48-24:09 because it calls super, he goes to ~TRShape>>translateTo:~ in B Q"How does the declaration of ~TRShape>>translateTo:~ look like?" GQ"(17) What does the declaration or definition of this look like?"
         9. 24:09-24:25 he goes to the ~TRShape>>position:~ Q"How does the declaration of ~TRShape>>position:~ look like?" GQ"(17) What does the declaration or definition of this look like?"
         10. 24:25-24:46 he decided to check how the position is implemented in ~TRBoxShape~ browsing classes ~TRBoxShape~ and ~TRAbstractBoxShape~ Q"How does the ~position~ method is implemented in ~TRBoxShape~?" GQ"(34) How does the system behavior vary over these types or cases?". The result is that all the computation is in ~TRShape~ which is shared with ~TRSVGPath~.
         11. 24:46-25:11 he observes ~TRSVGPath~ methods in B interested if there is a method that could indicate some relation with position. Q"Does ~TRSVGPath~ have a method related to ~position~ behavior?" GQ"(6) What are the parts of this type?" Result: there is no any method.
         12. 25:11-25:15 he states he has no idea why it does not work and goes back to ~testPositionSVG~.
         13. 25:15-26:24 he decided to change ~drawOn:~ method including a method call witch draw encompassing rectangle. He believes it could help him to indicate where the problem is.  c"logging" c"transition-9"
         14. 26:24-27:46 Q"Do the encompassing rectangle and SVG path are drawn correctly?" GQ"(42) Does the behavior works 'correctly'?"
             1. 26:24-26:40 he goes to W c"workspace" c"prototype" c"transition-10" and executes the example Q"How does the drawn objects look at runtime?" GQ"(27) How does this data structure look at runtime?". When he sees the canvas he closes the window deciding to simplify the SVG path string.
             2. 26:40-26:46 he observers the example code c"example" c"transition-8-from-prototype" and thinks how he can simplify the SVG path Q"How the SVG path string can be simplified?" GQ"(4) How can be the code simplified?" he finds out that he do not know how to simplify it and he decided to use it.
             3. 26:46-27:46 he executes the example code c"prototype" c"transition-2" c"workspace" and observes the canvas and he finds out that the encompassing rectangle is bigger than the SVG image. He thinks it could have an impact to the position. He close the canvas.
         15. 27:46-29:25 he again decided to simplify c"example" c"transition-8-from-prototype" the SVG path string Q"How the SVG path string can be simplified?" GQ"(4) How can be the code simplified?"
             1. 27:46-27:54 he tries to understand the SVG path string. Q"What is the meaning of SVG path string?" GQ"(25) -d1- What is the purpose of this code?"
             2. 27:54-28:31 he wants to find another example c"example" of SVG path string. Q"Is there any example using SVG path?" GQ"(4) Is there a precedent or exemplar for this?"
                1. 27:54-28:31 he asks for the ~TRSVGPath~ references Q"Where the ~TRSVGPath~ is referenced?" GQ"(12) Where is this method called or type referenced?" C"We could offer to ask for a similar code like the highlighted code." IM(15)
                2. 28:00-28:12 he browses ~TRCanvasExample~ class interested if there is an example. He closes the browser.
                3. 28:12-28:31 back in IM(15) and he observes the other methods. Finally, he finds a simple one and copy it to the clipboard.
             3. 28:31-28:44 he pastes the SVG path string into W c"workspace" c"prototype" c"transition-2-prototype" and executes the example. Q"How does the output look like?"  GQ"(27) How does this data structure look at runtime?"
             4. 28:44-28:59 he removes ~scale:~ call from the example and execute the example again. c"workspace" c"prototype" c"simplify" Q"How does the output look like?" GQ"(27) How does this data structure look at runtime?"
             5. 28:59-29:25 he simplify the SVG path string in the example and executes it again. c"workspace" c"confidence" c"transition-7" c"simplify" Q"How does the output look like?"  GQ"(27) How does this data structure look at runtime?"  Now he is satisfied with the simplicity.
         16. 29:25-29:50 He observes the example output (the canvas) and he decides to find out how the encompassing rectangle is computed.
         17. 29:50-31:00 Q"How is the encompassing rectangle computed?"  GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"
             1. 30:00-30:37 he goes to ~encompassingRectangle~ method and he states that it is computed from ~points~ but it do not consider the ~position~.
             2. 30:37-30:48 he goes to ~translateTo:~ method considering that maybe for that reason there is that part of code
             3. 30:48-31:00 he thinks what to do next.
         18. 31:00-33:06 he wants to know how the encompassing rectangle is computed in ~TRBoxShape~. Q"How is the encompassing rectangle computed?"  GQ"(34) How does the system behavior vary over these types or cases?"
             1. 31:00-31:16 Q"Does ~TRBoxShape~ have a method related to encompassing rectangle behavior?" GQ"(6) What are the parts of this type?"
                1. 31:00-31:10 he observes methods of ~TRBoxShape~ and finds out there is nothing about encompassing rectangle.
                2. 31:10-31:16 he goes to ~TRAbstractBoxShape~ where he finds the method ~encompassingRectangle~ and observes its implementation.
             2. 31:16-31:30 he wants to now the implementation of calling method ~transformedEncompassingRectangle~ Q"How does the ~transformedEncompassingRectangle~ method look like?"  GQ"(17) What does the declaration or definition of this look like?" B KM B
             3. 31:30-32:16 according to the method's comment he supposes that this method should be called from ~TRSVGPath>>encompassingRectangle~
                1. 31:51-31:58 in order to prove his hypotesis, he checks where the method is called Q"Where the method ~transformedEncompassingRectangle~ is called?" GQ"(12) Where is this method called or type referenced?" B KN SN(2)
                2. 31:58-32:16 he observes where it is used, on which classes.
             4. 32:16-32:36 he observes the implementation of ~transformedEncompassingRectangle~ B, he finds interesting a method call ~basicEncompassingRectangle~
             5. 32:36-33:02 he goes to the method ~basicEncompassingRectangle~ in order to understand how it is implemented Q"How does the implementation of ~TRShape>>basicEncompassingRectangle~ look like?" GQ"(17) What does the declaration or definition of this look like?" B He finds that it is an abstract method.
                1. 32:39-32:44 He is interested in the concrete implementations Q"Who implements ~basicEncompassingRectangle~ abstract method?" GQ"(11) Who implements this interface or these abstract methods?"  and clicks on the green arrow next to the method in B. There two concrete implementation which he can choose. He choose ~TRAbstractBoxShape~
                2. 32:44-33:06 He observes the implementation of ~TRAbstractBoxShape>>basicEncompassingRectangle~ Q"How does the implementation of ~basicEncompassingRectangle~ look like?" Q17 He finds out that it has ~rectangle~ instance variable.
         19. 33:06-33:10 he goes to ~TRSVGPath~ to check if the class has also ~rectangle~ instance variable. He concludes that he could likely use the same implementation as it is done for ~TRBoxShape~.
         20. 33:10-34:00 he changes the implementation of ~encompassingRectangle~ in ~TRSVGPath~ according to ~TRAbstractBoxShape~.
             1. 33:10-33:30 he creates ~basicEncompassingRectangle~ method on ~TRSVGPath~ from ~encompassingRectangle~ method
             2. 33:30-33:49 he goes to ~TRAbstractBoxShape~ in order to understand how ~encompassingRectangle~ is implemented Q"How does the implementation of ~encompassingRectangle~ look like?" GQ"(17) What does the declaration or definition of this look like?"
             3. 33:49-34:00 he changes the ~encompassingRectangle~ in ~TRSVGPath~.
         21. 34:00-34:10 he goes to W c"workspace" c"confidence" c"transition-7-after-code-change" with the example in order to see the effect of the change. Q"How does the output look like?"  GQ"(27) How does this data structure look at runtime?" He says that it is much better, but maybe it is not enough.
         22. 34:10-34:32 he wants to test behavior of the ~scale:~, but he does not remember how he should write it. Q"How should I use the scale: behavior?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?" c"example" c"transition-8-from-confidence"
             1. 34:24-34:29 he watchs ~TRSVGPath~ references Q"Where is the ~TRSVGPath~ referenced?" GQ"(12) Where is this method called or type referenced?" and he finds the desired example with ~svg scale: 0.1~ code line. He close the IM.
             2. 34:29-34:32 he paste the code line into the Workspace. C"Assisting tool could also offer common input variables to the method calls"
         23. 34:32-34:40 he executes the example Q"How does the output look like?" GQ"(27) How does this data structure look at runtime?" and finds out that it does not consider the scale.
         24. 34:40-34:53 he decides to fix the scale problem later and removes the code line from the example.
         25. 34:53-34:58 he executes the example and without saying anything he close the canvas window. c"workspace" c"confidence" c"transition-2-to-confidence"
         26. 34:58-35:06 he goes to ~testPositionSVG~ and execute the test case c"tdd" c"transition-3" Q"Does the test case ~testPositionSVG~ pass?" GQ"(e7) Do the test cases pass?" No, it does not pass.
         27. 35:06-35:32 Q"Why it fails?" GQ"(e8) What does the failure look like?" c"runtime" c"transition-4"
             1. 35:15-35:20 is evaluates in c"debugger" DBG ~svg position~ Q"What is the return value of the method ~position~?" GQ"(19) What are the values of these arguments at runtime?"
             2. 35:20-35:32 he thinks and without a word he close the c"debugger" DBG.
         28. 35:32-39:09 he thinks that it is now about a design decision he should take Q"How does the behavior ~position~ vary over the ~TRSVGPath~ and ~TRBoxShape~?" GQ"(34) How does the system behavior vary over these types or cases?"
             1. 35:50-36:29 he goes to definition of ~TRSVGPath~ to see ~translateTo:~ method
             2. 36:35-36:45 he goes to ~TRShape~ see ~position~ method.
             3. 36:45-36:58 he watch the example in the Workspace while in ~position~ method.
             4. 36:58-37:24 He goes to another Workspace where he has example with ~TRBoxShape~
             5. 37:24-39:09 He thinks that ~TRBoxShape~ is centered in 0@0 while ~TRSVGPath~ not. He wants to check if it is true. He wants to write a test case. c"tdd" c"transition-1" Q"Is ~TRSVGPath~ centered in 0@0 on creation?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"
                1. 37:28-37:40 He goes to test case ~testPositionDefaultSVGPath~ where he finds that for ~TRSVGPath~ without path it is true.
                2. 37:40-37:46 He writes the test case ~testPositionDefaultSVGPath~ as ~testPositionDefaultSVGPathWithoutPath~
                3. 37:46-38:27 He changes the declaration of ~testPositionDefaultSVGPath~ and adds ~path: ....~
                4. 38:27-38:45 He executes the test cases ~testPositionDefaultSVGPathWithoutPath~ (it is green as he expects) and ~testPositionDefaultSVGPath~ (it is yellow as he expects)
                5. 38:45-39:09 He summarizes why the test cases ~testPositionSVG~ and ~testPositionWithFloatsSVG~ fails.
         29. 39:09-45:29 He discuss with other programmer in the office about the design decision. Q"What is the correct implementation of the position on ~TRSVGPath~?" GQ"(38) What is the correct implementation of the behavior?"
             1. 39:09-40:35 he explains the problem using the examples he has in the Worspaces
             2. 40:35-40:55 The other programmer (P4) says wants to explore the class ~TRSVGPath~ Q"How does the definition of ~TRSVGPath~ look like?" GQ"(17) What does the declaration or definition of this look like?"
             3. 40:55-41:20 P4 asks for the references of ~TRSVGPath~ Q"Where is the ~TRSVGPath~ referenced?" GQ"(12) Where is this method called or type referenced?" and has a results of 16 references. He observes some methods in the UsersOf window and then he close it, when he asks him what P4 is looking for.
             4. 41:20-43:45 They discuss about a possible solution
             5. 43:45-45:13 he conludes the discussion and he changes the SVG example in the Workspace c"workspace" c"prototype" c"transition-5"
                1. 44:11-44:35 c"example" c"transition-6" he does not remember how to write the code he wants to write and he decides to look for an existing example. Q"How should I use the mouse dragging?" GQ"(23) How is this feature or concern (object ownership, UI control, etc.) implemented?"
                   1. 44:16-44:25 he looks for references of ~TRMouseDragging~ Q"Where the ~TRMouseDragging~ is referenced?" GQ"(12) Where is this method called or type referenced?"
                   2. 44:25-44:35 he finds the example in ~RTDraggable~ class and copy and paste it to the Workspace.
                2. 44:35-45:13 he changes the example
             6. 45:13-45:29 c"workspace" c"confidence" c"transition-7" he executes the example and he tries if the object is draggable Q"Is the object draggable?"  GQ"(42) Does the feature behave as expected?", but it is not.  Then he closes the example window.
             7. 45:29 he is back in the Workspace and they conclude that the difference between SVG position and its center can stay as it is for now.
10. 45:29-47:25 he changes the test case ~testPositionDefaultSVGPath~ and explains the design decision in the method comment. c"tdd" c"transition-3"
11. 47:25-47:29 and he executes the test case ~testPositionDefaultSVGPath~ to check if it passes.  Q"Does the test case ~testPositionDefaultSVGPath~ pass?" GQ"(e7) Do the test cases pass?" Yes, it passes.
12. 47:29-47:42 he changes the test case ~testPositionSVG~
13. 47:42-47:45 he executes the test Q"Does the test case ~testPositionSVG~ pass?" GQ"(e7) Do the test cases pass?" No, it does not pass. It is red.
14. 47:45-47:50 he fixes the test case.
15. 47:50-47:54 he executes the test Q"Does the test case ~testPositionSVG~ pass?" GQ"(e7) Do the test cases pass?" No, it does not pass. It is yellow.
16. 47:54-49:20 c"runtime" c"transition-4-from-tdd" Q"Why it fails?" GQ"(e8) What does the failure look like?" he observes in the c"debugger" DBG
    1. 48:03-48:08 he evaluates in c"debugger" DBG ~svg position~ asking Q"What is the return value of the expression ~svg position~?" GQ"(19) What are the values of these arguments at runtime?"
    2. 48:08-48:40 he closes the c"debugger" DBG and he changes the test case ~testPositionSVG~
    3. 48:40-48:46 he executes the test Q"Does the test case ~testPositionSVG~ pass?" GQ"(e8) What does the failure look like?" No, it does not pass. It is yellow.
    4. 48:46-48:52 he observes the test case in c"debugger" DBG
    5. 48:52-48:56 he changes the test case in c"debugger" DBG
    6. 48:56-49:08 he checks if the return value of ~svg position~ Q"What is the return value of the expression ~svg position~?"  GQ"(19) What are the values of these arguments at runtime?" is equal with the expected value. But it is not.
    7. 49:08-49:20 he tries another test case definition but the values are still not equal.
    8. 49:20 he does not find the answer.
17. 49:20 the session finished
* Sessions November 2014
** Session S14 with P8, familiar code (S2py Test Framework)
   :PROPERTIES:
   :VideoFile: videos/S14-P8.m4v
   :Familiar: 1
   :SESSION-ID: S14
   :PARTICIPANT-ID: P8
   :END:
*** Tool Usage
1. 00:00-00:54 c"rest-time"
2. 00:54-11:27 c"static-tool"
3. 11:27-11:42 c"dynamic-tool"
4. 11:42-12:32 c"static-tool"
5. 12:32-12:56 c"dynamic-tool"
6. 12:56-19:12 c"static-tool"
7. 19:12-20:01 c"dynamic-tool"
8. 20:01-22:35 c"static-tool"
9. 22:35-22:43 c"dynamic-tool"
10. 22:43-28:49 c"static-tool"
11. 28:49-29:08 c"dynamic-tool"
12. 29:08-29:24 c"static-tool"
13. 29:24-29:27 c"dynamic-tool"
14. 29:27-31:06 c"static-tool"
15. 31:06-31:18 c"dynamic-tool"
16. 31:18-31:48 c"static-tool"
17. 31:48-31:50 c"dynamic-tool"
18. 31:50-34:18 c"static-tool"
19. 34:18-34:44 c"dynamic-tool"
20. 34:44-35:25 c"static-tool"
21. 35:25-35:29 c"dynamic-tool"
22. 35:29-35:44 c"static-tool"
23. 35:44-35:45 c"dynamic-tool"
24. 35:45-36:12 c"static-tool"
25. 36:12-36:14 c"dynamic-tool"
26. 36:14-37:35 c"static-tool"
27. 37:35-37:37 c"dynamic-tool"
28. 37:37-48:47 c"static-tool"
29. 48:47-48:58 c"dynamic-tool"
30. 48:58-49:14 c"static-tool"
31. 49:14-50:35 c"dynamic-tool"
32. 50:35-50:48 c"static-tool"
33. 50:48-50:50 c"dynamic-tool"
*** Transcript
1. 00:00-00:57 c"explain" He explains his task: Framework for testing Spy profilers
2. 00:57-01:55 c"recall" c"navigate" He is recovering information from previous work, going to package ~S2py~, class ~S2Tester~, and reading instance variables ~beforeRunBlock~, ~runWithInBlock~, ~afterRunBlock~, ~messageNotUnderstoodBlock~ and their method accessors. Behavior is missing; checking it by going to class ~S2TesterMethod~ and seeing its method ~beforeRun:with:in:~.
3. 01:55-02:24 c"explain" He explains what is going to implement.
4. 02:24-03:04 c"implement" c"method" Implementing method ~beforeRun:with:in:~ in class ~S2TesterMethod~.
5. 03:04-03:24 c"implement" c"method" Implementing method ~run:with:in~ in class ~S2TesterMethod~.
6. 03:24-03:47 c"implement" c"method" Implementing method ~afterRun:with:in:~ in class ~S2TesterMethod~.
7. 03:47-03:57 c"navigate" c"recall" Going to class ~S2Tester~ in order to recall method names.
8. 03:57-04:03 Going to class ~S2TesterMethod~ in order to check that he implemented everything he need. Q"What are the parts of ~S2TesterMethod~?" Q6
9. 04:03-05:16 c"explain" c"navigate" going to class ~S2Tester~ and explaining why he has method ~messageNotUnderstoodBlock~ for a specific plugins. Going to package ~S2py-Plugins~, then to ~S2py-StringProfiler~ displaying method ~afterStringNew:~.
10. 05:16-05:54 c"navigate" c"recall" goes to class ~S2Tester~ and method ~messageNotUnderstoodBlock~, then opens new Nautilus Browser which he immediately closes, opens Workspace writing ~messageNotUnderstood:~ and immediately closes it, opens again Nautilus, goes to ~ProtoObject~ class, looks for method ~doesNotUnderstand:~ because he does not remember well the exact name. Q"What is the exact method name called like ~doesNotUnderstand:~?" GQ"(e2) FFP: -3a- What is the exact entity name of this behavior?"
11. 05:54-06:50 c"navigate" c"recall" he copies the method name, goes to the first Nautilus window with the class ~S2Tester~ and method ~messageNotUnderstoodBlock~. c"implement" Here he implements method ~doesNotUnderstand:~.  Switches again to the second Nautilus browser to ensure that ~aMessage~ input parameter of ~messageNotUnderstood:~ is an object of Message. C"The information was not there, but it was enough for him to know that he is right."  Q"What is the type of variable ~aMessage~?" Qe5
12. 06:50-07:02 c"navigate" c"check-assumption" He search for ~cull:~ implementors to check if his implementation is correct. Q"What does the ~cull:~ method looks like?" Q17 Then he closes the Implementor's window.
13. 07:02-07:50 c"observer" c"explain" c"check" Observer asked why he observes the methods around in ~S2Tester~; the answer is that he was checking if everything is implemented. Q"Is all necessary behavior of ~S2Tester~ implemented?" Q6
14. 07:50-08:29 c"explain" he goes to package ~S2py-Tests~ and explains how he can write test case of that behavior.
15. 08:29-09:26 c"implement" c"test-case" c"navigate" c"copy" he writes new test class ~S2TesterSpy~, copies method ~setUp~ from ~S2SenderTest~ and changes it. Then he opens new Nautilus window with ~S2TesterSpy~ class. Goes to ~S2py-Tests-Utility~, class ~S2Tester~.
16. 09:26-10:06 c"implement" c"doubt" he goes to the first Nautilus with test class and writes ~tearDown~ method that he removes immediately. He implements ~testVoid~ method.
17. 10:06-10:19 c"example" c"navigate" c"search-exemplar" c"copy" goes to ~S2SenderTest~ class, observes all the test methods, then goes to ~S2ProfilerTest~ class, observes ~testBehavior~ method and copy its contents. Q"Which existing method fits best for my new test case ~testVoid~?" Q4
18. 10:19-10:40 c"implement" c"paste" Goes to ~S2TesterSpy~ class and ~testVoid~ method and pastes the copied contents.
19. 10:40-11:06 c"explain" He explains its dummy classes ~S2pyA~ and ~S2pyB~ and their purpose.
20. 11:06-11:27 c"implement" goes back to ~S2TesterSpy>>testVoid~ and proceed changes.
21. 11:27-11:32 c"run-test" Qe7 c"save" executes the test case ~testVoid~, but before he saves the image.
22. 11:32-22:42 c"test-fails" c"unexpected-failure" the test case fails and he observes in c"debugger" why: looks at ~S2TesterMethod>>run:with:in~ method. Qe8 He closes the debugger.
    1. 11:41-12:23 c"fix" c"change" He goes to ~S2TesterMethod>>run:with:in~, he says that it should fail, because he does not define ~runWithInBlock~ yet, but in that case a message is send to a wrong object. He fixes the methods ~run:with:in~, ~beforeRun:with:in:~, and ~afterRun:with:in~.
    2. 12:23-12:38 he goes back to Nautilus with the test case ~testVoid~ supposing that it should still fail,
    3. 12:38-12:41 c"run-test" c"test-fails" c"expected-failure" executes the ~testVoid~  test and c"debugger" appears; this is what he expected. Qe7
    4. 12:41-22:42 c"observe" in the c"debugger" he thinks about ~runWithInBlock~ and closes the debugger. Qe8
       1. 12:57-13:21 c"explain" c"consider" he explains that he was thinking what should be executed first, if ~run:with:in:~ or ~beforeRun:with:in:~. He explains that it should be ~run:with:in:~. Q"What is the right order of method calls for ~run:with:in~ and ~beforeRun:with:in~?" Q38
       2. 13:21-19:12 <<t1link1>> c"implement" goes to ~S2py-Tests-Utility~ package, ~S2Tester~ class, and implements ~initialize~ method. When he writes line with ~runWithInBlock:~ he thinks about its argument. c"false-assumption-marked-as-miss-opportunity" c"miss-opportunity" C"I am not sure if it is correct to call it false-assumption. He forgot to write =super initialize=, that he fixes at [[t1link2][21:22]]."
          1. 14:51-16:36 c"implements" he explains the he should call =super run:with:in:= and goes to Nautilus with ~S2TesterMethod>>run:with:in:~ method and creates new method ~superRun:with:in:~. c"ide-improper-behavior" He two times tries to accept the code, but as he use input variable name ~selector~ that is already used as instance variable, he cannot accepted. C"I have an impression, that he did not read the error message; maybe because it is inserted directly into the code. After the third try, he finally reads the error message." Q"Why the source code of the method ~superRun:with:in:~ cannot be compiled?" Qx"Related to wrongly written source code."
          2. 16:36-16:57 c"explains" c"not-ideal-implementation" he claims that the ~superRun:with:in:~ is not the most nice solution, but it is what we have. And he explains that S2py profiler is not a practical tool to show good practice C"I hope I understood well Spanish".
          3. 16:57-17:24 c"navigate" c"how-to-implement" he is back in the method ~initialize~ and thinks how to finish the implementation. Q"How can I implement the desired behavior in ~initialize~ method?" Q38
          4. 17:24-18:19 c"change" c"confident" he is back in Nautilus with ~S2TesterMethod>>superRun:with:in:~ and claims that he needs an accessor to ~S2TesterMethod~. He goes to ~run:with:in:~ and changes its implementation. The same change is done in ~beforeRun:with:in:~ and ~afterRun:with:in:~. Then he goes to ~superRun:with:in:~ and claims that everything is fine.
          5. 18:19-19:12 c"implements" He goes to ~S2Tester>>initialize~ in the same Nautilus and changes its implementation.
       3. 19:12-19:30 c"save" he saves the image, c"run-test" Qe7 goes to another Nautilus and package ~S2py-Tests~ where he executes test cases on class ~S2TesterSpy~. There is only one ~testVoid~ that fails. c"test-fails" So he selects this method and run only this test case. c"consider-why-it-fails"
       4. 19:30-22:35 Qe8 It raises the debugger and observers why it fails; c"navigate" c"debugger" he watches ~S2Tester(S2Profiler)>>gatherForClassCategory:~ method and ~S2Tester(S2Profiler)>>profile:onClassCategory:~ He did not expected this error. c"unexpected-failure" c"how-to-fix" He identifies that there is a problem with ~classPlugins~ and closes the debugger. c"explain" He explains that ~classPlugins~ are defined as pragmas.
          1. 20:01-20:58 c"navigate" He browses categories in ~S2py~ and claims that right now he does not have any class-plugin in the profiler. c"false-assumption" c"explain" Then he sais that a good example is ~StringProfiler~ which he selects and shows in ~stringNewPlugin~ method ~<S2ProfilerPlugin>~ pragma. He sais that he does not want to do that, because he does not want to change his dummy classes (~S2pyA~ and ~S2pyB~). Then he explains how it works internally and c"decide" decides that he will simulate it without using the pragma declaration.
          2. 20:58-21:12 c"navigate" He goes to ~S2Tester~ class and observes ~profilerPlugins:~ and ~methodPlugins:~ methods. Q17
          3. 21:12-21:17 c"navigate" c"instance-variable" Then he clicks on "Instance variables in ~S2Tester~" button and when he see all the instance variables, he closes the dialog window. Q6
          4. 21:17-21:22 c"explains" Then he explains that he wanted to see where ~methodPlugins~ and ~profilerPlugins~ instance variables are defined and he understands that he modifies them in the superclass "desde arriba".
          5. 21:22-22:16 <<t1link2>> c"navigate" goes to ~S2Tester>>initialize~ and initialize ~methodPlugins~ instance variable. c"change" Then he removes this new line thinking that ~methodPlugins~ should be initialize by default and in that moment he finds out that there is no =super initialize= line. c"fix-introduced-bug"
          6. 22:16-22:35 c"navigate" c"check-assumption" then he goes to ~initialize~ of superclass to see if ~methodPlugins~ is initialized there. Then he closes Nautilus with this super class definition. Q"Is the ~methodPlugins~ instance variable initialize in the super class of ~S2Tester~?" Q41
       5. 22:35-22:42 c"run-test" Qe7 goes to Nautilus with ~S2TesterSpy>>testVoid~ and executes this test. It is green. c"green-tests"
23. 22:42-23:52 c"consider" now he thinks about following test cases he should write. Q"What is the next feature I should write test case for?" Qx"The question is about what to do next in order to proceed the task." c"navigate"
    1. 22:42-23:52 Q"How does the existing test cases looks like?" Q6 He goes to ~S2BasicNewTest~ and then ~S2ProfilerTest~ observing all written test cases. c"example" c"search-for-exemplar" Then he goes to ~S2BasicNewTest~ and also observes its test cases and c"explain" explains the purpose of the tests. c"navigate" Then he goes to ~S2BasicNewStub~ and c"explains" explains its relation to ~S2BasicNewTest~. During the explanation he observes its methods ~myMethoPlugin~, ~basicNewPlugin~, and ~registryName~. Then he clicks on ~S2BasicNewStubClass~, ~S2BasicNewStubMethod~, and ~S2BasicNewStubPackage~ classes finishing his explanation.
24. 23:52-24:04 c"navigate" c"false-navigation-in-packages" Then he goes to ~S2py-Tests-Utility~ package. C"I think he was looking for ~S2TesterSpy~ but he clicked on two other packages before he finally found it." Then he goes to ~S2py-Tests~ package where is his desired ~S2TesterSpy~ class, clicks on ~testVoid~ method.
25. 24:04-28:49 c"implement" c"reuse-code" implements new method ~testCountBefore~
    1. 24:20-24:39 c"explain" he explains how existing code from ~testVoid~ works.
    2. 24:39-28:49 c"implement" he implements the test case.
26. 28:49-28:51 c"run-test" c"unexpected-failure" Qe7 he executes the test case ~testCountBefore~ which fails, but he did not expected it.
27. 28:51-29:12 c"observe" c"debugger" Qe8 In debugger observes ~S2TestSpy>>testCountBefore~.
    1. 29:01-29:08 c"evaluate-expression" He evaluates an expression that he supposed to be equal to one c"unexpected-value", but it is equal to two. Q19
    2. 29:08-29:12 He closes the inspector with number two and closes the debugger. He is back in Nautilus
28. 29:12-29:24 c"reveal-error" Then he find out his error in the test case and changes the implementation. He explains the reason looking at the test case. c"fix-test-case"
29. 29:24-29:27 c"run-test" Qe7 c"green-tests" he executes the test case ~testCountBefore~ which is green.
30. 29:27-30:32 c"implement" c"reuse-code" He implements new test case ~testCountRunWithIn~.
31. 30:32-30:38 c"change-wording" he finds out a typo ~reciever~ instead of ~receiver~ and decides to fix it also in the method ~testCountBefore~.
32. 30:38-30:57 c"rename-method" he renames ~testCountRunWithIn~ to ~testCountRunWithIn1~.
33. 30:57-31:06 he observes his test case and comments it.
34. 31:06-31:18 c"run-test" Qe7 c"test-fails" he executes the test case ~testCountRunWithIn1~ which fails. c"why-test-fails" Qe8 He observers in c"debugger" method ~S2TesterSpy>>testCountRunWithIn1~ and Q19 values of ~assert:equals:~. He closes the debugger. He did not expected this failure. c"unexpected-failure"
35. 31:18-31:48 c"change" c"fix-test-case" he fixes the test case ~testCountRunWithIn1~
36. 31:48-31:50 c"run-test" Qe7 c"green" and runs it again. Now it is green.
37. 31:50-34:18 c"rename-method" he renames ~testCountRunWithIn1~ back to ~testCountRunWithIn~ and c"implement" c"reuse-code" implements new test case ~testRunWithIn~. Q"How I can test return values for ~runWithInBlock:~?" Q38
38. 34:18-34:21 c"run-test" Qe7 c"test-fails" c"unexpected-failure" he executes the test case ~testRunWithIn~ which fails; he did not expected it.
39. 34:21-34:44 Qe8 c"observer" c"debugger" He observes in the debugger method ~S2TesterSpy>>testRunWithIn~. c"reveal-error" He understand why it fails and closes the debugger.
40. 34:44-35:06 c"navigate" he goes to ~S2pyB>>foo~ method to see the implementation; c"check-assumption" it ascertains his previous thoughts. Q"Am I right in my thoughts?" He also observes ~bar~ method and checks methods ~foo~ and ~bar~ in ~S2pyA~ class. Q17 He closes the Nautilus.
41. 35:06-35:25 c"explain" he explains what happens and that he does not want to change ~S2pyA~ and ~S2pyB~ classes because it could affect other existing test. He wants to have it first stable, before changing anything.
42. 35:25-35:28 c"run-test" Qe7 c"test-fails" c"check-assumption" c"debugger" he runs again the test case ~testRunWithIn~ seeing that it fails and closes the debugger.
43. 35:28-35:43 c"change" c"fix-test-case" he changes the test case ~testRunWithIn~
44. 35:43-35:45 c"run-tests" c"green" and executes it; it is green.
45. 35:45-36:12 c"implements" c"reuse-code" now he implements test case ~testCountAfter~ using test case ~testCountBefore~.
46. 36:12-36:14 c"run-tests" Qe7 c"green" and executes it; it is green.
47. 36:14-37:35 c"refactor" he refactors the same part of code from the new test cases.
48. 37:35-37:37 c"run-tests" Qe7 c"green" and executes all the test cases of ~S2TesterSpy~ class; they are green.
49. 37:37-38:26 c"clean-code" c"save" He categorizes methods and saves the image.
50. 38:26-48:47 c"what-next" Q"What should I test/implement next?" Qx"The question is about what to do next in order to proceed the task."  c"implements" He thinks about next step and then implements new test case ~testMessageNotUnderstood~.
    1. 38:50-41:08 Q"How can I test ~messageNotUnderstooBlock~?" Q38
       1. 39:24-39:47 he goes to the next Nautilus searching for ~S2Tester~ and its c"rename-method" c"refactor" method name where he renames ~messageNotUnderstoodHandler:~ to ~messageNotUnderstoodBlock:~. c"lost-in-packages" C"I have an impression that as he has a lot of class categories in ~S2py~ package, he regularly clicks on several ones before finding the right one."
       2. 39:47-40:10 c"implement" he goes back to ~testMessageNotUnderstood~ method and continues in the implementation.
       3. 40:10-41:03 c"navigation" c"what-are-parameters" goes back to Nautilus with ~S2Tester~ watching ~initialize~ for block arguments names Q"What are the arguments for the block ~messageNotUnderstoodBlock~?" Q18 and finds out that ~messageNotUnderstoodBlock~ is not initialized c"fix-potentional-error" C"a potential bug revealed in advance?". c"implements" He adds the line of code to ~initialize~
       4. 41:03-41:08 c"navigate" goes back to Nautilus with ~S2TesterSpy>>testMessageNotUnderstood~
    2. 41:08-45:11 c"navigate" and immediately to the previous Nautilus with ~S2Tester>>initialize~. c"want-better-implementation" He previously wrote =Error signal= but he wants to have a better solution. Q"What is the better solution to ~messageNotUnderstoodBlock~ behavior?" GQ"(38) How can I improve current implementation?"
       1. 41:27-42:49 c"browse" c"class-hierarchy" browses ~Error~ class searching and observes its subclasses in ~Kernel-Exceptions~ package. Q8 c"vague-search" He want something like "personalized error with an message." Q5 C"I guess he wants to write =self error: 'error message'=."
          1. 42:15-42:49 c"navigate" he see that ~Exception~ class has methods ~messageText~ or ~tag~ and asks Q"What ~tag~ is used for?  Who use ~tag~?" Q25
             1. 42:15-42:22 c"browse" he browses users of ~tag~ instance variable and receives two methods ~tag~ and ~tag:~. Q"Who uses ~tag~ instance variable?" Q15
             2. 42:22-42:29 then he asks Q"Who sends ~tag~ method?" Q12 and have a window with 13 senders c"fine-result". Then he closes it.
             3. 42:29-42:32 then he closes the ~tag~ users window.
             4. 42:32-42:39 c"navigate" and he is back in Nautilus with ~Exception~ class observing other method names Q6
             5. 42:39-42:42 c"consider" c"right-assumption" then he states that ~messageText~ is something he can use for his purpose.
             6. 42:42-42:49 c"navigate" he goes to the class side of ~Exception~ observing method ~signal:~ and closes the Nautilus. Q"What method can be used to set ~messageText~?" Q15
       2. 42:49-44:11 he goes to the Nautilus with ~S2TesterSpy>>testMessageNotUnderstood~ and c"consider" thinks how to implement the test case. He thinks to use something like =self should:raise:= and he decides to implement its specialized exception class. c"answer-for-upper-question"
       3. 44:11-44:38 c"implements" he goes to ~S2py-Tests-Utility~ package and defines new class ~S2TestException~.
       4. 44:38-44:51 c"possible-session-end" The observer informed him, that he can finish the session whenever he wants. He decides to finish the test case.
       5. 44:51-45:11 c"implement" he goes to ~S2py-Tests~ package, then ~S2py-Tests-Utility~ package and ~S2Tester>>initialize~ method where he uses the class ~S2TestException~.
    3. 45:11-46:44 c"implement" he goes to ~S2TesterSpy>>testMessageNotUnderstood~, c"rename-method" renames it to ~testMessageNotUnderstood1~ and implements it
       1. 45:55-46:21 c"search-method-name" he does not remember how ~should:raise:~ method is exactly called. Q"What is the exact method name for something like ~should:raise:~ behavior?" C"I have an impression that this is different from FFP questions, because he knows where to search for. It is more like clarification, because he knows where the behavior is implemented." He opens new Nautilus and search for class ~TestCase~, Qe1 then switch to class ~TestAsserter~. Then he finds ~should:raise:~ method and close the Nautilus.
       2. 46:21-46:38 c"implement" then he continues implementing ~testMessageNotUnderstood1~ but c"forget-recent-class-name" he does not remember how the recently created exception class ~S2TestException~ is called.
       3. 46:38-46:41 c"search-class-name" he goes to other opened Nautilus where he finds ~S2TestException~ definition. Q"What is the exact class name I have recently implemented?"
       4. 46:41-46:44 c"implement" and continues writing the test case ~testMessageNotUnderstood1~.
    4. 46:44-48:47 c"change" he removes the old ~testMessageNotUnderstood~ method and writes other code in ~testMessageNotUnderstood1~. c"confusing-tool-behavior" C"He was surprised that written method call ~messageNotUnderstoodBlock:~ has red color; it was parsed together with following line of code. He almost wanted to go to other Nautilus to see the name." C"It is also happened again that he had an error when trying to accept code, but he did not read the message. He read it after second try." Q"Why the code is highlighted as not existing method?"
51. 48:47-48:50 c"save" c"run-tests" Qe7 c"red" c"unexpected-failure" he saves the image and executes the test ~testMessageNotUnderstood1~; it is read. It is not expected.
52. 48:50-48:58 Qe8 c"observe" He observes ~BlockClosure>>value:~ and ~BlockClosure>>numArgsError:~ in the c"debugger" and closes it. C"Maybe the r1 question can be divided into 17, because he was not interested in behavior, he only observed source code."
53. 48:58-49:14 c"navigation" he goes to Nautilus and observes method ~S2TesterMethod~ class and its method names. Then goes to ~S2Tester~ class where he finds the desired message ~messageNotUnderstoodBlock:~. c"fix" Then he goes to ~doesNotUnderstand:~ method where he finds the error and fixes it. c"is-this-question?"
54. 49:14-49:17 c"run-tests" Qe7 c"yellow" c"unexpected-failure" he goes to the Nautilus with test case ~testMessageNotUnderstood1~ and executes it; it is yellow.
55. 49:17-50:13 Qe8 c"observe" He observes ~S2TesterSpy(TestAsserter)>>should:raise~ and ~S2TesterSpy>>testMessageNotUnderstood1~. Then he does not understand why it fails and decides to debug =profiler bar=. c"evaluate-expression"
    1. 49:39-50:13 Q19 c"observe" he debugs it in the new c"debugger"
       1. 50:04-50:05 when he is in ~S2TesterSpy>>testMessageNotUnderstood1~ method, he is interested in return value of =message selector=. Q19 c"evaluate-expression" He inspects it a receives =#bar= value and closes the inspector.
       2. 50:05-50:13 c"reveal-error" then he finds the error
56. 50:13-50:48 c"fix-test-case" and fixes it in the c"debugger". As he is in nested block, he cannot accept the code from the debugger. He copies the new code, closes the debugger, and goes to Nautilus where he fixes the issue.
57. 50:48-50:52 c"run-tests" Qe7 c"green" c"save" he executes the test case ~testMessageNotUnderstood1~ and it is green. He saves the image
58. 50:52-50:56 session finished
** Session S5 with P8, unfamiliar code (Nautilus History as Plugin)
   :PROPERTIES:
   :VideoFile: videos/S5-P8.m4v
   :FUEL: dflow/S5-P8.fuel
   :VIDEO-START-TIME: 2014-11-07T15:15:09.04654-03:00
   :Familiar: 0
   :SESSION-ID: S5
   :PARTICIPANT-ID: P8
   :END:
*** Tool Usage
1. 00:00-00:13 c"rest-time"
2. 00:13-02:29 c"testing-behavior"
3. 02:29-03:02 c"dynamic-tool"
4. 03:02-03:21 c"testing-behavior"
5. 03:21-03:32 c"static-tool"
6. 03:32-03:47 c"testing-behavior"
7. 03:47-04:39 c"dynamic-tool"
8. 04:39-06:16 c"static-tool"
9. 06:16-08:36 c"dynamic-tool"
10. 08:36-09:36 c"static-tool"
11. 09:36-09:44 c"testing-behavior"
12. 09:44-10:38 c"dynamic-tool"
13. 10:38-11:49 c"static-tool"
14. 11:49-11:55 c"testing-behavior"
15. 11:55-15:03 c"static-tool" he uses Finder
16. 15:03-16:37 c"dynamic-tool"
17. 16:37-17:06 c"static-tool"
18. 17:06-18:35 c"dynamic-tool"
19. 18:35-18:45 c"static-tool"
20. 18:45-19:18 c"dynamic-tool"
21. 19:18-19:41 c"static-tool"
22. 19:41-22:10 c"dynamic-tool"
23. 22:10-22:43 c"static-tool"
24. 22:43-23:23 c"dynamic-tool"
25. 23:23-26:06 c"static-tool"
26. 26:06-26:23 c"testing-behavior"
27. 26:23-26:31 c"dynamic-tool"
28. 26:31-28:04 c"static-tool"
29. 28:04-28:50 c"dynamic-tool"
30. 28:50-31:55 c"static-tool"
31. 31:55-34:58 c"dynamic-tool"
32. 34:58-35:21 c"static-tool"
33. 35:21-35:41 c"dynamic-tool"
34. 35:41-35:51 c"static-tool"
35. 35:51-36:39 c"dynamic-tool"
36. 36:39-36:55 c"static-tool"
37. 36:55-37:01 c"dynamic-tool"
38. 37:01-37:17 c"static-tool"
39. 37:17-37:46 c"dynamic-tool"
40. 37:46-37:59 c"static-tool"
41. 37:59-38:16 c"dynamic-tool"
42. 38:16-42:39 c"static-tool"
*** Transcript
1. 00:00-00:07 Initial image setup
2. 00:07-01:48 observes functionality of the plugin system of Nautilus. Activates several ones a reveals that it is necessary to open a new Nautilus to see an effect. Then he removes all of them and choose only one that he decides to analyse closely. Q"What is the current History Browser behavior?" Q25
3. 01:48-03:26 <<t2link10>> c"halo" Q"What class implements ~URLPlugin~?" Q1
   1. 01:48-02:23 <<t2link8>> c"halos" wants to use halos; a feature that enable to inspect UI widgets. He thinks that it is necessary to activate it c"false-assumption-removed" C"I remove it because this is about using development tool." and search for a settings in Setting Browser. He explains that he can observe the UI widget and see who is it. He cannot find it in the Setting Browser and closes it. Q"How can I activate halos feature?" Qx"it is about tool usage, not about application."
   2. 02:23-02:28 c"observer" He is thinking about another approach to find out what UI object it is, but the observer decides to tell him, that halos are available on a particular key shortcut.
   3. 02:28-02:57 c"fails-using-tool-feature" c"halos" he uses halos inspecting the widget of the plugin. He cannot find how to see the Morphic structure. Q"What is the UI widget structure of the Nautilus?" Q27  c"inspector" Closes the inspector and decides to achieve the information different way.
   4. 02:57-03:18 c"browse" opens Nautilus Plugins Manager in order to see what is the name of the activated plugin. Q"What is the name of the recently activated plugin?" Q1 It is called ~URLPlugin~.
   5. 03:18-03:26 opens Workspace and writes the ~URLPlugin~. As it is name of an class, he browses it and closes the Workspace.
4. 03:26-11:59 <<t2link11>> C"I believe that he tries to understand where the UI widget of History Navigator is defined." C"in 05:12 he says that he needs to understand how UI is created." C"in 05:25 he sais:" Q"How/Where is this Nautilus UI created? Or likely more specifically How are Nautilus plugins created?" Q3 c"not-answered" C"He does not understand how the plug-in UI is created."
   1. c"halo" c"false-navigation?" C"~PackageTreeNautilusUI~ is not the class he wants to know, I think."
      1. 03:47-04:17 <<t2link9>> c"halos" he displays halos over the History Navigation List and searches how to inspect the widget. c"ide-confusion" C"The feature he wants is defined on 'debug' halo, but apparently it is a confusing name and he searches for other name, something like 'inspect'." Q"How can I inspect the UI widget of ~History Navigator~?" Qx"Related to tool usage, not to application." in the end he clicks on the 'debug' halo and uses 'inspect model'. C"he should use 'inspect morph' instead."
      2. 04:17-04:36 c"inspector" he reveals that it is an ~PackageTreeNautilusUI~, observes its instance variables. He states that this is likely not the drop list ~History Navigation List~.
      3. 04:36-04:39 he writes =self browse= in the inspector in order to browse object class Q6
      4. 04:39-05:25 he decides to browse the class of ~PackageTreeNautilusUI~ object and immediately asks for class references. c"class-references" Q"Who uses ~PackageTreeNautilusUI~ class?" Q12
         1. 04:49-04:56 there is only one usage in ~PackageTreeNautilus>>defaultUIClass~
         2. 04:56-04:59 then he asks for senders of ~defaultUIClass~ and there is again only one sender in ~Nautilus>>uiClass~.
         3. 04:59-05:08 he asks for senders of ~uiClass~, there are 4.
         4. 05:08-05:12 and focuses to ~Nautilus>>open~ method where observes method definition Q17.
         5. 05:12-05:25 he closes the previous two sender windows and keeps the one with ~Nautilus>>open~, opens it in Nautilus, and also closes the last sender window. He says S"As I am not familiar with UI creation, I need to know how they are created."
   2. 05:25-09:28 Continues que question about Nautilus UI creation
      1. 05:25-05:58 he observes methods of ~Nautilus~ class first on instance class, then on class side. Q6 c"miss-opportunity" C"He observes ~history~ protocol of Nautilus package, he could 'save' these observation for later use. In that moment, he is interested where plugins are created. This is a different focus."
      2. 05:58-05:59 meanwhile he closes another Nautilus window with ~PackageTreeNautilusUI~.
      3. 05:59-06:08 then he, I believe accidentally, clicks on a Nautilus browser with ~RBFormatterTests>>testCoreSystem~ while explaining me his thoughts. He finally clicks on the right Nautilus window with ~Nautilus~ class.
      4. 06:08-06:25 The he opens Workspace and executes script =Nautilus open= and closes the new Nautilus window. C"I think it was just a check if it works."
      5. 06:25-07:37 He debugs =Nautilus open= and several times step-in. Observes ~NautilusUI>>open~ method Q17. He finds out that in that moment the UI is already created (but not visible)
      6. 07:37-08:16 and he decides to got one step back on the stack to ~Nautilus>>open~ where =self uiClass on: self= is called. He believes that this part creates the UI with the plugin ~URLPlugin~. Observes ~uiClass~ instance variable value which is ~NautilusUI~ class and steps-in to =#on: self= method.
      7. 08:16-08:28 he observes ~NautilusUI(AbstractNautilusUI)>>model:~ method Q17, and also its parameter value of ~anObject~ which is an instance of ~Nautilus~ class.
      8. 08:28-09:28 I think that he does not see any relevant code for UI creation here and for that reason he decides to inspect ~self~ which is an instance of ~NautilusUI~ class. In that moment the c"debugger" does not browse the class, but raise an error. C"Apparently because a line in list widget is not selected." so he closes the new debugger. c"miss-opportunity" C"There is an announcement at 08:33 called ~historyChanged~. He does not see it because he is focused on plugin creation."
         1. 08:37-08:51 he decides to open Workspace where he writes ~Nautilus~ and browse it. Then he remember that the class is called ~NautilusUI~ so he closes the new Nautilus window, goes back to the Workspace, writes ~NautilusUI~ and browse it.
         2. 08:51-09:14 goes to the class side of ~NautilusUI~ and observe ~buildHistoryShortcutsOn:~ method C"I have an impression that he does not need to know this method."  Then he goes to instance side and observes its methods.
         3. 09:14-09:28 In that moment he see that he cannot find a desired information and because he has a limited time, he closes the most of the windows.
   3. 09:28-10:37 <<t2link1>> he is back in Nautilus with ~URLPlugin~ observing its class hierarchy. Then he opens ~Nautilus Plugin Manager~ and he inspects ~AbstractNautilusPlugin~ class. In the inspector he executes =self withAllSubclasses= and compares this list (subclasses list) with the list of plugins (plugin list) in Nautilus Plugin Manager. He can see that plugin list contains ~BreadCrumbs~ that is missing in subclasses list. C"Most of the plugins are called the same way as their classes. This is one exception where the class is called ~NautilusBreadcrumbsPlugin~." Then he counts items in the plugin list which has 14 items. The subclasses list has 15. c"false-assumption" He thinks that plugins are not defined (or listed, or searched) by subclassing ~AbstractNautilusPlugin~; there should be another type of annotation  pragma framework is another possible usage. C"He forgot that in the subclasses list is also included ~AbstractNautilusPlugin~" He closes the Nautilus Plugin Manager.
   4. 10:37-10:49 <<t2link2>> He observes class side of ~URLPlugin~, particularly ~defaultPosition~ and ~description~ methods. He can see that there is not much information clicking around the other classes in the ~AbstractNautilusPlugin~ hierarchy.
   5. 10:49-11:05 then he switch Nautilus view to hierarchy view and observes ~AbstractNautilusPlugin~ which is super class of ~URLPlugin~. He observes its class side methods: ~possiblePositions~, ~pluginName~, ~model:~, ~description~, and ~defaultPosition~. There are not much information. He switch to instance side and finds ~registerTo:~ method. C"Apparently this is a promising method name".
   6. 11:05-11:27 He goes to ~URLPlugin>>registerTo:~ method Q17 and immediately observers other methods: ~display~, ~changed:~, and ~buildString~. He goes to the class side and observes ~description~ and ~defaultPosition~ methods. C"He is looking for a pragma all the way around, but there is no such method.  For that reason he then observes ~AnnotationPanePlugin~ and ~IgorsPlugin~ that are subclasses of ~URLPlugin~." He observes ~IgorsPlugin~ and its method ~buildString~ and ~AnnotationPanePlugin~ and its method ~buildString~. Then he clicks on class side, but there is no any indication of pragma usage.
   7. 11:27-11:59 he decides for a new strategy how to understand how the plugins are used.
      1. 11:27-11:47 He creates new class ~HistoryNavigationPlugin~
      2. 11:47-11:59 and checks if this plugin is already in the Nautilus Plugins Manager (plugin list). Yes, it is already there.
5. 11:59-12:20 satisfied that he made a progress, he observes ~NautilusCommon~ package and notes that there is a category ~NautilusCommon-Plugin~.
6. 12:20-13:41 he wants to know where the History Navigator is implemented Q"Where is the History Navigator implemented?" Q1
   1. 12:20-13:41 he observes that it contains a string "History Navigator" He decides to search for this string using Finder tool. During the search process, which took some time (12:47-13:28), he explained that he wants to obtain all the History Navigator behavior and then he needs to define the History Navigator's position, because it is really specific one and it is not defined in among the valid positions. The result shows one method called ~NautilusUI>>buildNavigationList~.
7. 13:41-13:52 he browse the method and closes Finder and observes the method code of ~NautilusUI>>buildNavigationList~.  Q17
8. 13:52-19:41 as he sees in the code, that History Navigator communicates directly with ~NautilusUI~ object (there is a =self= reference), he wants to know if nautilus plugins have access to ~NautilusUI~ object. Q"Do Nautilus plugins have access to NautilusUI object?" Q28  C"It is an interesting case when the participant learns the Nautilus's structure."
   1. 13:52-14:11 goes back to Nautilus with ~HistoryNavigationPlugin~ and observes instance variables of from this class to all superclasses. Q"Is there any instance variable that holds ~NautilusUI~ object?" Q16 There is not such variable.
   2. 14:11-14:29 c"explain" then he explains what he want to do (because c"observer" observer asked him about his thought) and he says that he needs to know if Nautilus plugin holds ~NautilusUI~.
   3. 14:29-14:51 he observes the code of ~buildNavigationList~ and he check if all the used selectors are methods of ~NautilusUI~. He identify that they are. So he states that he needs access to UI.
   4. 14:51-16:35 He decides to see instances of a ~URLPlugin~ in order to see what it contains. Q27 He opens Workspace and writes =URLPlugin allInstances= and inspects it. He has three objects (because he has three Nautilus windows opened). He sees that it has ~model~ instance variable which keeps ~PackageTreeNautilus~ object. C"It was not apparent from the source code, that ~model~ keeps the ~PackageTreeNautilus~." And this object contains ~browsingHistory~ instance variable that keeps ~NavigationHistory~ object. Then he observes other parts of ~PackageTreeNautilus~, its ~announcer~, ~browsedEnvironment~, etc. C"I have an impression that portion of time was kind of unproductive; for example, it was not necessary to observe instance variables of ~NautilusAnnouncer~. It is likely a time that the participant was thinking what to do about it." As the list of instance variables of ~PackageTreeNautilus~ he at the time 16:27 find out, that there is also instance ~ui~ with ~PackageTreeNautilusUI~ object. Then he closes the inspector. C"He did not find what he wanted to find."
   5. 16:35-19:41 he browses ~URLPlugin~ and he decides to create message ~URLPlugin class>>new~ with =self halt=. Q14
      1. 17:05-17:32 Then he opens new Nautilus browser and a c"debugger" appears. He observes stack trace, particularly ~PackageTreeNautilus(Nautilus)>>initialize~ where he can see how plugins are instantiated. Then he observes other stack lines, but without clicking on any of them.
      2. 17:32-18:12 he then continue step-in seeing how the class is initialized from ~URLPlugin class>new~. In ~URLPlugin(AbstractNautilusPlugin)>>model:~ he finds out that it calls ~registerTo:~. He check what is ~model:~'s parameter value Q19, it is ~PackageTreeNautilus~ object. Inside the ~registerTo:~ he find out that it just register some announcements. C"Apparently he is not satisfied about it."
      3. 18:12-18:15 he goes back to ~PackageTreeNautilus(Nautilus)>>initialize~ stack line
      4. 18:15-18:28 and immediately decides to open another Nautilus. There is still the breakpoint, so he decides to write =self halfOnce= instead of =self halt= and proceeds the execution.
      5. 18:28-18:45 He searches for ~PackageTreeNautilus~, switches to hierarchy view and observes its methods. Then he finds out, that this is not the class he wants to see; he wants to see ~PackageTreeNautilusUI~. He closes the browser.
      6. 18:45-18:55 he goes back to the c"debugger" with ~PackageTreeNautilus(Nautilus)>>initialize~ stack line and decides to inspect the ~PackageTreeNautilus~ object. C"He could inspect it directly in the GT debugger, but I guess he have not used to it yet." and evaluates code =self ui= Q19. It is =nil=, so he then check if the ~ui~ instance variable is really =nil=. Yes, it is.
      7. 18:55-19:06 Then he wonders why it is =nil= Q"Why does the instance ~ui~ have the value ~nil~?" Q31 And he understands that the browser has not been created yet.
      8. 19:06-19:09 So he goes back to the c"debugger" and proceeds it.
      9. 19:09-19:18 back in the inspector with ~PackageTreeNautilus~ he executes again the =self ui= Q"What is the return value of ~ui~ method?" Q19 and finds that it is ~PackageTreeNautilusUI~ object. C"I think he does not understand well the class hierarchies of ~PackageTreeNautilus~ and ~PackageTreeNautilusUI~".
      10. 19:18-19:25 He decides to browse ~PackageTreeNautilus~ class looking for its class hierarchy Q17.
      11. 19:25-19:41 then he browses ~PackageTreeNautilusUI~ class looking for its class hierarchy Q8. Here he finally understands how he can access ~PackageTreeNautilusUI~ object from ~URLPlugin~ object.
9. 19:41-22:10 he is back in browser with ~NautilusUI>>buildNavigationList~ and he wants to know what happens when he removes (comments) the code responsible for creating History Navigator. Q"How can I remove the History Navigator from the ~NautilusUI~?" Q34
   1. 20:15-20:25 Then he opens new Nautilus and obtains ~MessageNotUnderstood~ exception. He observes the stack and ends in ~buildNavigationList~ method where he revelas one more line that he did not removed (commented). He understand that this is the issue. He closes the c"debugger".
   2. 20:25-20:37 goes to the browser with ~buildNavigationList~ and removes this forgotten line.
   3. 20:37-20:43 he opens new Nautilus and receives another ~MessageNotUnderstood~ exception. he observes the stack and sees that it expects a Morph, while he returns =nil= from the ~buildNavigationList~. He closes the c"debugger".
   4. 20:43-20:54 goes back to browser with ~buildNavigationList~ wondering what to do next.
   5. 20:54-21:05 then he opens again new Nautilus and observes the stack. Then he closes the c"debugger".
   6. 21:05-21:30 Q"Where is the ~buildNavigationList~ called?" Q29
      1. 21:05-21:12 he writes =self halt= into ~buildNavigationList~, because he want to prevent creating the History Navigator.
      2. 21:12-21:30 opens new Nautilus and a c"debugger" opens in the halt position. He goes to ~PackageTreeNautilusUI(NautilusUI)>>buildColumns:height:~ and removes (comment) code that calls ~buildNavigationList~.
   7. 21:30-22:01 then he want to remember this changed method ~buildColumns:height:~, opens Workspace, then he inspect ~thisContext~, inspects ~method~ instance variable and here he can copy string ~NautilusUI>>#buildColumns:height:~ C"Quite complicated, he could copy it from the top of the changed method." c"chatter" C"I think it could be useful to have a possibility to annotate a code, or any object. Maybe there could be a similar chatter use case in Rosario's session un unfamiliar code where she copied several methods to a Workspace." c"bookmark" He pastes it to the Workspace in order to see it and closes the inspector.
   8. 22:01-22:10 goes back to the c"debugger" and proceeds it expecting that there should not be any exception. He obtains a new Nautilus without the History Navigator. It is what he expected
10. 22:10-26:32 Now he want to achieve that ~buildNavigationList~ is called only when the plugin is created (selected). C"Interesting is, that he did not think of moving all the history navigation to the plugin." Q"How can I call the ~buildNavigationList~ after ~HistoryNavigationPlugin~ object creation or selection?" Q38 He cleans the space closing inspector with ~PackageTreeNautilus~ object, and searching for a c"debugger" with ~URLPlugin>>new~ plugin. He finds out, that he has already closed it.
    1. 22:38-22:45 he enables =haltOnce= from the World menu, and opens new Nautilus. It opens c"debugger" with the breakpoint at ~URLPlugin>>new~.
    2. 22:45-23:20 He observes the stack saying S"Here the plugin is created." and asking Q"What can I do with this [likely meaning ~URLPlugin~ object]?" Q26. He do several steps-over and ends in ~PackageTreeNautilus(Nautilus)>>initialize~. Then he closes the c"debugger".
    3. 23:20-23:58 goes to browser with ~URLPlugin~ class and observes its behavior of ~buildString~ and ~display~ methods.
    4. 23:58-24:17 <<t2link4>> goes to ~HistoryNavigationPlugin~ and decides to remove the class and make a new one as a copy of ~URLPlugin~; so the ~HistoryNavigationPlugin~ has all the needed methods. C"Actually he calls the new class ~HistoryNavigation~. I suppose he forgot the 'Plugin' part of name and it brings a confusion in [[p2link5][27:03]] minute." c"future-confusion"
    5. 24:17-24:39 he removes (comments) the source code of ~changed:~ and ~buildString~ method in ~HistoryNavigation~
    6. 24:39-24:49 then he observes ~display~ and ~registerTo:~. And says that now it is time to create the morph of History Navigator.
    7. 24:49-25:40 <<p2link6>> Q"Where is the code that creates morph of History Navigator located?" Q1 C"This is a recently navigated code, but he had to proceed several steps to get there. Maybe again, kind of annotation could help. More over there was an opened Nautilus with this code." c"snippet" C"Maybe Playground snippets could help."
       1. 24:49-25:16 goes to the Workspace with the string ~NautilusUI>>#buildColumns:height:~ wondering how he can browse it. He then inspect it and in the inspector he writes =self browse=. Then he closes the Inspector.
       2. 25:16-25:40 back in the nautilus with ~buildColumns:height:~, he selects text with ~buildNavigationList~ and browse it. Here he copies the object creation of ~DropListMorph~.
    8. 25:40-25:50 <<p2link7>> He goes to back to Nautilus with ~HistoryNavigation>>display~. C"He has about 12 existing windows but he is kind of disoriented; he knows that there is a browser with the code, but he do not know which one."
    9. 25:50-26:32 he pastes the code with ~DropListMorph~ creation to ~display~ method and asks Q"What will happen with this new code when I execute Nautilus?" Q42
       1. 25:54-26:20 he saves the image c"save", opens Nautilus Plugin Manager, removes ~URLPlugin~ and adds ~HistoryNavigation~ plugin. Then he closes the existing browser. C"I think there was no intention to close this browser. He will need it soon (in 26:40 minute)."
       2. 26:20-26:32 he opens new Nautilus and receives an exception ~MessageNotUnderstood~ c"debugger". He says that it make sense, because he defines some accessors for ~DropListMorph~ object that do not exists for ~HistoryNavigation~ plugin.
11. 26:32-38:16 c"revise-the-duration" C"Maybe we can split in two part: a) searching, b) implementing" he states that he cannot open a new browser until he does not repair the method ~display~. C"Actually he observes method ~buildNavigationList~, but I am pretty sure, that he does not know about it." Q"How can I pass (call) methods from ~HistoryNavigationPlugin~ to ~PackageTreeNautilusUI~?" Q28
    1. 26:40-27:49 Q"Where is my ~HistoryNavigationPlugin~ class displayed? In which browser?" Qx"Related to tool usage, not to task." c"lost-among-windows"
       1. 26:40-27:08 <<p2link5>> c"confusion" then he notices that this is not the code he wants to change and searches in other opened windows for the right one (but it is already closed). In the end he use an existing browser that does not show any code and search for ~HistoryNavigation~ class. Then he is likely confused that it is not called ~HistoryNavigationPlugin~ and closes the search dialog.
       2. 27:08-27:32 c"confusion" He searches again for the class ~display~ code among the opened windows. The he reveals an opened Nautilus Plugins Manager where he cannot see its plugin name. So he close it and opens a new one again. Here he can see his plugin ~HistoryNavigation~ and closes the window.
       3. 27:32-27:49 c"confusion" he again searches for ~HistoryNavigation~, and browses this class. Here he can see that the class is not called ~HistoryNavigationPlugin~ and renames it. C"We observed a confusion that happens because of two unwanted actions: a) the class was in the end called ~HistoryNavigation~ instead of ~HistoryNavigationPlugin~, b) he closed the browser with this class. So he searched for a class ~HistoryNavigationPlugin~ which did not existed for a while."
    2. 27:49-33:23 he browse to ~display~ method and puts =self halt=. and opens new Nautilus browser.
       1. 28:09-28:18 in c"debugger", he inspect ~HistoryNavigationPlugin~ and =self ui=, but he receives ~MessageNotUnderstood~ c"confusion". He does not understand why it is an exception. C"He inspects a wrong object, it should be ~PackageTreeNautilus~". He closes the debugger.
       2. 28:18-28:23 back in the previous c"debugger", he observes the evaluation part with =self ui= and one line above, he reads that he is inspecting ~HistoryNavigationPlugin~. He understands that this is a wrong object.
       3. 28:23-28:25 and search for another instance with ~PackageTreeNautilus~.
       4. 28:25-28:27 he writes =self model ui=, executes it, and receives =nil= object. c"confusion" this is neither expected, because he can see, that instance variable ~model~ has the ~PackageTreeNautilus~ object.
       5. 28:27-28:36 he does not understand why it is nil, but he believes that it is going to be set, and that he does not need it right now.
       6. 28:36-28:58 <<p2link21>> he says that he needs a new method in ~HistoryNavigationPlugin~, goes to the browser with this class, C"Again, he never know which window it is.", creates new empty method ~sendToUi:~ c"false-solution" c"false-solution"
       7. 28:58-29:09 c"lost-among-windows" C"then he again search his desired window for a while."
       8. 29:09-29:30 then he c"explain" explains what he is going to do and goes back to the browser with ~sendToUi:~.
       9. 29:30-30:06 c"implements" he implements body of ~sendToUi:~, where he changed input variable name from ~aSymbol~ to ~aBlock~.
          1. 29:54-30:06 He wants to know how ~Symbol>>value:~ is implemented. Q17. c"confirm-his-thoughts"
             1. 29:54-30:06 then he asks for implementors of ~value:~ Q12 receiving 87 results. Here he searches for ~Symbol~ and here he can see the method source code. He can see that his thoughts are right and closes the Implementors window.
       10. 30:06-30:19 he is back in the browser with ~sendToUi:~, wanting to close it, but the code is still not accepted, so he cancel the warning window and close the browser.
       11. 30:19-30:22 then he close another empty browser which is on top, and goes to the previous c"debugger" with ~display~ method.
       12. 30:22-30:37 he starts to change the code of ~display~ method and in that moment he finds out, that his implementation of ~sendToUi:~ has to do a slightly different work.
       13. 30:37-30:58 he search for the window with an ~HistoryNavigationPlugin~, for some reasons (likely it is the previously removed class) there is an ~AnObsoleteHistoryNavigationPlugin~ and when he clicks on button for displaying flat-view (instead of hierarchy view), he receives an exception. he closes it without reading. Then after some other clicks, the error is solved and he reaches the desired class. c"ide-error" c"navigation"
       14. 30:58-31:47 goes to ~sendToUi:~ and says that it has to return a block with the code he has written recently. He changes the code, observes it for a while and accepts it.
       15. 31:47-33:23 he goes back to the c"debugger" window with ~display~ and change its definition. As he has to repeat code =self sendToUi:= on 6 lines, he first copies them, but then he finds out, that there are likely parenthesis that he missed before, undo the editing and decides to write two more lines by hand. Then he pastes the code to the rest of lines, and accepts the code.
    3. 33:23-33:35 then he proceeds the c"debugger" and receives an ~MessageNotUnderstood~ exception. He can see that he has two debuggers (exceptions) and closes the first one (on the top) and goes to the second one. He closes that one too.
    4. 33:35-34:41 Q"Why it fails?" Qe8
       1. 33:35-33:44 he opens new Nautilus in order to check if the previous exceptions were accidental or there is a problem to fix. He proceeds the =self halt= and can see the same two exceptions.
       2. 33:44-34:41 He observes the stack with ~PluggableListMorph~, ~LazyListMorph~, then he switches to the other debugger and observes stack with ~DropListMorph~
          1. 34:27-34:30 he executes =self getIndexSelector= in order to see what object it returns Q19. He inspects the return value and receives a ~BlockClosure~. He says S"OK" and closes the inspector.
          2. 34:30-34:41 he states that it cannot be any block, but it has to be a selector. This is the answer why it fails.
    5. 34:41-34:53 c"debugger" he closes both debuggers understanding that the current solution is not satisfactory.
    6. 34:53-36:23 Q"How can I solve this problem?" Q38
       1. 34:53-35:05 c"lost-among-windows" he goes to browser with ~sendToUi:~ method and removes it.
       2. 35:05-35:16 Then he reverts ~display~ method to a version without ~sendToUi:~ method.
       3. 35:16-35:23 c"ascertain" Q"Does the opening Nautilus fail?" Q42 He opens a new Nautilus and receives a c"debugger".
       4. 35:23-35:36 Q"Why it fails?" Qe8 he reads the exception and observes the stack and states that S"I cannot do dispatch the clean way, because it [~DropListMorph~] uses reflection." He closes the c"debugger". c"false-assumption?" C"I have an impression, that he could use the first version of ~sendToUi:~ where he did not used block."
       5. 35:36-35:51 he observes ~display~ method in a browser. He decides to implement all accessors as methods of ~HistoryNavigationPlugin~ class that pass the call to =model ui= object. He first implements ~getHistoryList~.
       6. 35:51-35:54 c"ascertain" Q"Does my solution work?" Q44 and opens new Nautilus in order to see if it works. He receives a c"debugger".
       7. 35:54-36:23 Q"Why it fails?" Qe8 He can see that =self model ui= is still =nil= object. He states that he has a problem that S"the plugins are generated before UI. It did not happend before [while History Navigator was part of UI]."
    7. 36:23-38:04 Q"How can I solve this problem?" Q38
       1. 36:23-36:32 He wonders how it can be solved. He says that he has a few options while clicking on the stack with ~DropListMorph~ and ~HistoryNavigationPlugin~.
       2. 36:32-36:52 he goes to the browser with ~getHistoryList~ and says that he can do is lazy and c"change" changes the method. c"wrong-implementation".
       3. 36:52-37:01 he closes the old c"debugger" and opens new Nautilus Q"Does my solution work?" Q44 an exception appears. C"Because of the wrong implementation." He observes the ~HistoryNavigation>>getHistoryList~ in the c"debugger" and see the mistake. He closes the debugger.
       4. 37:01-37:17 he goes to the browser with ~getHistoryList~ and fixes it. c"fix"
       5. 37:17-37:21 opens new Nautilus Q"Does my solution work?" Q44 and receive another exception. C"It is another one, so his solution works. He just need to make the same way the rest of accessors."
       6. 37:21-37:39 he observes in the c"debugger" method ~DropListMorph>>getCurrentSelectionIndex~ Here he understands that default behavior returns 0 Q"What is the default behavior of ~getCurrentSelectionIndex~?" Q19
       7. 37:39-37:58 he goes to the browser with ~HistoryNavigationPlugin~ and implements ~currentHistoryIndex~, he copied this name from ~buildNavigationList~ right before.c"reuse" He reuses ~getHistoryList~ method.
       8. 37:58-38:04 he closes the c"debugger" and opens new Nautilus. Q"Does my solution work?" Q44 Yes, Nautilus is opened and History Navigator is displayed in the middle.
    8. 38:04-38:16 c"check" He makes a few clicks and he can see that History Navigator is not actualized. C"He is much more happy that he has made a progress." Q"What is the current state of my task?  Does everything work? What feature is missing?" Q44
12. 38:16-40:36 Q"Why the History Navigator is not updated?" Q34
    1. 38:16-39:12 he goes to browser with ~buildColumns:height:~ in order to see the commented code, then he jumps to ~buildNavigationList~ Q17
    2. 39:12-39:20 then he goes to ~plugins display~ method protocol, and then to ~builTopPlugins~. He did this navigation for checking purpose c"check". C"Apparently he do not know why it is not updated; likely he cannot believe it is not updated." Then he closes the browser.
    3. 39:20-39:32 Then he goes again to ~buildNavigationList~ method and likely thinking why it does not work; why it is not updated; what code he missed when he moved to the plugin. Then he sees that there is ~navigation~ variable that used to be set, but know it is commented.
    4. 39:32-39:39 he browses users of ~navigation~ instance variable, but he cannot see it in the list of existing instance variables. C"It is because ~navigation~ is local instance."  He closes the dialog with instance variables.
    5. 39:39-39:57 he checks again ~buildNavigationList~ method and now he can see that ~navigation~ is local variable. Then he explains he did not see that ~navigation~ is local variable and meanwhile he asks for ~buildNavigationList~ senders Q12.
    6. 39:57-40:36 he observes commented part of ~buildColumns:height:~ and asks Q"How the History Navigator is updated?" Q23 c"not-answered-question"
       1. 39:57-42:40 He says that he expected - browse again to ~buildNavigationList~ Q17 and search for an event registered on ~DropListMorph~, but he cannot see any. Then he recalls that he only reimplemented ~getHistoryList~ and ~currentHistoryIndex~. C"Apparently before, he was expecting an debugger on missing methods in ~HistoryNavigationPlugin~." c"false-assumption" c"answer"
       2. 40:36-40:39 The next command is ~setHistory:~
       3. 40:39-41:06 he goes to definition of ~setHistory:~ Q17 selecting ~--all--~ protocol and looking for it. Then he clicks for a few seconds an background of Pharo. C"In 41:06 He decides to ask for implementors." and without seeing the definition c"not-answered-question" he close the browser.
       4. 41:06-41:13 he browse again ~buildNavigationList~ Q17 selects ~setHistory:~ and asks for implementors Q"Who implements ~setHistory:~ method?" Q17. A browser with one implementation is opened.
       5. 41:13-41:23 he reads ~setHistory:~ method body
       6. 41:23-42:40 but he does not understand why there was not an error so far, using ~HistoryNavigationPlugin~ Q"Why the current solution does not fails for missing ~setHistory:~ in ~HistoryNavigationPlugin~?" Q30 c"not-answered-question"
          1. 41:23-41:29 he goes to the browser with ~HistoryNavigationPlugin~ and observes its current methods Q"What methods I have already implemented?" Q6.
          2. 41:29-41:50 he displays ~display~ method and still thinks why the method ~setHistory:~ is not called. C"Here he could check that it is really defined on ~DropListMorph~ usage." He says that the object ~HistoryNavigationPlugin~ neither understands ~setHistory:~, ~spaceFill~, nor ~wrapHistory:~ and he is surprised why they are not called Q"Why the methods ~setHistory:~, ~spaceFill~, and ~wrapHistory:~ are not called? Why do they not raise an error?" Qx"Same question as the parent one."
          3. 41:50-42:02 he goes to the browser with ~NautilusUI~ and observes ~setHistory:~ and ~wrapHistory:~ methods C"He could check that they really exists." Then he click back to ~setHistory:~, but apparently he is just thinks what to do next. c"some-more-clicks-around" Q17
          4. 42:02-42:07 and he goes back to the browser with ~display~ method and asks for ~wrapHistory:~ implementors Q"Who implements ~wrapHistory:~?" Q17
          5. 42:07-42:10 he receives one implementation of ~wrapHistory:~ and observes its source code. then he closes the browser.
          6. 42:10-42:17 he asks for implementors of ~spaceFill~ but there is not any. Q17
          7. 42:17-42:40 he states the current status of the implementation and finishes the session
13. 42:40 session finished
** Session S6 with P9, unfamiliar (Rubric in Nautilus)
   :PROPERTIES:
   :VideoFile: videos/S6-P9.m4v
   :FUEL: dflow/S6-P9.fuel
   :VIDEO-START-TIME: 2014-11-18T11:20:14.310965-03:00
   :Familiar: 0
   :SESSION-ID: S6
   :PARTICIPANT-ID: P9
   :END:      
*** Tool Usage
1. 00:00-00:33 c"rest-time"
2. 00:33-00:46 c"dynamic-tool"
3. 00:46-01:20 c"static-tool"
4. 01:20-01:43 c"example-tool"
5. 01:43-01:46 c"static-tool"
6. 01:46-01:54 c"example-tool"
7. 01:54-02:05 c"static-tool"
8. 02:05-02:12 c"example-tool"
9. 02:12-02:19 c"static-tool"
10. 02:19-02:32 c"example-tool"
11. 02:32-03:22 c"dynamic-tool"
12. 03:22-10:18 c"static-tool"
13. 10:18-11:40 c"testing-behavior"
14. 11:40-11:47 c"dynamic-tool"
15. 11:47-12:47 c"testing-behavior"
16. 12:47-15:53 c"static-tool"
17. 15:53-15:57 c"dynamic-tool"
18. 15:57-17:47 c"static-tool"
19. 17:47-18:17 c"dynamic-tool"
20. 18:17-18:42 c"static-tool"
21. 18:42-20:04 c"dynamic-tool"
22. 20:04-20:29 c"static-tool"
23. 20:29-20:42 c"dynamic-tool"
24. 20:42-20:49 c"static-tool"
25. 20:49-21:19 c"dynamic-tool"
26. 21:19-22:09 c"static-tool"
27. 22:09-22:22 c"dynamic-tool"
28. 22:22-22:40 c"static-tool"
29. 22:40-23:09 c"dynamic-tool"
30. 23:09-23:40 c"static-tool"
31. 23:40-24:09 c"dynamic-tool"
32. 24:09-24:37 c"static-tool"
33. 24:37-25:10 c"dynamic-tool"
34. 25:10-25:19 c"rest-time"
35. 25:19-26:11 c"static-tool"
36. 26:11-26:33 c"dynamic-tool"
37. 26:33-32:57 c"static-tool"
37. 32:57-33:16 c"dynamic-tool"
37. 33:16-35:28 c"static-tool"
38. 35:28-35:41 c"dynamic-tool"
39. 35:41-36:31 c"static-tool"
40. 36:31-37:02 c"dynamic-tool" if we distinguish between testing-behavior and dynamic tool, I have to revise those dynamic-tool between 12:53 and 37:02
41. 37:02-39:17 c"static-tool"
42. 39:17-39:25 c"testing-behavior"
43. 39:25-39:29 c"static-tool"
44. 39:29-40:15 c"dynamic-tool"
45. 40:15-41:27 c"static-tool"
*** Transcript
1. 00:00-00:27 he explains what he is doing to do; he says that he needs to recall how Rubric works Q"How does the Rubric framework works?" Qx"he asks later again, here he decides to check Nautilus first." I want to see an example.
2. 00:27-00:44 But before anything I want to see if I can execute the old (simple) System Browser (we call it here in transcript as "Simple Browser") calling =Browser open=. Q"Does the old browser work? How it is look like?" Qx"it is about learning environment" He opens Workspace, writes the code and executes it. A browser appears. He states that he has to use this one while changing Nautilus Browser. Closes Workspace. c"never-used" C"The basic browser is so simple, that he prefers to use Nautilus."
3. 00:44-00:47 He states that the simple browser is ugly and decides to use Nautilus (we call it here in transcript "Browser") while it is possible. He opens a browser.
4. 00:47-02:19 Q"How does Rubric works? Is there an exemplar for my needs?" Q4 c"answered" c"example"
   1. 00:47-01:14 he search for ~Rubric~ package and searches for examples that are in package ~Rubric-Editing-Code-Examples~, particularly in ~RubTextAreaExample~ class. He observes class comment that is full of methods to call. He does not execute any example.
   2. 01:14-01:42 he goes to ~Rubric-Editing-Widgets-Examples~ and particularly to ~RubWorkspaceExample~. He executes the example seeing a workspace. c"confidence" c"transition-2-to-confidence" He states S"OK. This is a workspace" He writes a wrong code into it in order to check how errors are displayed. A non existing method call is red. There is no any side-icon behavior that he has to implement in this task. Then he closes the workspace.
   3. 01:42-01:53 Then he goes to ~RubMethodEditingExample~ and executes it. But without exploring it, he closes it.
   4. 01:53-02:19 and says that he thinks that ~RubWorkspaceExample~ and ~RubMethodEditingExample~ are similar; ~RubMethodEditingExample~ contains on a top a part for choosing class and method, but he needs exactly only the editing part.
5. 02:19-03:40 <<t3link14>> Q"What class is responsible for the editing part of ~RubMethodEditingExample~?" Q1 c"not-answered"
   1. 02:19-02:33 <<t3link20>> then he executes again the example with ~RubMethodEditingExample~ and says that he wants to inspect the Morph with halos c"halos" c"halo" c"transition-11", but he does not remember how to trigger them. c"observer" He asks the observer if he knows. The observer shows the keyboard plus mouse combination. 
   2. 02:33-02:51 having halos c"halos", he searches how to inspect the morph of ~RubMethodEditingExample~. He finally finds it and inspect the morph.
   3. 02:51-03:21 <<t3link15>> in the c"inspector" c"runtime" c"transition-12" he has ~RubScrolledTextMorph~, he inspects it, because he wants only editing part of ~RubMethodEditingExample~. Q"What class is responsible for the editing part of ~RubMethodEditingExample~?" Qx"Same as parent question." He observes the instance variables and asks which class is responsible for the old editing part in Nautilus (the name is written in the assignment). He closes the inspector. c"miss-opportunity" C"He could look at Morph tab." c"not-answered"
   4. 03:21-03:40 he browses the ~TextMorphForEditView~ class using Spotlight and arrange two windows next too each other in order to see ~TextMorphForEditView~ and ~RubMethodEditingExample~ classes.
6. 03:40-07:29 <<t3link1>> Having both windows he thinks that he needs a Rubric class that has similar responsibility as ~TextMorphForEditView~. Q"Is there any class having the same responsibility as ~TextMorphForEditView~?" Q3 c"abandoned-question" C"He then changes focus to ~buildNavigationList~ method and how to implement in that method a Rubric class."
   1. 04:27-07:29 Q"What is the ~TextMorphForEditView~ class responsible for?" Q25
      1. 04:27-05:10 He observes what ~TextMorphForEditView~ is responsible for (observes its methods). Q6. C"He is quite silent." c"abandoned-question"
      2. 05:10-07:29 Q"Where does the Nautilus reference ~TextMorphForEditView~?" Q12 c"answered-question"
         1. 05:10-06:29 <<t3link5>> Q"Where is ~TextMorphForEditView~ referenced?" Q12 C"He cannot find in the context menu that function. After a while he asks the observer where the function is; he answers." c"answered-question"
         2. 06:29-06:48 The ~TextMorphForEditView~ is referenced only in ~PluggableTextMorph>>#textMorphClass~. He asks for senders of ~textMorphClass~. It is referenced in two places; one is ~AbstractNautilusUI~.
         3. 06:48-07:29 He observes ~AbstractNautilusUI>>#buildNewSourceTextArea~ C"Actually that method does not call the one of ~PluggableTextMorph~, but I suppose there is a reference to ~PluggableTextMorph~ class.", then he browse the method. He supposes that ~buildNewSourceTextArea~ is the one that initialize editing area of Nautilus. c"organize-window" Then he observes the method and says S"it [editing text area] has a lot of parameters."
7. 07:29-17:18 Q"What is the best way to proceed the task? in other words: Is this method the best place to change? How can I change it?" Q38
   1. 07:29-07:36 he goes to subclass of ~AbstractNautilusUI~ called ~NautilusUI~ and immediately back to ~AbstractNautilusUI~. Closes the browser.
   2. 07:36-09:08 then he browses the ~buildNewSourceTextArea~ again from Senders window. Q17
   3. 08:01-08:32 He observes methods of ~NautilusUI~ class. Q6 C"I think he browses occasional methods; they do not have a relation to ~TextMorphForEditView~ class." He does not want to do a bad changes; for that reason he observes the class. C"Maybe he looks for smell-code."
   4. 08:32-08:55 He browses ~AbstractNautilusUI~. Q6
   5. 08:55-09:08 He asks Q"What is the best way to proceed the task?" Qx"Equivalent to parent question." Than he states that he wants to change directly ~buildNewSourceTextArea~ method in a new subclass of ~NautilusUI~. c"decision"
   6. 09:08-12:14 <<t3link13>> Considering ~warningLimit~ behavior c"runtime" c"transition-7-to-runtime"
      1. 09:08-09:47 he opens a new browser with ~NautilusUI~ using Spotlight where he looks for ~warningLimit~ method that he sees in ~buildNewSourceTextArea~ method. Q17 C"I do not understand why he does not use function Implementors of."  C"I guess he is not satisfied with ~warningLimit~ source code."
      2. 09:47-10:18 He changes ~buildNewSourceTextArea~ method on the line with ~warningLimit~ to a number 1000. c"false-change" C"That line does not affect behavior the way he expects."
      3. 10:18-10:48 <<t3link16>> he goes to another browser and wants to check if this code change is visible. Q"How does this code change affects behavior? Is my change visible? Does it work?" Q42 c"false-assumption" C"I think he does not consider that the changed method is called on Nautilus initialization; when someone opens a new Nautilus window." He finds out that the change does not work.
      4. 10:48-12:14 Q"Why it does not work?" Q30 Then he find out, that there is another line of code in ~buildNewSourceTextArea~ that sets the ~warningLimit~. He goes to the previous browser and changes it.
         1. 11:01-11:08 Q"Is my change visible? Does it work?" Q42 It does not change behavior in opened browser. c"false-assumption"
         2. 11:08-12:14 Q"Why it does not work?"  he does not understand why his changes does not work. He decides to delete (comment) the whole ~buildNewSourceTextArea~ ensuring himself that the method is called. Q"Does the ~buildNewSourceTextArea~ method is called in that specific case?" Qx"Same as parent question."
            1. 11:26-11:38 he again clicks in the other browser on methods and cannot see a result.
            2. 11:38-11:46 he opens new browser and he receives a c"debugger" with ~MessageNotUnderstood~. He is satisfied that it is finally broken.
            3. 11:46-12:14 then he revert the commented method body ~buildNewSourceTextArea~ and opens new browser; here he can see that the behavior has changed as he wanted/expected.
   7. 12:14-12:47 he says S"that it is more or less clear that it [text editing area] is called from here ~buildNewSourceTextArea~" He summarizes what he knows about ~buildNewSourceTextArea~ method and what he will likely breaks after the change to Rubric. C"Anyway I have an impression that he could likely change the method without thinking too much, if not in the session (if not observed)."
   8. 12:47-13:46 Q"What does the ~buildNewSourceTextArea~ method returns?" Qe5
      1. 12:47-12:59 he looks for senders of ~buildNewSourceTextArea~ Q12 There two senders.
      2. 12:59-13:16 then he sees in ~buildCodePane~ method an object ~MultipleMethodsEditor~. he browses the ~buildCodePane~ in order to having it in a browser instead of senders window. He wants to keep ~buildCodePane~ method opened.
      3. 13:16-13:23 then he browses to ~MultipleMethodsEditor~ Q12
      4. 13:23-13:46 he finds out that it is a ~Morph~ and goes to previous browser with ~buildCodePane~. C"He is likely satisfied with this current knowledge."
   9. 13:46-13:59 he summarizes what he knows about ~buildNewSourceTextArea~ and about Rubric, he goes to the browser with ~RubSmalltalkMethodEditor~.
   10. 13:59-14:52 he observes ~RubSmalltalkMethodEditorModel~ class Q6 and considers the differences in API of ~RubSmalltalkMethodEditorModel~ and ~TextMorphForEditView~. Q35 He believes that they are inconsistent and it is something he has to deal with. He discusses possible solution.
   11. 14:52-17:18 goes to ~Rubric-Editing-Widgets-Examples~ package and ~RubMethodEditingExample~ and he decides to investigate how it works Q"How does ~RubMethodEditingExample~ work?" Q23
       1. 15:08-17:18 he observes the class Q6.
          1. 15:38-16:15 Q"What does the ~textModel~ method returns?" Qe5
             1. 15:38-15:57 in ~newScrolledText~ he finds =self textModel= and wants to know what it returns. Q19 He tries to execute =self textModel= but it does not work (it cannot work because self is class not an instance). A c"debugger" appears, he closes it.
             2. 15:57-16:15 he goes to the ~textModel~ method definition Q17 and here he can see that it returns ~RubSmalltalkMethodEditorModel~
          2. 16:15-16:30 he goes back to ~newScrolledText~ method and reads the rest of code. Q17
          3. 16:30-17:12 then he switches between ~textModel~, ~newScrolledText~, and ~open~ class in order to understand how it is initialized.
          4. 17:12-17:18 What he does not understand is how the ~editor~ (in ~open~ method) adds the complete window. Q23 C"The answer is in the same method." c"miss-opportunity"
8. 17:18-17:46 C"implement" he is back in ~buildNewSourceTextArea~, he comments its contents and adds ~RubSmalltalkMethodEditorModel~ class.
9. 17:46-17:57 clicks back to the browser with ~textModel~ and then he opens a new Nautilus. c"runtime" c"transition-7-to-runtime" He receives c"debugger" with ~MessageNotUnderstood~. He closes the c"debugger" saying S"This is expected error."
10. 17:57-18:03 <<t3link16>> c"ide-confusion" C"The task bar is apparently not useful, from time to time he tries to find a particular window here, but in a second he rather observes windows."
11. 18:03-18:17 he then executes the Nautilus again in order to see what method is missing Q32; it is ~vResizing:~. he closes the c"debugger".
12. 18:17-18:34 he can see that ~vResizing:~ is used in ~RubMethodEditingExample>>#open~. Q12 He goes to ~newScrolledText~ method and here he can see that he should call ~newScrolledText~.
13. 18:34-18:40 c"implement" goes to ~buildNewSourceTextArea~ and adds ~newScrolledText~ call.
14. 18:40-18:56 c"check" then he tries if it works and executes new Nautilus. c"runtime" c"transition-7-to-runtime" Yes, it works, there is c"debugger" with another error. He closes the debugger. Q"Does it solve the issue?" Q44
15. 18:56-19:15 but the Nautilus is opened and he says S"In theory I have here a Rubric editor". Then he closes the Nautilus with Rubric, but cannot because of ~getText~ error. He minimalise it.
16. 19:15-20:01 He observes ~newScrolledText~ method Q17 and immediately opens again new Nautilus. In c"debugger" he observes ~okToChange~ method where ~getText~ method is called Q29. The he minimalise the debugger and Nautilus.
17. 20:01-20:17 Then he revert ~buildNewSourceTextArea~ method, because he preferes to use Nautilus.
18. 20:17-26:20 <<t3link12>> Q"How can I obtain the saved text of the Rubric editing area?" Q28 c"false-assumption-removed" C"His solution is temporal, he implements ~getText~, but he should explore ~getTextSelector~ and ~setTextSelector~." C"I remove this false-assumption because it is correct decision. He could change the call from Nautilus or add this method."
    1. 20:17-21:06 <<t3link7>> he inspects =RubSmalltalkMethodEditorModel new= Q27 and also browses ~RubSmalltalkMethodEditorModel~ class. As he can see only one method called ~newScrolledText~, he decides to execute it in the inspector. He receives new inspector with ~RubScrolledTextMorph~. c"miss-opportunity" C"In that inspector, he could see ~getText~ method. He spends searching this information from 21:06-22:10, tests it from 22:10-22:20, implements from 22:20-24:24. He should use ~getTextFromModel~." and immediately closes it. And then inspects it again.
    2. 21:06-21:39 <<t3link8>> Here he can see ~getTextSelector~ instance variable with ~getText~ value. He explains what is his intention.
    3. 21:39-21:50 He browses the ~RubScrolledTextMorph~. He then observes if ~RubScrolledTextMorph~ has ~getText~ method; Q6 yes, it has.
    4. 21:50-22:10 <<t3link10>> He supposes that ~RubScrolledTextMorph~ does not have this method. Q"Does ~RubScrolledTextMorph~ have ~getText~ method?" Q6 c"miss-opportunity" c"false-assumption-marked-as-miss-opportunity" C"He recently read that there is an instance variable ~getTextSelector~." He can see that it has methods ~getTextFromModel~, ~getTextFromView~, and ~getTextSelector~. C"I think he does not know what to do with this information."
    5. 22:10-22:14 <<t3link9>> he goes to the inspector with ~RubSmalltalkMethodEditorModel~ and tries to execute =self getText= Q"What is the return value of =self getText=?" GQ"(19) What is the method return value at runtime?" and receives an empty string.
    6. 22:14-22:20 then he goes to the inspector with ~RubScrolledTextMorph~ and executes =self getText= c"confidence" c"transition-13" GQ"(6) Does the object understand a message?" and receives ~MessageNotUnderstood~ error. He closes the c"debugger".
    7. 22:20-24:24 <<t3link17>> in order to progress fast, he decides to implement ~getText~ method on ~RubScrolledTextMorph~ class; he can solve this later. c"temporal-solution" c"implement"
       1. 22:40-24:06 to implement this, he needs to access ~RubSmalltalkMethodEditorModel~ from ~RubScrolledTextMorph~. 
          1. 22:40-24:06 Q"How can I access ~RubSmalltalkMethodEditorModel~ from ~RubScrolledTextMorph~?" Q28 c"confidence"
             1. 22:40-22:52 he observes instance variables in the inspector and executes from the inspector =self scrollPane= Q19, he is not satisfied with the answer.
             2. 22:52-23:11 he explains what he is looking for
             3. 23:11-23:40 he searches for a method in ~RubScrolledTextMorph~ in the browser. Q5 He finds ~getTextFromModel~ method.
             4. 23:40-23:46 goes back to the inspector and executes =self getTextFromModel=. Q19 He receives an empty string.
             5. 23:46-24:01 Q26 He wants to be sure, that it is the same string as he can receive from the model. He goes to the inspector with ~RubSmalltalkMethodEditorModel~ and executes =self text: 'hola'= Then he executes =self getText= to be sure, that he receives 'hola'; yes he receives. 
             6. 24:01-24:06 <<t3link11>> he goes to the Inspector with ~RubScrolledTextMorph~ and executes again =self getTextFromModel=; Q19 he receives the string 'hola'.
       2. 24:06-24:24 Instead of implementing method ~getText~, he implements (in particular rewrites) method ~getTextFromModel~ that calls itself (infinite loop). c"error" c"implement"
    8. 24:24-24:37 he goes to the browser with ~buildNewSourceTextArea~ and reverts changes to the new source code with Rubric.
    9. 24:37-24:44 C"Observer asks him to save the image because he suspect that the image could fail." c"save" c"observer"
    10. 24:44-25:20 He tries to open new Nautilus Q42 and after a while, the image quits unexpectedly. He opens the image again.
    11. 25:20-25:59 He observes the changes in ~buildNewSourceTextArea~ Q17 and then in ~getTextFromModel~ Q17 Then he finds out the infinite loop. He implements ~getText~ and reverts ~getTextFromModel~ method.
    12. 25:59-26:12 He saves the image. c"save"
    13. 26:12-26:20 he opens new Nautilus and receives a new window. Q42
19. 26:20-26:36 c"runtime" c"transition-7" He makes a several clicks in order to see how it works. Q"How does the current changes behave?" Q42 He can see that editing area is not updated.
20. 26:36-27:06 <<t3link22>> He thinks why it is not updated Q"Why the editing area is not updated?" Q38, he was supposed that the view will be updated automatically. c"false-assumption"
    1. 26:46-27:06 Then he goes to ~buildNewSourceTextArea~ Q17 and says, that he should update it the same way as in the previous solution.
21. 27:06-41:18 <<t3link4>> Q"How can editing area text can be updated on method/class/package selection?" GQ"(23) How the behavior could be implemented?" c"unanswered-question"
    1. 27:06-27:28 he considers why it does not work and meanwhile he closes the Nautilus.
    2. 27:28-28:04 c"recall" He recalls the class name of the original editing area call ~TextMorphForEditView~. Q"Do I remember well the class name?" Qe9 c"unexpected-answer"
       1. 27:28-27:39 He wants to check if he is right; for that he wants to see ~textMorphClass~ method C"I do not understand why he simply does not ask for implements."
       2. 27:39-28:04 He goes to another opened browser with ~AbstractNautilusUI~ class. C"Here he uses task bar to find a particular window, but I consider it as well oriented among 19 windows." And looks for ~textMorphClass~ definition. Q17
    3. 28:04-28:12 Here he can see that it returns ~PluggableTextMorphWithLimits~. c"confused" C"I suppose he is confused. He does not remember that ~textMorphClass~ was defined on two classes and that time he ignored one." He first browse ~PluggableTextMorphWithLimits~ class but he closes it immediately.
    4. 28:12-32:10 Q"What is the method that updates editing area?" Q3 C"Answer to this question is not checked. It is an assumption."
       1. 28:12-28:25 he reverts changes in ~buildNewSourceTextArea~ to the orignal version.
       2. 28:25-28:29 he goes to the browser with ~textMorphClass~ method and browses ~PluggableTextMorphWithLimits~ class.
       3. 28:29-31:22 Q"How does ~PluggableTextMorphWithLimits~ work? In particular, How does it holds a text?" Q23 C"In the end, the upper question is more accurate and answered. That one is not important for the task. That one is considered unanswered." c"unanswered-question"
          1. 28:29-28:41 he observes method names of ~PluggableTextMorphWithLimits~ Q6 but he cannot see any interesting one. c"unsatisfied-answer" C"Maybe he could compare those methods with ones used in ~buildNewSourceTextArea~." c"miss-opportunity?"
          2. 28:41-28:45 he reads instance variable names of ~PluggableTextMorphWithLimits~. Q6 But he is neither satisfied. c"unsatisfied-answer"
          3. 28:45-29:02 he browses ~PluggableTextMorph~ class that is superclass of ~PluggableTextMorphWithLimits~ and observes its instance variables. Q6 C"The observer might disturb him from revealing the information. When the mouse hovers the ~textMorph~ instance, the observer asks him what he is looking for."
          4. 29:02-29:36 he browses methods of ~PluggableTextMorph~ and finds ~changeText:~ method that looks promising. c"miss-opportunity?" C"I think he could see ~setText:~ method that is used in ~changeText:~" Then he looks for other methods starting with ~text~ and finds ~textMorph:~, but he says that it is a ~Morph~, not a text and continues searching. Q6
          5. 29:36-29:51 then he observes method protocols and clicks on ~settings~, then on ~changeText:~ method and asks for senders. Q12 There are two senders, both on ~PluggableTextMorph~.
          6. 29:51-30:53 He observes both methods ~bsText~ and ~update:~ and finds =self getText=. Q17 Then he closes the Senders window.
          7. 30:53-31:22 he browses ~update:~ method again in the browser. Q17 then he clicks on ~updating~ method protocol and then he says S"I do not know how to change the text of text editing area."
       4. 31:22-31:45 <t3link6>> he is back in the browser with ~buildNewSourceTextArea~ and starts to observe how editing area morph is configured. Q17 He can see =aMorph ... text: #sourceCodeFrom:=.  c"information-he-missed-before"
       5. 31:45-31:48 he browses ~sourceCodeFrom:~ implementors using Spotlight and receives one implementor on ~AbstractNautilusUI~ class. Q17
       6. 31:48-32:00 he observes ~sourceCodeFrom:~ method and clicks on ~sourceCode~ that is called. Q17
       7. 32:00-32:10 he summarize that ~sourceCodeFrom:~ is the text he needs. He closes the browser with ~sourceCodeFrom:~. c"answer?"
    5. 32:10-34:27 <<t3link2>> then he thinks how he can setup ~RubScrolledTextMorph~ the same way using ~sourceCodeFrom:~. Q"What is the equivalent method in ~RubSmalltalkMethodEditorModel~ that can receive ~sourceCodeFrom:~ as an argument?" Q34 c"abandoned-question?"
       1. 32:10-32:31 he searches for something in task bar, then switches to the inspector with ~RubScrolledTextMorph~ saying S"this is the one, I think." Then he switch to the browser with this class. C"Likely too many windows, but he stills seems well oriented" c"many-windows"
       2. 32:31-32:57 he observes all its methods Q6 and stop at ~setText:~ method, he thinks that he could use that one. c"false-assumption?" C"I think he should use the next one called ~setTextSelector:~ c"miss-opportunity?" He closes the browser.
       3. 32:57-33:16 <<t3link23>>  c"confidence" c"transition-7" he decides try ~setText:~ out in the Inspector with ~RubScrolledTextMorph~. C"I think he should use ~changeText:~ that he observed before." He executes =self setText: 'asd'=, and then =self getText=. Q26 It returns 'hola'. c"unexpected-result" He ensures that it is still 'hola' executing =self getText= in the inspector with ~RubSmalltalkMethodEditorModel~. Yes, it returns 'hola'.
       4. 33:16-34:27 <<t3link3>> Q"Why the ~setText:~ does not work as expected?" GQ"(26) Why the entity behavior is behave differently?" c"unanswered-question?"
          1. 33:16-33:26 he says that S"It does not work as he expected." he searches for a second a browser with ~RubScrolledTextMorph~ c"many-windows", then he opens a new one.
          2. 33:26-33:58 he observes method protocols of ~RubScrolledTextMorph~, clicks on ~accessing text~. Then he selects ~setText:~ and after ~updateTextWith:~ that is called from the ~setText:~. Q17
          3. 33:58-34:09 he clicks on ~getTextFromModel~ and ~getTextFromView~ method Q17
          4. 34:09-34:27 then he says that S"I have an impression why it does not work. ... [I do not understand the idea]"
       5. 34:27-35:37 Q"Does the editing area shows ~RubSmalltalkMethodEditorModel~'s text?" Q26
          1. 34:27-34:39 goes to the browser with ~buildNewSourceTextArea~ and reverts method the way it uses Rubric.
          2. 34:39-35:26 c"implement" and changes it the way that it always should display 'hola' in the editing area.
          3. 35:26-35:31 c"save" he saves the image.
          4. 35:31-35:37 c"runtime" c"transition-7" then he opens new Nautilus and he can see, that there is 'hola' text.
    6. 35:37-37:00 now he decides to add a correct text of a source code in ~buildNewSourceTextArea~. Q"How can I add to ~RubSmalltalkMethodEditorModel~ a source code text?" Q28
       1. 35:42-35:52 he browses ~AbstractNautilusUI~ and thinks what method to use. 
       2. 35:52-35:55 then he goes back to ~buildNewSourceTextArea~ and observes the old code. Q"What is the method name used before?" Q17
       3. 35:55-36:03 he goes to ~sourceCodeFrom:~ C"I think it takes quite a time to find it in the list. Likely asking for implementors could be faster." c"ide-impropper-behavior" c"spotter"
       4. 36:03-36:19 he observes ~sourceCodeFrom:~ Q17
       5. 36:19-36:20 then he clicks on ~sourceCode~ Q17.
       6. 36:20-36:27 c"implements" then he changes ~buildNewSourceTextArea~ using ~sourceCode~ method.
       7. 36:27-36:49 c"runtime" c"transition-7" Q"Does the change work?" Q42 He opens new Nautilus and he can see that there is a code for class definition. Then he clicks on other packages, classes, and methods and he can see that the editing area is not updated.
          1. 36:41-36:49 Q"Why it does not work?" Qe8 He says S"I understand why it does not work."  He closes the Nautilus.
       8. 36:49-37:00 he opens again Nautilus and explains, that he has to use something that updates text of editing area whenever he clicks on an entity (package, class, ...). He closes the Nautilus.
    7. 37:00-37:50 he observes the original code of ~buildNewSourceTextArea~. Q17 he says that S"the progress is going the right way although it is not nice solution yet."
    8. 37:50-37:53 he asks for ~buildNewSourceTextArea~ senders. Q12 There are two in ~AbstractNautilusUI~ class.
    9. 37:53-38:08 he chooses ~lockTextArea~ and browses it. He can see that the editing area is not updated. He closes the browser.
    10. 38:08-41:18 he observes ~buildNewSourceTextArea~ and then he is interested if ~sourceCodeFrom:~ is useful also for updates. C"Interesting is, that he supposed that ~sourceCodeFrom:~ is only for the initialization; not for updating." Q"Is ~sourceCodeFrom:~ also used for editing area updates?" Q26
        1. 38:56-39:14 he reverts the ~buildNewSourceTextArea~ to the orignal code and change code =... text: #sourceCodeFrom: ...= to =... text: 'hola' ...=.
        2. 39:14-39:24 c"save" then he saves image and c"runtime" c"transition-7" opens the Nautilus and receives a c"debugger" with ~MessageNotUnderstood~. He states that it expects a selector, not a text. Closes the debugger.
        3. 39:24-39:27 and reverts the one line change.
        4. 39:27-39:35 then he decides to see where it is called and redo the =... text: 'hola' ...= changes, runs the Nautilus.
        5. 39:35-39:42 reverts the ~buildNewSourceTextArea~ to =... text: #sourceCodeFrom: ...=
        6. 39:42-40:11 and observes stack in the c"debugger". Q29 He can see that 'hola' is called from ~PluggableTextMorphWithLimits>>#getText~.
        7. 40:11-40:13 he browses the ~PluggableTextMorphWithLimits>>#getText~.
        8. 40:13-40:14 and closes the c"debugger".
        9. 40:14-40:59 he observes the ~getText~ method. Q"How does it work?" Q17
        10. 40:59-41:18 he goes back to ~buildNewSourceTextArea~
22. 41:18-41:55 then he prefers to finish the session, because he could observe it for a long time.
23. 41:55 session finished
** Session S15 with P9, familiar (LiveRobots, well sorted variables)
   :PROPERTIES:
   :VideoFile: videos/S15-P9.m4v
   :FUEL: dflow/S15-P9.fuel
   :VIDEO-START-TIME: 2014-12-01T11:45:14-03:00 
   :Familiar: 1
   :SESSION-ID: S15
   :PARTICIPANT-ID: P9
   :END:
*** Tool Usage
1. 00:00-00:21 c"rest-time"
2. 00:21-01:07 c"testing-behavior"
3. 01:07-02:37 c"static-tool"
4. 02:37-03:22 c"static-tool" Monticello Browser
5. 03:22-05:25 c"static-tool"
6. 05:25-05:39 c"dynamic-tool"
7. 05:39-10:12 c"static-tool"
8. 10:12-10:16 c"dynamic-tool"
9. 10:16-11:11 c"static-tool"
10. 11:11-11:31 c"dynamic-tool"
11. 11:31-12:55 c"static-tool" 
12. 12:55-12:57 c"dynamic-tool"
13. 12:57-14:45 c"static-tool" 
14. 14:45-14:50 c"dynamic-tool"
15. 14:50-14:58 c"static-tool" 
16. 14:58-19:26 c"static-tool" he writes test case the most of the time, and from time to time he executes it
17. 19:26-21:20 c"dynamic-tool"
18. 21:20-21:34 c"static-tool"
19. 21:34-22:05 c"dynamic-tool"
20. 22:05-25:59 c"static-tool"
21. 25:59-27:01 c"dynamic-tool"
22. 27:01-27:21 c"static-tool"
23. 27:21-27:28 c"dynamic-tool"
24. 27:28-29:09 c"static-tool"
25. 29:09-29:14 c"dynamic-tool"
26. 29:14-29:45 c"static-tool"
27. 29:45-30:34 c"dynamic-tool"
28. 30:34-30:43 c"static-tool"
29. 30:43-31:18 c"dynamic-tool"
30. 31:18-32:05 c"static-tool"
31. 32:05-32:11 c"dynamic-tool"
32. 32:11-32:34 c"static-tool"
33. 32:34-32:45 c"dynamic-tool"
34. 32:45-33:19 c"static-tool"
35. 33:19-34:33 c"testing-behavior"
36. 34:33-35:43 c"static-tool"
37. 35:43-36:09 c"dynamic-tool"
38. 36:09-36:51 c"static-tool"
39. 36:51-37:02 c"dynamic-tool"
40. 37:02-37:19 c"static-tool"
41. 37:19-37:24 c"dynamic-tool"
42. 37:24-38:32 c"static-tool"
43. 38:32-39:20 c"dynamic-tool"
44. 39:20-39:47 c"static-tool"
45. 39:47-40:15 c"dynamic-tool"
46. 40:15-41:48 c"static-tool"
47. 41:48-41:58 c"dynamic-tool"
48. 41:58-42:05 c"static-tool"
49. 42:05-42:09 c"dynamic-tool"
50. 42:09-42:35 c"static-tool"
51. 42:35-42:38 c"dynamic-tool"
52. 42:38-43:37 c"static-tool"
53. 43:37-44:05 c"dynamic-tool"
54. 44:05-45:36 c"static-tool"
55. 45:36-46:49 c"dynamic-tool"
*** Transcript
1. 00:00-01:02 c"explain" c"reproduce-bug" He sets the Pharo environment and his task. There is reported bug on an issue tracker. He copies the code and executes. The list of variables should be in the same order as it is in the code. This is the task for this session.
2. 01:02-01:34 c"browse" He opens browser and goes to ~LRPInterpreter~ class and its ~variablesInScopeOf:~ method. He says that he remember that this method is responsible for passing variables to the UI. Q17
3. 01:34-01:57 <<t4link1>> c"browse" Then he asks for ~variablesInScopeOf:~ senders where he can see how the variables are passed to the UI list. Q12 C"The original question could be 1, but he remembers ~variablesInScopeOf:~ method and it is more convenient to get information that way. Moreover it was just a check." He explains what is ~machine~ and how it works. He says that there is nothing to change, what is returned by ~variablesInScopeOf:~ is matter of change. c"false-assumption-incorrectly-identified" C"He identifies well where to do the changes." C"Incorrectly identified: Later in the session he adds method ~allVariables~ to ~LRPMachine~ class, because he needs to obtain variables of a particular machine and its parents. I think he could even return global variables."
4. 01:57-02:11 He says that changes could be big and he decides to write a test case to ensure that nothing will brake.
5. 02:11-03:18 He finds out that he forgot to download package with test cases; he downloads it. c"ide-bug" C"Monticello Browser with red widget." C"Is interesting, that he does not work with the latest code." C"Also it is interesting that he first wanted to create a new package, ignoring the fact there are already test cases. I suspect that it happens because of the session; like time pressure. Observer encouraged him to load the package."
6. 03:18-03:44 He saves the image c"save". He observes existing test cases and goes to ~LPRInterpretationTests~ Q6 and its protocol ~variable tests~.
7. 03:44-14:50 c"tdd" He creates a new test case ~testVariableOrder~ and he copies an existing test ~testVariableInterBlockAccess~ explaining that the test cases have a pattern he does not remember C"no ha traido". Then he puts the source code from the issue tracker. He can see that the source code contains apostrophe and it breaks the Smalltalk code he has. Moreover, the issue tracker code is large, so he decides to put it into a different method. c"implements-test-case"
   1. 04:51-05:24 he goes to ~LRPInterpretationTests~ class side and writes a method ~programTest~ that returns the issue tracker source code as string. c"implements"
   2. 05:24-05:39 He is surprised that there is not any syntax error. He cannot believe and decides to check it by invoking the method from Workspace. c"ide-untrusted" He can see that everything is fine and closes the Workspace. C"The explanation why he does not trust is that before the Smalltalk source was not colored properly. And it was not colored properly, because of resource consumption done by the LPR simulator."
   3. 05:39-06:31 c"implements" he is back in ~testVariableInterBlockAccess~ and changes the code. Then he recalls why the Smalltalk code coloring does not work properly (it is written one item above). He closes the LPR simulator and he can see that the code highlighting works properly now.
   4. 06:31-06:35 He closes another window of the LRP called "LRP Errors".
   5. 06:35-07:20 he reads the test case Q17 and checks what is necessary to change. He also clarify if he needs to use interpreter and states that yes, because the interpreter receives the variables.
   6. 07:20-07:32 He opens another browser where he opens again the ~variablesInScopeOf:~ method Q17 and goes to the previous browser.
   7. 07:32-08:03 he reads the rest of the test case ~testVariableOrder~ Q17 and starts to change the rest of the method. Then he remembers, that the ~machine~ is also available from ~scope~ and decides to see how he can access it. C"He is not sure about the machine accessibility from the scope."
   8. 08:03-09:11 Q"Is there other form to see [access, get] the ~machine~ from the ~testVariableOrder~?" Q28
      1. 08:03-08:21 he thinks for a while how to finish the test; likely how to access the ~machine~.
      2. 08:21-08:33 c"example" c"transition-6" he decides to see an example among other test cases in ~LRPInterpretationTests~. Q6 In ~testChainedSpawn~ he can see example =interpreter runningMachine=.
      3. 08:33-09:11 c"recalls" he recalls that there is a simple way how to obtain a ~machine~ while the machine is executed. He decides to go this direction.
         1. 08:39-09:11 c"implements" he change the program in ~programTest~. He adds at the end =(spawn follower moving)=.
   9. 09:11-10:01 c"change" then he goes back to ~testVariableOrder~ and finishes it.
   10. 10:01-10:12 c"check" He is not sure if he can send ~name~ method to the ~machine~ Q"Does ~machine~ understand ~name~ method?" Q6 He checks it in the other browser observing instance variables of ~LRPMachine~.
   11. 10:12-10:16 c"check" he executes the test case ~testVariableOrder~ and it is green. Qe7
   12. 10:16-10:29 he claims that he has a right machine and thanks to this he can obtain the variables. He browses the ~LRPInterpreter~ and search for the ~variablesInScopeOf:~ method. Q17
   13. 10:29-14:50 c"implements" in the ~testVariableOrder~ he makes changes, receiving the variables.
       1. 10:54-11:30 <<t4link31>> He does not remember the data structure of the received variables. c"miss-opportunity" C"The comment of ~variablesInScopeOf:~ method says that it is an association name -> value-holder." and he decides to use =self halt= in the test case to explore it. Q"What is the structure of the object that is returned by ~variablesInScopeOf:~?" Q27
          1. 11:10-11:30 he executes the test case and obtains a c"debugger". In the bottom inspector he observes that it is an array with associations. C"Exactly what the comment says." He closes the debugger.
       2. 11:30-12:38 he states that he is only interested in the variable order. He goes to ~programTest~ in order to know what is the right variable order. Q"What is the right variable order for the ~programTest~?" Qx"It is related to the task itself; it is the same as ask what plus method should return when executing 2+3."
          1. 11:50-12:38 c"implements" he opens new Workspace and observing the ~programTest~ he writes the order.
       3. 12:38-12:55 he goes back to ~testVariableOrder~, writes an assertion and
       4. 12:55-12:57 executes the test case. It is green. Qe7 c"green"
       5. 12:57-14:45 then he asserts the variable order for all 8 variables. C"He writes the code in a manual way, but he claims that later he wants to make it comprehensible."  C"During the copying from the Workspace he misses a one line." He also checks manually the order of variables in ~testVariableOrder~ method and in the workspace. He closes the workspace, accepts the code
       6. 14:45-14:50 check if the test case fails. Qe7 Yes, it fails. He closes the c"debugger".
8. 14:50-32:45 Q"How can I solve the task?" Qx"Too general question." Now he as the test case ready and he says that he can change ~variablesInScopeOf:~. He says that it is a bit more complex task. C"And for that reason he decided to write the test case ~testVariableOrder~."
   1. 15:02-15:33 I thinks that the variables are stored in a dictionary. Q"How are the variables stored?" Q23
      1. 15:15-15:33 c"check" He checks it browsing ~LRPScope~ and methods ~addVariable:with:~ and ~initialize~. Q6
   2. 15:33-16:35 He says that he has two options a) extend a dictionary the way, that it can returns variables in the order of arrive. b) C"He was thinking about this solution before." he knows that a parser keeps the variables in the order. So he can combine parser information (order) with scope information (values).
   3. 16:35-17:14 Q"Where the machine ~LRPMachine~ stores the variables?" Q23
      1. 16:35-17:14 he browses ~LRPMachine~ and search for method ~variables~. Q6 S"Those variables should be ordered." C"Again, he could know it using inspector/debugger."  c"miss-object-ide" c"ide-not-used"
   4. 17:14-17:53 He says that each machine has its variables, and it can also access variables of other machines. He needs something more intelligent (another method) to receive all variables he needs. He wants to create a method that can do the job. But then he believes there is something more; he is not sure what it is.
   5. 17:53-24:35 Q"Where are the external variables (not defined in the machine) stored?" Q23
      1. 17:53-18:48 He observes classes in ~LiveRobotics-Parser~ package, clicks on ~LRPNode~ and observes other classes. Q6
      2. 18:48-19:11 Then he clicks on ~LRPParser~ to see how it is parsed. Q"How is the source code parsed?" Q23 he looks at method ~parse:~, then ~variable~. C"Apparently seeing the parser code is not satisfactory." c"unanswered-question"
      3. 19:11-19:18 he observes the classes of ~LiveRobotics-Parser~ packages and then closes the browser. Q6
      4. 19:18-24:35 Tries to answer the question using c"debugger". c"runtime" c"transition-14"
         1. 19:18-20:48 he goes to the ~testVariableOrder~, writes =self halt= and executes the test case. Q27
            1. In the c"debugger" he inspects the ~interpeter~, 
            2. then =self runningMachine=, 
            3. then he checks =self variables= which returns empty collection. 
            4. Inside of ~LRPMachine~ object he observes ~scope~ instance variable and ~body~. In the body he can see that all the variables are defined outside of the machine.
         2. 20:48-21:19 he closes the ~LRPMachine~ inspector and observes the ~LRPInterpreter~ inspector. Q27
         3. 21:19-24:35 He states that the interpreter should keep the program, because the interpreter makes things with it. Q"How/Where does ~LRPInterpeter~ stores the program?" Q23
            1. 21:19-21:31 he opens the new browser and observes ~LRPInterpeter~ observing its instance variables. Q6 Here he can see ~runningAST~, this is the answer. C"Actually I do not understand why he did not look at the inspector. There is the list of variables. Likely because he do not get used of live-tools?"
            2. 21:31-21:50 he goes back to the inspector and writes =self runningAST= Q27 C"I do not really understand why he does not look at the instance variable list" c"ide-not-used" c"miss-opportunity" The answer is ~nil~.
            3. 21:50-24:35 he does not understand why ~runningAST~ is =nil=, he is sure that it should keep the program. Q"Why does the ~runningAST~ not keep the program in this case?" Q26 He closes the interpreter.
               1. 22:20-23:03 he observes in the browser ~LRPInterpeter~ and protocol ~interpeter~ with about 5 methods. Q6
               2. 23:03-24:35 Q"In which moment the ~runningAST~ is set?" Q23
                  1. 23:03-24:35 He asks for users of ~runningAST~; Q12 there are 3 methods. Then he thinks that it is a bug that the ~runningAST~ is not set and decides to fix it.
   6. 24:35-26:54 c"fix" Q"How can I fix the unset ~runningAST~ in that case?" Q38
      1. 24:35-25:07 he observes ~interpeter:withScope:~ method Q17 where he thinks to fix the missing ~runningAST~, but he realize that this is not a good place to put because of recursive behavior. C"He does not remember how that part exactly works, so he apparently thinks about other solution."
      2. 25:07-25:46 he goes back to ~testVariableOrder~ and decides to keep the parsed program in a variable ~parsedProgram~. After interpretting the program he explicitly sets the ~runningAST~ using ~runningAST:~ accessor.
      3. 25:46-25:59 he explains that he decided for the solution because he wants to make a progress now. c"desire-progress"
      4. 25:59-26:54 Q"Does my solution works?" Q42
         1. 25:59-26:54 he closes the old c"debugger" and executes the test case ~testVariableOrder~ again. Qe7
         2. 26:10-26:54 Then he checks in the inspector that ~runningAST~ is set. He also observes the ~runningAST~ structure. Q27 He can see array that contains ~LRPVariable~ objects, ~LRPMachine~ object, and others. He closes the inspector with ~runningAST~ array and the c"debugger". He keeps the ~LRPInterpeter~ inspector.
   7. 26:54-30:43 c"change" he arranges the ~LRPInterpeter~ inspector and the browser with ~variablesInScopeOf:~ and starts to write a change.
      1. 27:18-27:27 c"runtime" c"transition-15" Then he again inspects contents of ~runningAST~ to see how he can obtain the variables. Q27 C"He says that he does not like the current solution, he will fix it later" c"improve-later"
      2. 27:27-29:37 As he writes the code,
      3. 29:09-29:14 c"runtime" c"transition-15" he also check ~LRPVariable~ object asking Q"Does ~LRPVariable~ returns its name calling ~name~ method?" Q28 in the inspector.
      4. 29:14-29:37 writes a code
      5. 29:37-30:29 <<t3link32>> he already collects variables values and now he considers how to return an association variable name -> value. C"The answer is quite simple and written in the comment. I do not know why he needs to investigate it."  c"miss-opportunity". Q"How can I create an association the way it is returned by previous implementation of ~variablesInScopeOf:~?" Q38
         1. 29:37-29:53 he goes to the ~LRPInterpeter~ inspector and  c"runtime" c"transition-15" executes =self runningMachine= Q27 and he closes it immediately decided to get the information other way.
         2. 29:53-30:20 then he says that he is in the right direction and inspects =self runningMachine= again.  c"runtime" c"transition-15" Then he inspects =self scope vars associations=. He can see there are ~Association~ objects, but he does not know how to create one. C"Although the code is written in the comments."
         3. 30:20-30:29 c"confidence" c"transition-16" he decides to try write a code in new Workspace. He opens new Workspace and writes ='hola' -> 2=, Q27 prints it, and he is satisfied with the obtained knowledge.
      6. 30:29-30:43 then he finishes the code in ~variablesInScopeOf:~.
   8. 30:43-30:58 <<t4link2>> c"tdd" Q"Does my solution works?" Qe7 He saves the image and runs the ~testVariableOrder~ test case. It is red and he closes the c"debugger" immediately.
   9. 30:58-31:18 Q"Why the current solutions fails?" Qe8 He executes the test case again in order to see what happens c"debugger". He can see a problem in the ~variablesInScopeOf:~ and thinks that he does not use (access) the dictionary properly. c"false-assumption" C"I think the missing parenthesis is the problem." c"miss-opportunity" C"He could read better the error in the debugger."
   10. 31:18-32:09 Q"How can I fix the error?" Q38
       1. 31:18-31:54 Q"How does the dictionary works?" Q36 he closes the c"debugger" and goes to the browser with ~variablesInScopeOf:~. Then he opens new browser that he closes immediately. He remembers that he access the dictionary the same way in a test case. He searches for a one and finds ~testVariableSanity~. He does not understand why it does not work, because the code looks similar.
       2. 31:54-32:07 he adds parenthesis, but he is not sure if this is the problem S"por si a caso" and
       3. 32:07-32:09 executes the ~testVariableOrder~ again Qe7. He can see that this is the solution.
   11. 32:09-32:34 he closes the c"debugger". C"My question is why he has not tried to execute the rest of the test in order to see if it works?" and the browser with ~testVariableOrder~. c"ide-confusion" C"Here we can see that he searches for a window that does not exists. But he reveals fast the he closed a window he should not." he opens new browser with ~testVariableOrder~, removes =self halt= and
   12. 32:34-32:36 executes it again; it is green. Q"Does the test case ~testVariableOrder~ pass?" Qe7
   13. 32:36-32:45 Q"Does all the test cases of ~LRPInterpetationTests~ pass?". Qe7 All are green.
9. 32:45-34:30 Q"How can I reveal the potential bug that I am pretty sure about it?" Q34 He has an impression that there is a missing test that could reveal a bug of the current solution (or ensure that everything is fine). He has this impression because of previous programming sessions; he has seen it before when writing another test case.
   1. 32:45-33:16 He observes ~LRPCompareProgramTests~ and ~LRPInterpretationTests~ C"but it seams that he does not search for a something specific." Then he goes to ~testVariableOrder~ method, then to ~programTest~ and copies the contents.
   2. 33:16-34:30 c"runtime" c"transition-17" then he opens ~Live Robotics Application~ and pastes it there. He wants to add other variables and checks what happens. Q"Does my implementation works for other variables (use cases)?" Q44
      1. 33:29-34:30 Q"How does it works for variables inside of a machine?" Qx"The same question as above." He writes variables inside follower machine and he can see that they are not displayed in the variables list. He copies the changed code and closes the application.
10. 34:30-37:24 Q"How can I solve the bug?" Qe8
    1. 34:30-35:10 He changes the code of ~programTest~ method, he renames ~testVariableOrder~ to ~testVariableOrderOutsideMachine~ and to ~testVariableOrderInsideMachine~. Then he removes those new test cases and creates a copy ~testVariableOrderMachine~.
    2. 35:10-35:44 he change the ~testVariableOrderMachine~, he adds the new asserts and executes the test case; it is yellow.
    3. 35:44-36:08 he observes the code in c"debugger" Q"Why it fails?" Qe8. At first he is surprised that it receives only 8 variables instead of 10. But immediately he understands that this is the bug he revealed. He closes the c"debugger".
    4. 36:08-36:51 then he goes to the ~variablesInScopeOf:~ method and changes it.
    5. 36:51-37:02 Q"Does my solution fix the bug?" Qe7 He executes the ~testVariableOrderMachine~ and obtains a c"debugger" (red test case) with ~shouldNotImplement:~ message. He understands the error and closes the debugger.
    6. 37:02-37:19 He changes the ~variablesInScopeOf:~ and executes again the test case ~testVariableOrderMachine~.
    7. 37:19-37:24 Q"Does my solution fix the bug?" it is green. Qe7
11. 37:24-42:37 Q"Does the current solution works for nested machines too?" Q44 Then he goes back to ~variablesInScopeOf:~ and decides to do other test case called ~testVariableOrderNestedMachine~.
    1. 37:24-42:08 Here he states that he cannot use the trick with =interpreter runningMachine name= C"He spent some time to find out how to get the running machine. I believe that the is a bit dirty way he uses and it in the end he has to find the clean way." Q"What is the other way to get instance of a nested machine?" Q28
       1. 37:52-39:27 He opens other browser. He thinks that each machine should have an information about nested machines. Q"How can I access nested machines from a parent machine?" Qx"The same question as above" c"not-answered-question"
          1. 37:52-38:26 he observes the ~LRPMachine~ class. Q6 He can see method ~machines~ but he thinks that this is not the correct one. But in the end he decides to try it.
          2. 38:26-39:13 he goes to ~testVariableOrderNestedMachine~ method, writes =self halt=, c"runtime" c"transition-15" and executes the test case. Inside the c"debugger" he inspects ~interpeter~ and inspects =self runningMachine=. Q27 He closes several windows. Here he writes =self machines= and receives an empty collection. He understands that it does not serve to his needs.
          3. 39:13-39:27 He observes other methods of ~LRPMachine~. Q6
             1. 39:13-39:18 He tries ~containerMachine~ C"Apparently he search for any method that contains ~machine~ word. It would be useful having a method filter." c"spotter" It returns ~nil~. Q27
             2. 39:18-39:27 He searches for other methods.
       2. 39:27-42:08 then he sais S"I know what I can do." He decides that he will take the opportunity that he knows the program. S"I do not need a general solution." He says that he can make use of a ~state~. He changes ~testVariableOrderNestedMachine~.
          1. 40:41-41:07 Then he opens a new browser because he does not remember name of a state. Q"What is the name of the state I need in that case?" Qx"This is related to the task program, not to Pharo source code." He browses ~programTest~ and reveals that the state is called ~looking~ and machine ~lookalgo~. He writes the ~looking~ into the ~testVariableOrderNestedMachine~,
          2. 41:07-41:16 Then he needs to know how to access a machine Q"How can I obtain a machine inside of a state?" Q28
             1. 41:07-41:16 He browses a ~LRPState~ class and finds a ~machines~ method. Q6
          3. 41:16-41:49 he is back in the ~testVariableOrderNestedMachine~ and changes the method c"introduce-simple-bug". Then he look at a machine name he should obtain and changes an assertion. He also comments the rest of the test case, because he is not interested in it yet.
          4. 41:49-41:58 he executes the test case Q"Does the test pass?" Qe7 it is red. He obtains a c"debugger" with ~MessageNotUnderstood~.
             1. 41:50-41:58 Q"Why it fails?" Qe8 He can see the problem of missing parenthesis and closes the c"debugger".
          5. 41:58-42:05 he fix the test case ~testVariableOrderNestedMachine~ and
          6. 42:05-42:08 executes the test case again. Qe7 It is green.
    2. 42:08-42:35 Now he knows that he has a correct machine, he uncomments the last part of the test case ~testVariableOrderNestedMachine~, check the name of the additional variable that this machine has in ~programTest~, change the code, and
    3. 42:35-42:37 executes the test case. Q"Does the test case pass?" Qe7 It is yellow. He expected that result. He closes the c"debugger" without any close look.
12. 42:37-46:43 Q"How can I fix current solution the way it works also for nested machines?" Q38
    1. 42:37-43:21 He explains what he has to do.
    2. 43:21-44:05 Q"How can I access parent machine from a nested machine?" Q28 He supposes that each machine knows its parent machine.
       1. 43:21 C"In that moment the observer notices that he can finish whenever he wants."
       2. 43:21-44:05 c"runtime" c"transition-15" He writes a =self halt= in ~testVariableOrderNestedMachine~ and executes it. He obtains a c"debugger". He inspects nested ~machine~, then =self containerMachine= Q27 This is the method he needs. C"Before he tried this method in a wrong moment despite he apparently knows what is the purpose of this method." He closes the inspectors and the debugger.
    3. 44:05-45:23 he browses ~LRPMachine~ and creates a method ~allVariables~. c"implements"
    4. 45:23-45:36 he saves the image, changes ~variablesInScopeOf:~ method, and save the image again. c"implements"
    5. 45:36-46:39 he goes to the browser with ~testVariableOrderNestedMachine~ and executes the test case. Qe7 He still has a =self halt=, he closes the c"debugger", and removes the halt. He executes the test case again; it is red.
    6. 45:47-46:39 ~containerMachine~ can also return a nil and this is the bug. Qe8 C"He is surprised that it is a nil." But he also reveals other bug in his test case, where he asked other machine for its variables. He change this. He fix the ~allVariables~ and saves the image.
    7. 46:39-46:43 He executes the test case ~testVariableOrderNestedMachine~; Qe7 it is green.
13. 46:43-46:58 he saves the image and finishes the session.
** Session S16 with P10, familiar code (Roassal2 builder)
   :PROPERTIES:
   :VideoFile: videos/S16-P10.m4v
   :FUEL: dflow/S16-P10.fuel
   :VIDEO-START-TIME: 2014-11-18T17:03:03.221448-03:00
   :Familiar: 1
   :SESSION-ID: S16
   :PARTICIPANT-ID: P10
   :END:
*** Tool Usage
1. 00:00-00:51 c"rest-time"
2. 00:51-08:05 c"dynamic-tool"
3. 08:05-09:34 c"static-tool"
4. 09:34-11:09 c"dynamic-tool"
5. 11:09-11:13 c"static-tool"
6. 11:13-11:37 c"dynamic-tool"
7. 11:37-11:48 c"static-tool"
8. 11:48-11:50 c"dynamic-tool"
9. 11:50-13:15 c"static-tool"
10. 13:15-14:33 c"dynamic-tool"
11. 14:33-18:21 c"static-tool"
12. 18:21-18:26 c"dynamic-tool"
13. 18:26-18:51 c"static-tool"
14. 18:51-19:35 c"dynamic-tool"
15. 19:35-20:08 c"static-tool"
16. 20:08-20:29 c"dynamic-tool"
17. 20:29-20:40 c"static-tool"
18. 20:40-22:24 c"dynamic-tool"
19. 22:24-23:15 c"static-tool"
20. 23:15-24:59 c"dynamic-tool"
21. 24:59-25:56 c"static-tool"
22. 25:56-26:13 c"example-tool" Roassal Examples
23. 26:13-27:19 c"static-tool" Agilevisualization.org webpage
24. 27:19-27:53 c"dynamic-tool"
25. 27:53-28:23 c"static-tool"
26. 28:23-29:44 c"static-tool" Agilevisualization.org webpage
27. 29:44-33:05 c"dynamic-tool"
28. 33:05-33:36 c"static-tool"
29. 33:36-36:23 c"dynamic-tool"
30. 36:23-36:40 c"static-tool"
31. 36:40-36:45 c"dynamic-tool"
32. 36:45-36:53 c"static-tool"
33. 36:53-37:02 c"dynamic-tool"
34. 37:02-37:27 c"static-tool"
35. 37:27-39:18 c"dynamic-tool"
36. 39:18-39:41 c"static-tool"
37. 39:41-39:54 c"dynamic-tool"
38. 39:54-40:11 c"static-tool"
39. 40:11-45:26 c"dynamic-tool"
*** Transcript
1. 00:00-00:44 Basic image configuration
2. 00:44-03:27 he explains his task having a snippet in the Workspace. He made Kiviat builder for Roassal2. It highlights nodes by default when hovering. He want to disable it. And he wants to make polygons, not only lines that connects related nodes. And the last, it is should be available to set node colors.
3. 03:27-04:25 he decides to start first implementing polygons. He explains what he already tried; he is able to change line colors. And he has a global builder, but he is not sure if he uses it correctly.
4. 04:25-10:57 Q"How ~RTPolygon~ can be used?" Q26 c"unanswered-question"
   1. 04:25-04:38 He has another workspace with ~RTPolygon~ example, but he does not understand how he can use it. c"chatter" C"Here a quick question to P4 could answer it."
   2. 04:38-04:51 he inspects ~RTPolygon~ object Q27 in order to see that it is a Roassal shape, but he does not know how to add this shape into an element.
   3. 04:51-08:40 Q"How can I add ~RTPolygon~ shape into ~RTElement~ object?" Q26 c"unanswered-question"
      1. 04:51-05:20 he changes his snippet and executes it. Q27 There is a ~MessageNotUnderstood~ error c"debugger" C"he should use ~elementOn:~ instead of ~elementsOn:~." He fixes this error and executes it again.
      2. 05:20-06:17 and an ~RTView~ opens with a red screen saying ~MessageNotUnderstood~ error. C"He could open the error in debugger, but it is hardly accessible and developers do not know about this feature." Qe8 He states that this is where he is right now with his task and he does not know how to make a progress because of this error. c"chatter" C"This problem is too difficult for him, in the ideal scenario he could ask someone. Maybe sending an example, the window (or debugger) could help."
      3. 06:17-06:48 Q"Can I add another shape to the element?" Q26 He tries to use another shape in order to ensure if everything is correct; if it is the problem of the ~RTPolygon~ class. He changes code in the workspace using ~RTBox~ shape, executes the code, and sees that it works.
      4. 06:48-08:00 Back in the window with the broken ~RTView~ and he says the he does not like that kind of red (broken) window. He has never solved that kind of error. He reads the error stack in order to understand what is the error about. Q"Why does this error happen?" Qe8 But he says that he does not know what to do about it and closes the broken window.
      5. 08:00-08:40 he browses the ~RTPolygon~ class, reads the class comment, and states that this is what he really wants, but it does not work.
   4. 08:40-09:12 Q"How does the ~RTPolygon~ is tested?" Qe6 He says that there are no test cases for ~RTPolygon~ and browses ~RTShapeTest~ class. C"Strange that he does not try to search for ~RTPolygon~ references." He observes methods and closes the browser.
   5. 09:12-10:40 he browses the ~RTPolygon~ class and again observes the class comment with example usage. He again inspects ~RTPolygon~ object, but he is apparently only digging around because he does not have an idea how to make a progress. He also inspects ~RTBox~ objects and states that it is the same thing (also a shape object). Q"Are ~RTPolygon~ and ~RTBox~ the same shape objects?" Q35 He does not see any difference. He closes the inspectors.
   6. 10:40-10:57 He states that most of the time he goes to ask someone. c"chatter"
5. 10:57-11:43 c"observer" The observer proposes to choose another task because he cannot make a progress now. He likely agree and he repeats that in such moments he asks someone to help him. c"chatter"
6. 11:43-13:15 he browses ~RTPolygon~ class and observes its methods. Q6 He does not really want to give up on this task.
7. 13:15-13:56 He is back in the workspace with his example and thinks what to do next. He decides to make the highlighting optional. He close ~RTView~ window with the example.
8. 13:56-19:20 Q"How can we solve the optional highlighting?" Q38
   1. 13:56-14:31 Q"How do we define new API?" Qx"Same as parent question" he writes a new API method called ~highlightWhenOverNodes~ that he thinks to implement.
   2. 14:31-14:56 he browses ~RTKiviatBuilder~ and its method ~renderIt~. Q17 There is a line =self highlight= that he wants to make optional.
   3. 14:56-15:49 Q"What is the best practice to make this code optional?" Q35 He remember that he has already seen something like this in ~RTFlowLayout~.
      1. 15:12-15:49 he browses ~RTFlowLayout~ class and ~initialize~ method Q17, then ~alignBottom~. He sees that it is only a variable that have a symbol. He closes the browser.
   4. 15:49-16:49 c"implements" he adds an instance variable to ~RTKiviatBuilder~ called ~highlight~, initialize its value in ~initialize~ method.
   5. 16:49-17:33 C"He talks about something he misses in Pharo, but I do not understand."
   6. 17:33-18:17 c"implements" he goes to ~renderIn:~ method and changes its definition.
   7. 18:17-18:50 c"implements" he copies and pastes the method name ~highlightWhenOverNodes~ and creates it in ~RTKiviatBuilder~ class.
   8. 18:50-19:20 Q"Does my solution works?" Q44 He goes to the Workspace and test if the highlighting works. Yes, it works.
9. 19:20-21:02 Then he says that he wants to ask someone for reviewing the code before commit. c"chatter" C"Chatter may could help by sharing changed code that another one can file-in to its image or only see the changes and try it." He talks about the existing code and his previous changes.
10. 21:02-32:28 Q"What is the correct usage of =builder global= builder?" Q26 C"I way to answer this question is to search for examples, documentation."
    1. 21:19-21:16 he is in the workspace with his Kiviat example and discuss the written code that uses global builder.
    2. 21:16-21:58 He thinks about ~RTGlobalBuilder~ Q26 
       1. 21:16-21:43 he writes a code and inspects the global builder. Qe5 C"It could be question 27" C"Apparently he is not aware of a lot of Pharo features; e.g., he could select the portion of commented code and inspect it, instead of writing it again." He can see that it is a ~RTGlobalBuilder~ class c"idea" C"We could popup such information when hovering the code"
       2. 21:43-21:58 He browses method ~addProperty:~ Q17
    3. 21:58-23:14 c"observer" the observer asks why he is looking at the information and he starts to explain. He closes the inspector, browses ~RTKiviatBuilder~ and method ~renderIn:~, and explain the global builder on a peace of existing code.
    4. 23:14-25:54 he discuss about the global builder idea. The idea of the global builder is quite new, so he does not know yet how to use it and how the global builder should look like.
    5. 25:54-29:43 c"lost-among-windows" He search for an example. He browse web page http://agilevizualization.com. While browsing a documentation, he spot a shape builder that he discuss that is somehow complementar to the global builder. He shows an example in the workspace. He reads the documentation about the global builder.
    6. 29:43-30:19 back in the Pharo image and fixes its snippet according to the documentation. c"spotter" C"Maybe there could be a spotter popup that display relevant information. And those information can be browsed directly or the full Spotter UI could be opened." And he executes it.
    7. 30:19-30:21 there is an error ~MessageNotUnderstood~ he closes the c"debugger".
    8. 30:21-30:30 he changes the code and executes it again; another error ~MessageNotUnderstood~ appears. He closes the c"debugger".
    9. 30:30-30:43 he changes the code and executes it again; new RTView windows appears. Elements does not have expected colors. He closes the window.
    10. 30:43-30:58 and executes again the correct portion of the snippet. Now it is correct. He close the window.
    11. 30:58-32:28 he adds a new code to the snippet and executes (checks if it works correctly). He observes how it works and what are instance variable values.
11. 32:28-45:34 He is thinking what to do next but he does not know. The observer asks him what he is thinking about and he explains that each property is executed for each element. He is constructing a solution in his mind, no code change. He is moving the workspace around, then switch to the browser, back to the workspace. C"I think he simply does not know what to do next. He has not clear idea what he wants to achieve."
    1. 36:24-36:56 he goes to the browser ~RTKiviatBuilder~, then he goes back to the snippet,
    2. 36:56-37:02 inspects global builder Q27
    3. 37:02-37:27 and browse its class ~RTGlobalBuilder~. Q6
       1. 37:06-37:27 he browses ~executeOn:~ method Q17
    4. 37:27-38:07 then in the inspector observes ~kiviatNode~ instance variable. Q27 He is considering how to access information he needs.
    5. 38:07-39:05 he changes the snippet
    6. 39:05-39:14 back in the inspector with ~kiviatNode~ Q27, then in the snippet
    7. 39:14-39:41 then in the browser ~RTGlobalBuilder~ and method ~execute~ Q17
    8. 39:41-41:07 he is back in the snippet and executes it. There is an error about improper number of block arguments. He observes the stack.
       1. 41:07-41:19 he inspects ~elements~ variable and checks its contents. Q27 He closes the inspector.
       2. 41:19-45:34 he goes to ~execute~ Q31 on the stack and inspects ~#value~ symbol of =properties do: #value= C"I think he does not understand well this construct". He closes the inspector. He says he does not know what to do about this error. He does several observation (inspection) of values on the stack in order to understand why it fails.
12. 45:34-46:55 session finished.
** Session S17 with P11, familiar code (Big collections in GT-Inspector)
   :PROPERTIES:
   :VideoFile: videos/S17-P11.m4v
   :FUEL: dflow/S17-P11.fuel
   :VIDEO-START-TIME: 2014-11-04T14:38:02.94833-03:00
   :Familiar: 1
   :SESSION-ID: S17
   :PARTICIPANT-ID: P11
   :END:
*** Tool Usage
1. 00:00-00:53 c"rest-time"
2. 00:53-01:10 c"static-tool" he uses internet, looking at issue tracker
3. 01:10-19:35 c"dynamic-tool"
4. 19:35-20:00 c"static-tool"
5. 20:00-23:16 c"dynamic-tool"
6. 23:16-24:21 c"static-tool"
7. 24:21-24:46 c"dynamic-tool"
8. 24:46-24:56 c"static-tool"
9. 24:56-25:26 c"dynamic-tool" until now it was about observing behavior, how the behavior differs, etc.
10. 25:26-41:12 c"static-tool"
11. 41:12-41:37 c"dynamic-tool"
12. 41:37-44:47 c"dynamic-tool" uses profiler
13. 44:47-45:01 c"dynamic-tool"
14. 45:01-47:45 c"static-tool"
15. 47:45-48:23 c"dynamic-tool"
16. 48:23-49:30 c"dynamic-tool" uses profiler
17. 49:30-53:53 c"dynamic-tool"
18. 53:53-54:21 c"dynamic-tool" uses profiler
19. 54:21-54:41 c"dynamic-tool"
*** Transcript
1. 00:00-00:52 the observer explains the session procedure
2. 00:52-01:08 he shows the issue he wants to solve, he shows a bug report; there is a code snippet that reproduces the issue. He does not know much about the issue, neither about solution.
3. 01:08-01:35 c"confidence" he pastes the snippet into the Workspace and explains the issue. Qe8
4. 01:35-02:48 he changes the default Pharo inspector and c"debugger". c"typos" he tries if it works.
5. 02:48-05:49 Q"Does the default inspector displays all the inspected collection items?" Q34 c"answered-question"
   1. 02:48-05:08 he inspects the snippet in the standard inspector. The default inspector is even slower. He wants to know if the inspector displays whole array (2.000.000 items). It likely yes c"partially-answered-questions" He closes the inspector because it seems even slower then GT inspector.
   2. 05:08-05:49 he tries the snippet with less items 10000. There are not all the elements; there are skipped at the middle as he can see in the inspector. There are 1000 from the beginning and 1000 from the end. He closes the inspector.
6. 05:49-11:27 Q"How does the GT inspector behaves? How does the issue looks like?" Q34
   1. 05:49-06:07 he says that the original bug report is about opening the collection in the GT inspector. He writes the code and inspects the 10.000 collection in the GT inspector.
   2. 06:07-06:53 he tries the code with 100.000 items. He can see that displaying is fast, but clicking on each element is not fast. He closes the inspector.
   3. 06:53-09:25 Q"Does the GT inspector response faster or slower with different number of items?" Q34
      1. 06:53-07:20 he tries the code with 100 items and he can see that clicking on the items is still slow. He closes the inspector.
      2. 07:20-07:57 He inspects 100.000 items, then on 500.000 items. He observes that switching to the tab with items is slower with more items. Selecting items takes sometime.
      3. 07:57-08:28 he inspects with 1.000.000 items. c"save" To display the tab takes more time, clicking on the items also takes some time.
      4. 08:28-09:25 then with 5.000.000 items and observer the slowdown.
   4. 09:25-11:27 S"Let's try a different approach." He inspects 5000 items. The inspector always displays only first 50 elements. He wants to know what happens to the selection when all items are displayed. Q"How the GT inspector behaves when all items are displayed?" Q34 he observes a slowdown. Displaying the already displayed tab is fast. But item selection is slow.
7. 11:27-54:44 c"prototype" Q"Where does the problem come from?" Qe8 he wants to know why there are those slowdowns. c"answered-question"
   1. 11:27-23:18 <<t6link1>> Q"Does the slowdown comes from Glamour framework?" Q34 he explains that now he wants to identify (localize) the issue. During the explanation he inspects items, at the end of discussion he closes it. c"answered-question" C"He concludes that it does not come from the Glamour framework, but later observes this framework. So the conclusion is incorrect but apparently he is not affected by it." c"false-assumption?"
      1. 12:39-13:01 He executes a simple list presentation using Glamour (code comes from the bug report). For 10.000 items it is fast. He closes the window.
      2. 13:01-13:34 On 100.000 items, it is fast. On 1.000.000 it is slower.
      3. 13:34-14:17 For 5.000.000 items it takes a more time even while it displays only 50 items by default.
      4. 14:17-14:34 Q"How does the item selection looks like?" Q34 he observes it is fast. He closes the window.
      5. 14:34-15:34 Q"How does the item selection looks like when all items are displayed?" Q34 He inspects 10.000 items and displays them all. Observes that item selection is fast.
      6. 15:34-16:14 he discusses why it was slow in GT inspector while clicking on items. He closes the window.
      7. 16:14-21:35 Q"Does the slowdown occurs when using multiple presentations (transitions)?" Q34 c"answered-question"
         1. 16:14-19:05 He decides to make a more complex example. He opens new Workspace and writes code with multiple presentations. c"typos"
         2. 19:05-19:10 he executes the code. There ir an error ~MessageNotUnderstood~. He closes the c"debugger". Q"What is the error about?" Qe8
         3. 19:10-19:17 He fixes the typo. C"actually he fixes another bug."
         4. 19:17-19:22 and executes it again. There is still the same bug. He closes the c"debugger".
         5. 19:22-20:00 Q"What is the error about?" Qe8
            1. 19:22-19:35 he observes the code.
            2. 19:35-19:45 he browses ~GLMBrowser~ class. He closes the browser.
            3. 19:45-20:00 Q"How does ~GLMBrowser~ is used?" Q26
               1. 19:45-20:00 He searches for ~GLMBrowser~ references and observes the code. Q12
         6. 20:00-20:10 He finds out that he should use another class called ~GLMTabulator~. He fixes the code.
         7. 20:10-20:14 and executes it. There is another error ~NotFound~.
         8. 20:14-20:28 Q"What is the error about?" Qe8
            1. 20:14-20:23 he observes the code in the workspace and when realizes the problem he closes the c"debugger".
            2. 20:23-20:28 he fixes the code.
         9. 20:28-20:39 and executes it. It works. He observes how fast it is.
         10. 20:39-20:55 Q"What is the error about?" Qe8
             1. 20:39-20:49 There is another error ~MessageNotUnderstood~. He has not expected it. He closes the c"debugger" and the window.
             2. 20:49-20:55 he finds the problem in the Workspace and fixes it.
         11. 20:55-20:59 he executes the snippet and it works.
         12. 20:59-21:35 he observes how fast is clicking on each item; the item selection is fast. He concludes that the problem of slow click response comes from the GT inspector; it is not an issue of Glamour framework. He closes the window.
      8. 21:35-22:26 He executes example of 10.000 items in the GT inspector and observes the slow click response. He closes the window.
      9. 22:26-23:18 He concludes there are two problems: a) it is slow to open a big presentation in Glamour besides it shows only 50 items C"Has he check this before? No.", b) C"he does not explain the second problem."
   2. 23:18-50:57 Q"Which particular object or method is responsible for the slowdown?" Q23 C"Why does he not use profiler? He uses it later." c"answered-question"
      1. 23:18-41:12 c"static" Q"Is the slowdown inside the Glamour framework?" Q34 c"answered-question"
         1. 23:18-25:11 he browses ~GLMTreeMorphModel~ because he remember from another bug report that the problem could be here. There is a method called ~amountToFilterBy~ Q17 with a commented code. He changes the code. Then he executes the Glamorous example and shows that there is no a visual cue that there are more items that are not displayed. He reverts the method, closes the old view and executes the snippet. He explains there is a visual cue that there are more items to display.
         2. 25:11-25:16 he checks the bug report in the browser. Qe8 C"I do not know why."
         3. 25:16-25:27 He closes the view and even workspace with the snippet code. C"I have an impression that it was not intended. For that reason we want to keep all snippets that are searchable in spotter" c"spotter"
         4. 25:27-27:13 he browse ~roots~ method where ~amountToFilterBy~ is used and observes its behavior Q17. He discusses Glamour design; each presentation has renderer, renderer knows how to build a morph and gets data from the presentation.
         5. 27:13-27:59 He decides to browse a renderer: he browses ~Glamour-Morphic-Renderer~, then ~GLMMorphicListingRenderer~ class, and ~render:~ method. Q17
         6. 27:59-28:19 Q"Where the ~render:~ method builds a morph?" Q23,
            1. 27:59-28:19 he sees ~treeMorphFor:and:~ and browses it. Q17
         7. 28:19-29:20 he opens new browser with ~GLMListPresentation~; he observes its methods. Q6
            1. 29:06-29:20 Then he switch to ~GLMListingPresentation~ because there is the most of the logic. Q6 He explains the hierarchy logic.
         8. 29:20-29:36 Q"Is there method containing words filter, amount, or only?" Q5 He searches for a method containing "filter", "amount", or "only".
            1. 29:31-29:36 He spots ~showOnly:~ and displays it. Q17
         9. 29:36-29:46 Q"Where is the ~allowItemDragBlock~ instance variable used?" Q12 C"It took him a while to find out where it is located in the list." There are two users.
         10. 29:46-29:56 Q"Who calls the method ~amountToShow~?" There are two senders. Q12
         11. 29:56-30:18 he observes ~treeMorphFor:and:~ Q17 C"He recently 27:59 browsed this method; highlighting recently browsed/edited methods or classes could be useful." and ~toggleAmountToFilterBy~
         12. 30:18-30:20 Q"Who call the method ~toggleAmountToFilterBy~?" There are no senders. Q12
         13. 30:20-32:07 He browses the ~treeMorphFor:and:~ method. Q"What is happening in this ~treeMorphFor:and:~ method?" Q17
             1. 30:45-30:53 Q"How does definition of ~newTreeMorph~ look like (implementors)?" Q12. There are two implementors; one for table, one for listing.
             2. 30:53-30:57 Q"What does the definition of ~PaginatedMorphTreeMorph~ looks like?" Q17 He browses it but he is not interested about it for now. C"Some bookmark system could help. But I have an impression that people do not use the existing one in Nautilus."
             3. 30:57-31:14 He goes back to ~treeMorphFor:and:~ and observes the code part with ~amountToShow~ method. Q17
             4. 31:14-31:48 Q17 he goes to the browser with ~showOnly:~ but this is not the class he wants, he browses ~GLMTreeMorphModel~ in a new browser, then ~amountToFilterBy~ to see it returns =nil=. C"I have an impression that he browsed it because of the observer; in order to support narrative session." He minimizes the window.
             5. 31:48-32:07 he is back in the ~treeMorphFor:and:~ and says that the amount to show is specified on the morph and that ~GLMTreeMorphModel~ is a model that should be given to the morph.
         14. 32:07-32:21 goes to ~render:~ method and says that ~amountToFilterBy~ is completely ignored. Q17
         15. 32:21-32:31 He browses ~GLMTreeMorphModel~ and ~amountToFilterBy~ method. Q17
         16. 32:31-41:12 Q"Is it a good design decision in the ~root~ method?" GQ"(25) Is it a correct design decision?" C"Likely it is good design decision" c"answered-question"
             1. 32:31-33:03 he browse ~roots~. Q17 He remembers that this method was supposed to return only a portion of the items, but now it returns everything. He does not know if it is good or bad decision. In order to know it he decides to check ~PaginatedMorphTreeMorph~ to see what is going on.
             2. 33:03-33:22 he browses ~treeMorphFor:and:~ Q17 and
                1. 33:16-33:22 asks for implementors of ~chunkSize:~. Q12 There are three implementors. He closes it immediately.
             3. 33:22-33:48 S"We have a model" Q"Where does the model inherits from?" Q7
                1. 33:36-33:41 he goes to ~newTreeMorph~, then to ~render:~ and browses ~GLMTreeMorphModel~ Q17 and
                2. 33:41-33:48 he can see that it inherits from ~PaginatedMorphTreeModel~.
             4. 33:48-34:14 He browses ~PaginatedMorphTreeModel~ and observes its methods Q6; he concludes it has ~chunkSize:~ method. He closes the browser.
             5. 34:14-34:32 he browses ~treeMorphFor:and:~ and he browse again implementors of ~chunkSize:~ Q17 C"I have an impression that here some more compact view with method call edges could help. But in that case he maximize browsers, so it is not sure if he could use it. On other hand asking for implementors is cheap, maybe for that reason he did it several times."
             6. 34:32-41:12 Q"What is the difference between setting ~chunkSize:~ on ~PaginatedMorphTreeModel~ and ~PaginatedMorphTreeMorph~?" Q34 he observes those methods in the Implementors window. c"answered-question"
                1. 35:17-35:29 Q17 he browses ~setPageSize:~ definition. It is only setter. He closes the browser.
                2. 35:29-36:07 Q"Who does use (listen to) ~MorphTreeChangeRequest~ announcement?" He browses ~MorphTreeChangeRequest~ users; there 17 use cases. Q12 he observes first one but then says that he wants to know
                   1. who is registered to it. Q"Who is registered to ~MorphTreeChangeRequest~ announcement?". Qx"The same question as parent one, but more specific." c"inspector" C"We could make a tab where registrations and announcements are separated" The last method register it, it is class ~MorphTreeMorph~ and method ~registerRequestHandlers~.
                3. 36:07-36:16 Q"What does ~changeRequest:~ method looks like?" Q17 He can see that it only calls ~change:~ method. C"The method is very simple and only dispatches a change request." c"desperate" C"He is out of desperation for about a minute." He closes the window.
                4. 36:16-37:07 Q"What does the definition of ~MorphTreeChangeRequest>>change:~ looks like?" Q17 he browse the class, then the method.
                   1. 36:27-36:50 Q"What is the ~action~ responsible for?" GQ"(25) What is type responsible for?"
                      1. 36:36-36:50 he remembers that it was created by using ~chunkSize:~ method and for that reason he browses the class method ~chunkSize:~; Q17 here he can see that ~action~ is set to =#chunkSize:=.
                   2. 36:50-37:07 he summarizes the last observations in order to understand what is actually happening. c"inspector" C"Some kind of dynamic information could help. I think that tools are not ready to use dynamic information instead of static. In that case he could simply execute the snippet he has and then somehow browse the static information followed by the dynamic information. Or maybe the UML collaboration diagram could help. Why to construct all the collaboration when the information is there?" c"UML"
                5. 37:07-41:12 <<t6link2>> he browses ~chunkSize:~ implementors Q17. He concludes all the knowledge he has gained up to now. During the discussion he switches between all the used windows in order to support discussion. c"lost-among-windows". He concludes that the issue is likely not inside of Glamour framework, but could be in Morph framework. He decides to inspect this. He also thinks that the method ~amountToFilterBy~ is likely obsolete and could be removed.
      2. 41:12-50:57 Q"Is the slowdown inside the Morph framework?" Q34 c"answered-question"
         1. 41:14-41:47 Q"How could I test the possible slowdown in Morph?" GQ"(23) How the behavior could be tested/observed?" c"profiler" he decides to use profiler. He displays the issue code snippet and profiles it.
         2. 41:47-44:45 <<t6link1>> the profiler appears and he observes it. He observes the profiler tree, in particular methods ~rootNodes~ and ~roots~ and concludes that it is a bad design decision of ~PaginatedMorphTreeMorph~ class C"I have an impression that he lost about 40 minutes because he could start with profiling the snippet. But it is a good example that what takes a 40 minutes exploring static code, can be understood in 4 minutes using dynamic information." He closes the profiler.
         3. 44:45-50:57 Q"What is the difference between ~chunkSize:~ and ~pageSize:~?" Q34 C"He already before said that he has no idea what is the difference between them, this is the first time he decides to understand it, although he investigated code around all the time." c"abandoned-question" C"I think he does not really understand the difference, but he concludes that the slowdown comes from the Morph and he is not willing to digging into."
            1. 45:03-45:14 Q17 he browses implementors of ~chunkSize:~ (3 occurrences) and ~pageSize:~ (4 occurrences). He observes the ~pageSize:~
            2. 45:14-45:33 He browses ~PaginatedMorphTreeModel~ class and supposes that its ~chunkSize:~ and ~pageSize:~ methods should be a simple. Q17
            3. 45:33-45:40 Q"Who calles ~chunkSize~?" Q12 There are 5 senders but all of them from a different (irrelevant) framework. He closes the window.
            4. 45:40-46:05 Q"Who calles ~pageSize~?" Q12 There are 6 senders, all relevant to the framework. He observes ~MorphTreeChunkPager>>buildPanel~ method, but it is too long. He closes the window without a deep understanding of the code.
            5. 46:05-46:17 c"desperate" C"He likely does not know how to continue the investigation." He browses ~PaginatedMorphTreeMorph~ class and its ~pagerSize:~ method.
            6. 46:17-47:27 Q"What is the behavior of ~PaginatedMorphTreeMorph>>pageSize:~ method?" Q17 c"answered-question"
               1. 46:17-47:27 it uses ~pager~ instance variable and he asks Q"Who is the ~pager~?" Qe5 c"answered-question"
                  1. 46:17-46:31 Q"Who creates ~pager~?" Q21 He browses ~pager~ instance variable accessors. The ~pager~ is set by calling ~addNavigationPane:~.
                  2. 46:31-46:40 Q"Who sends ~addNavigationPane:~?" Q12 there are two: ~chunkSize:~ and ~pageSize:~ c"UML" C"What a code circle! Maybe some dynamic UML diagram could help to understand the logic. It could display object dependency, cooperation, etc."
                  3. 46:40-47:00 in the method ~chunkSize:~ he can see that the pager is ~MorphTreeChunkPager~ object, he browse the class Q6. c"unfamiliar-code" C"He says that this is unfamiliar code and he is lost." He observes its methods. He closes the browser.
                  4. 47:00-47:27 he observes both ~chunkSize:~ and ~pageSize:~ methods and he can see that both use a different object for the pager. 
            7. 47:27-48:18 <<t6link3>> Q"What will happen if we do not use ~chunkSize:~?" Q42 he can concludes that it spends a lot of time in ~chunkSize:~ and both (methods) seems to build the same think. c"false-assumption" C"The behavior changes if you do not use both of them" He decides to comment a line in ~treeMorphFor:and:~ that calls ~chunkSize:~. He has no idea if it solves anything. He executes the code snippet with and he see that it takes a lot of time, and moreover the pager in the bottom is more complicated. He closes the window.
               1. 48:18-49:29 he profiles the snippet. He observes that computing ~roots~ take the same time. He close the profiler. c"profiler"
               2. 49:29-49:34 he closes the example window.
               3. 49:34-50:57 <<t6link3>> he concludes that the slowdown on the large collections is a feature of ~PaginatedMorphTreeMorph~ and he does not want to change it C"because it is unfamiliar code and he could need more time to digging into." c"unfamiliar"
   3. 50:57-54:44 Q"Are my conclusions correct?" GQ"(43) Is my code/model/entity understanding correct?" He want to check if his conclusions are correct. c"confidence"
      1. 50:57-54:22 Q"How much time it takes to iterate over 2.000.000 items?" Q34 he tries a code snippet that is really fast (less then 0.5 secs). He want to be sure that it is not a compiler optimization and writes another code. He executes it, then profiles it. It is still fast, less then one second.
      2. 54:22-54:44 he concludes the issue. C"Actually I am not sure it he is right with his conclusion. Maybe he could use the chunkSize and pageSize values when asking for roots. I have no idea."
8. 54:44-54:53 session finished
** Session S7 with P11, unfamiliar code (Nautilus hover highlighting)
   :PROPERTIES:
   :VideoFile: videos/S7-P11.m4v
   :FUEL: dflow/S7-P11.fuel
   :VIDEO-START-TIME: 2014-11-05T11:46:03.801956-03:00
   :Familiar: 0
   :SESSION-ID: S7
   :PARTICIPANT-ID: P11
   :END:
*** Tool Usage
1. 00:00-00:32 c"rest-time"
2. 00:32-01:20 c"dynamic-tool"
3. 01:20-02:43 c"rest-time"
4. 02:43-03:10 c"dynamic-tool"
5. 03:10-05:40 c"static-tool"
6. 05:40-06:12 c"dynamic-tool"
7. 06:12-06:41 c"static-tool"
8. 06:41-07:14 c"dynamic-tool"
9. 07:14-07:39 c"static-tool"
10. 07:39-08:35 c"dynamic-tool"
11. 08:35-13:44 c"static-tool"
12. 13:44-13:59 c"dynamic-tool"
13. 13:59-15:52 c"static-tool"
14. 15:52-16:22 c"dynamic-tool"
13. 16:22-16:31 c"static-tool"
14. 16:31-16:59 c"testing-behavior"
15. 16:59-17:24 c"dynamic-tool"
16. 17:24-22:15 c"static-tool"
17. 22:15-22:32 c"dynamic-tool"
18. 22:32-24:10 c"static-tool"
19. 24:10-24:24 c"testing-behavior"
20. 24:24-25:26 c"static-tool"
21. 25:26-26:46 c"testing-behavior"
22. 26:46-30:42 c"static-tool"
23. 30:42-30:49 c"testing-behavior"
24. 30:49-31:04 c"static-tool"
25. 31:04-31:31 c"testing-behavior"
26. 31:31-33:52 c"static-tool"
27. 33:52-34:00 c"testing-behavior"
28. 34:00-34:30 c"static-tool"
29. 34:30-34:40 c"testing-behavior"
30. 34:40-36:47 c"static-tool"
31. 36:47-38:22 c"testing-behavior"
*** Transcript
1. 00:00-00:20 basic session preparation
2. 00:20-01:32 Q"What do I need to do?" Qx"Too generic question about the assignment."
   1. 00:25-01:14 Q"How does it works now in Nautilus?" Q25 S"OK. Let's see how does it works now in Nautilus." He opens Nautilus and selects a method to try the current functionality with CMD+click. c"observer" Observer says that there is also functionality for CMD+SHIFT+click. He tries both clicks on a method call and on a class reference. S"This not intuitive at all."
   2. 01:14-01:32 he reads the assignment. c"observer" Observer explains a bit the assignment.
3. 01:32-01:38 Q"What solution could be the best?" He thinks a bit, but then says S"Let's see first where it is implemented." Qx"He rather thinks about next procedure."
4. 01:38-08:36 Q"Where is this feature implemented? Where could I put the assignment logic?" Q3 c"answered-question"
   1. 01:38-02:08 he discusses a bit some possibilities like highlighting or context menu.
   2. 02:08-02:38 c"observer" The observer shows how it works in Eclipse using his computer.
   3. 02:38-02:46 <<t7link2>> c"halos" c"halo" Q"What object is responsible for the editing area?" Q1 He uses halo feature and he can see it is ~PluggableTextMorphWithLimits~. C"Halo feature could be perceived as a WhyLine project." c"answered-question"
   4. 02:46-03:35 He inspects the ~PluggableTextMorphWithLimits~ object. Q27
      1. 03:00-03:06 He checks the class hierarchy. Q7.
      2. 03:06-03:33 He browses it in Nautilus and observes methods. Q6.
      3. 03:33-03:35 Then he says that it is a very specific class, and browses its superclass. Q8
   5. 03:35-05:40 Q"Is there any method called mouse on ~PluggableTextMorphWithLimits~?" Q5
      1. 03:35-04:29 He browses ~PluggableTextMorph~. Q6 He observes method names and says that a search method should be called like mouse, or hover. c"unanswered-question" C"It was too complicated for him to understand mouse-something methods."
      2. 04:29-04:31 Q"Is there anything in the ~initialize~ method?" Q17 He observes the method, but nothing interesting.
      3. 04:31-05:29 Q"Is there any method containing word mouse or click?" Q5 As he cannot search easily in the Nautilus, he goes back into the inspector where he can search for method names. He writes click, no results, then writes mouse, there are three methods.
         1. 04:31-04:56 He observes ~mouseEnter:~, ~mouseLeave:~, Q17 but it is not interesting. C"I am curious why he does not have a look at ~mouseDownFromTextMorph:~, it sounds like interesting." c"miss-opportunity?"
         2. 04:56-05:04 He browses superclass ~Morph~ and search for methods mouse. Q6
            1. 04:56-05:04 There are several, he browses ~mouseDown:~. Q17
         3. 05:04-05:14 He asks for ~mouseDown:~ implementors. Q17 There are 59 implementors. He does not find anything interesting. He closes the window.
         4. 05:14-05:29 He browses ~mouseUp:~ method. Q17 But immediately says that this logic is too complicated. He closes the inspector.
      4. 05:29-05:40 He observes ~PluggableTextMorph>>initialize~. Q17 He tries again the functionality wondering where is the code that opens that window.
   6. 05:40-08:36 <<t7link2>> Q"Where is this Senders window opened when I click on the message send?" Q3 c"answered-question"
      1. 05:40-06:12 <<t7link1>> c"halos" Q"What object is responsible for the Sender window?" Q1 c"answered-question"
         1. 05:40-05:44 He wants to find the code where the window is opened and put a breakpoint here.
         2. 05:44-05:56 He uses halos and inspects the morph. Q27
         3. 05:56-06:12 He finds that it is a ~SpecWindow~ Q8
         4. 06:01-06:12 and that has as a model ~MorphicWindowAdapter~. Q27 He closes the inspector. 
      2. 06:12-06:33 Q5 He goes to the browser and search for a class that contains word Sender. There is no one. He closes the search dialog and the browser. C"He could also try to search for packages called Sender; there is a one called ~Spec-Tools-Senders~."
      3. 06:33-07:16 Q"What is the model of the window?" Q27 He inspects c"halos" c"halo" Senders window morph and follow the chain of ~model~ instance variables. He finds object of ~MessageBrowser~ class. C"Here we can see that connection between object and its class is missing. He could use the same inspector to follow navigation."
         1. He browses ~MessageBrowser~ class and closes the inspector.
      4. 07:16-07:25 He observes the ~MessageBrowser~. He checks class hierarchy; Q8 it is a ~ComposableModel~.
      5. 07:25-08:36 Q14
         1. He puts =self halt= c"halt" in the ~initialize~ method.
         2. 07:32-08:36 c"save" Then he press CMD+SHIFT+click and obtains a c"debugger" with the halt. He is satisfied. He observes the stack. Q31 He finds ~TextMethodLink>>actOnClick:for:in:editor:~ method that seems do the job. He says that this is the code that opens the Senders window. He browses the code.
5. 08:36-17:40 Q"How can I implement the context menu?" Q38 He closes the c"debugger" and says that now he needs to implement a context menu.
   1. 08:56-10:18 Q"Is there already any existing code that implements implementors-of and senders-of in menu?" Q4 He remembers that features like implementors-of, senders-of are already implemented in menus. He wants to find that code in order to reuse it.
      1. 09:00-09:20 Q17 He asks for implementors of ~sendersOf:~; there are two. He browses ~SmalltalkEditor~ class.
      2. 09:20-10:18 he searches for a menu on the class side of ~SmalltalkEditor~ Q5 C"I have an impression that he know a bit the logic. Maybe because he used the same for Glamour framework. I would not search for a menu on a class side. At least not that fast." There is a ~smalltalkEditorMenuOn:~ that he browses. Then he says that it is not the right one and browses ~smalltalkEditorShiftedMenuOn:~. He copies the method code and minimize the browser.
   2. 10:18-10:56 c"implements" he goes to the ~TextMethodLink~ and on the class side pastes the ~smalltalkEditorShiftedMenuOn:~ method and removes some redundant lines that does not belong to the assignment.
   3. 10:56-11:19 he goes to the instance side of ~TextMethodLink~, into method ~actOnClick:for:in:editor~. Q17 He sees that he needs only implementors-of, and senders-of. c"implements" He goes back to ~smalltalkEditorShiftedMenuOn:~ and cleans the code.
   4. 11:19-11:39 Q"What are other information (objects) that the ~smalltalkEditorShiftedMenuOn:~ method needs when called?" Q38 he observes what more is necessary for calling this method (and build the menu). He does not know who ~aBuilder~ is and decides to get it work (to call the method). C"I am a bit surprised that he decided to implement ~actOnClick:for:in:editor:~ method on ~TextMethodLink~. I think he could call it from the original object, but maybe it is just a proof of concept."
   5. 11:39-17:40 c"manipulation" Q"How can I open the context menu from here?" Q39
      1. 11:39-12:05 he goes to ~actOnClick:for:in:editor:~, comments to old code and writes a new code. He writes ~PragmaMenuBuilder~ c"implements"
      2. 12:05-12:24 Q4 he browses ~PragmaMenuBuilder~ and looks for a comment to see an use case. The comment provides an example that he copies.
      3. 12:24-13:44 c"implements" he pastes the example into the code. He needs a new pragma for the specific context menu. He goes to the ~smalltalkEditorShiftedMenuOn:~ c"miss-opportunity" C"He can see that the same example for ~PragmaMenuBuilder~ is in the method comment." he defines a new pragma called ~codeNavigationMenu~. He changes the ~actOnClick:for:in:editor~ method.
      4. 13:44-15:32 c"save" Q"Does the new code works?"
         1. 13:44-13:59 He executes the new code line but nothings happened. He fixes the code and then it works as expected. Q42
         2. 13:59-14:06 he improves the code a bit and tests it again. It works.
         3. 14:06-15:03 then he decides to open the menu if the shift is pressed. He changes the code accordingly. c"save"
         4. 15:03-15:32 then he thinks that it is better to open it on CMD+click. C"I have an impression that this method is called only when CMD is pressed. So it is not necessary to make any if-statement here."
      5. 15:32-15:49 Q"What is the equivalent method for CMD key as ~shiftPressed~ is for SHIFT key?" Q3
         1. 15:32-15:42 He browses implementors of ~shiftPressed~ Q17, browses ~HandMorph~ class but closes it because there is nothing he needs.
         2. 15:42-15:49 He browses ~UserInputEvent~ class Q6 and finds out ~commandKeyPressed~ method. C"Method ~shiftPressed~ should be called ~shiftKeyPressed~ as it is for others." c"api-confusion". He closes the browsers.
      6. 15:49-15:52 he edits the ~actOnClick:for:in:editor:~ method.
      7. 15:52-16:05 Q"Does the new code works?" Q42 It does not work. He writes the =self halt=.
      8. 16:05-17:40 Q"Why it does not work?" Qe8 He clicks and obtains a c"debugger".
         1. 16:05-16:21 He tests if =anEvent commandKeyPressed= is true. Q27 It is. In the same moment he finds that he has an error on the pasted code.
         2. 16:21-16:35 He fixes it, removes halt, but it still does not work.
         3. 16:35-17:25  Q"Why it does not work?" Qx"Same as parent question" He executes the line that build the context menu, it works. He puts =self halt= after the if-statement. It still does not work. He puts =self halt= at the beginning of the method. He obtains the c"debugger". He tests if =anEvent commandKeyPressed= is true. It is. He finds the problem.
         4. 17:25-17:40 he changes the code, removes the code, and tests it. It works; it opens the context menu
6. 17:40-25:50 c"static" Q"How can I implement the implementors-of and senders-of functionality? How can I access the functionality from here?" Q28
   1. 17:40-18:10 Q"What methods do I have to implement?" Q38 he changes the method ~actOnClick:for:in:editor:~ and he goes to ~smalltalkEditorShiftedMenuOn:~ and checks what methods he has to implement: there are two ~sendersOfIt~ and ~implementorsOfIt~.
   2. 18:10-19:18 Q"What objects do I need in order to call the old code?" Q40 he goes back to ~actOnClick:for:in:editor:~ and observes what objects he needs to call the old code. He needs =anEditor= and a selector. He pass those information as a model to the context menu. 
   3. 19:18-19:50 he goes to ~smalltalkEditorShiftedMenuOn:~ and renames it to ~codeNavigationMenuOn:~.
   4. 19:50-25:50 Q"How do I need to change this code the way it fits to the API (my design / setup decision)?" Q40
      1. 19:50-20:07 He observes the ~codeNavigationMenuOn:~ Q17 and decides to search for an example.
      2. 20:07-21:48 Q"Is there any exemplar for creating context menu?" Q4 c"abandoned-question"
         1. 20:07-20:16 he browses ~PragmaMenuBuilder~ class and looks for its comment. Q17
         2. 20:16-21:04 he browses ~MenuRegistrationExample~ class that is mentioned in the comment. He observes its methods that contains context menu examples. Q6
         3. 21:04-21:13 Q"Who is the ~aBuilder~ parameter variable?" Qe5
            1. 21:04-21:13 He asks for implementors of ~withSeparatorAfter~ Q17 C"I think he wants to know who is aBuilder. A typical approach how to access static information without static types."
         4. 21:13-21:23 He browses ~PragmaMenuAndShortcutRegistrationItem~ class. Q6 He can see ~action:~ method that likely satisfies his needs.
         5. 21:23-21:35 Q"Who access ~action~ instance variable?" Q12 ~action:~ only sets instance variable. He checks who access ~action~ instance variable. There is only accessor ~action~.
         6. 21:35-21:48 Q"Who calls ~action~ method?" Q12 c"abandoned-question" There is too many senders, he decides to use the method instead. He closes the browser and implementors window.
      3. 21:48-22:13 He changes the code of ~codeNavigationMenuOn:~ method. He puts =self halt= in order to find out how to finish the implementation.
      4. 22:13-22:30 he executes it and in the c"debugger" observes how to access model (editor and selector) Q27. He finds it and closes the debugger.
      5. 22:30-23:07 he changes to ~codeNavigationMenuOn:~ method.
      6. 23:07-25:50 Q"Are my changes correct?" Q42
         1. 23:07-23:20 he goes to the ~actOnClick:for:in:editor:~ method and checks if his changes in ~codeNavigationMenuOn:~ are correct. He concludes that yes. 
         2. 23:20-23:47 he cleans the code in ~actOnClick:for:in:editor:~ method.
         3. 23:47-24:07 he goes back to ~codeNavigationMenuOn:~ and check it again. He finds an error in the code and fixes it.
         4. 24:07-24:21 c"manipulation-minor" He checks if it is works. It works.
         5. 24:21-25:50 He cleans the method ~codeNavigationMenuOn:~ and categorize the methods. Cleans a bit the code and test it again. It works.
7. 25:50-26:48 c"observer" With a bit of observer's suggestions he finds out that there is still work to do. It does not work on for class references and there is no a visual clue.
8. 26:48-31:14 He decides to fix the class reference. Q"How can be the class reference handled?" Q38
   1. 26:48-27:18 he observes ~actOnClick:for:in:editor:~ on ~TextClassLink~. Q17 He understands what he has to change because the code looks similar to ~TextMethodLink~.
   2. 27:18-28:04 he copy pastes code and creates ~smalltalkEditorShiftedMenuOn:~ on ~TextClassLink~.
   3. 28:04-28:23 he renames pragma and method from ~codeNavigationMenuOn:~ into ~codeMethodNavigationMenu~.
   4. 28:23-29:07 he goes to ~TextClassLink~ and renames ~smalltalkEditorShiftedMenuOn:~ into ~codeClassNavigationMenuOn:~ and changes method.
   5. 29:07-29:39 he copy pastes ~actOnClick:for:in:editor:~ into ~TextClassLink~ and changes the code.
   6. 29:39-29:51 he executes it and receives an error. Qe8 He fixes it.
   7. 29:51-30:22 he changes code in ~codeClassNavigationMenuOn:~
   8. 30:22-30:42 He cleans the code.
   9. 30:42-30:51 c"manipulation-minor" he tests it. Q44 It works for methods but not for classes.
   10. 30:51-31:01 he supposes that it is a problem of pragma name. He goes to ~actOnClick:for:in:editor:~ menu and fixes the pragma in ~codeClassNavigationMenuOn:~.
   11. 31:01-31:14 he tests it. Q44 It works.
9. 31:14-37:25 he decides to fix the variable links. Q"How can be the variable links handled?" Q38
   1. 31:18-31:35 he checks the code of ~actOnClick:for:in:editor:~ for ~TextMethodLink~ and ~TextClassLink~ Q17 and decides to refactor code into the super class ~TextLink~.
   2. 31:35-34:48 Refactoring
      1. 31:35-33:22 he creates method ~menuFor:from:for:with:~
      2. 33:22-34:26 he changes ~actOnClick:for:in:editor:~ methods accordingly. C"While he copy-pastes the code he introduce an error."
      3. 34:26-34:38 he tests it and it does not work for class references.
      4. 34:38-34:48 he fix the code in ~actOnClick:for:in:editor:~ method.
   3. 34:48- he goes to ~TextVariableLink~ class and changes ~actOnClick:for:in:editor:~ method. He copy-pastes the ~codeClassNavigationMenuOn:~ and creates the same method for ~TextVariableLink~.
      1. 35:21-36:31 he forgot what is the model for the variable link. Qe5 He goes to the ~actOnClick:for:in:editor:~ method and fix the code. He changes pragma name, he classifies methods.
      2. 36:31-37:25 he tests all the functionality. It works. Q44
10. 37:25-38:22 he checks the created code and describes the solution, what he likes about it, what is not perfect.
11. 38:22-38:52 session finished. 
** Session S8 with P4, unfamiliar (Glamour responsive API)
   :PROPERTIES:
   :VideoFile: videos/S8-P4.m4v
   :FUEL: dflow/S8-P4.fuel
   :VIDEO-START-TIME: 2014-12-04T11:19:28-03:00
   :Familiar: 0
   :SESSION-ID: S8
   :PARTICIPANT-ID: P4
   :END:
*** Tool Usage
1. 00:00-00:12 c"rest-time"
2. 00:12-00:44 c"static-tool"
3. 00:44-01:09 c"example-tool"
4. 01:09-02:10 c"dynamic-tool"
5. 02:10-02:26 c"static-tool"
6. 02:26-08:46 c"dynamic-tool"
7. 08:46-08:55 c"static-tool"
8. 08:55-09:12 c"dynamic-tool"
9. 09:12-12:08 c"static-tool"
10. 12:08-14:46 c"dynamic-tool"
11. 14:46-20:04 c"static-tool"
12. 20:04-20:26 c"dynamic-tool"
13. 20:26-21:03 c"rest-time"
14. 21:03-27:29 c"dynamic-tool"
15. 27:29-34:12 c"static-tool"
16. 34:12-37:06 c"dynamic-tool"
17. 37:06-38:02 c"static-tool"
18. 38:02-38:24 c"dynamic-tool"
19. 38:24-38:37 c"static-tool"
20. 38:37-39:23 c"dynamic-tool"
21. 39:23-40:15 c"static-tool"
22. 40:15-42:00 c"dynamic-tool"
23. 42:00-43:07 c"static-tool"
24. 43:07-46:09 c"dynamic-tool"
25. 46:09-47:58 c"static-tool"
26. 47:58-48:44 c"dynamic-tool"
27. 48:44-48:59 c"static-tool"
28. 48:59-49:14 c"dynamic-tool"
29. 49:14-49:24 c"static-tool"
30. 49:24-49:33 c"dynamic-tool"
31. 49:33-49:37 c"static-tool"
32. 49:37-53:52 c"dynamic-tool"
33. 53:52-54:38 c"static-tool"
34. 54:38-55:15 c"dynamic-tool"
35. 55:15-55:20 c"static-tool"
36. 55:20-55:31 c"dynamic-tool"
37. 55:31-55:37 c"static-tool"
38. 55:37-55:50 c"dynamic-tool"
39. 55:50-55:52 c"static-tool"
40. 55:52-56:49 c"dynamic-tool"
41. 56:49-57:02 c"static-tool"
42. 57:02-57:32 c"dynamic-tool"
43. 57:32-57:39 c"static-tool"
44. 57:39-57:46 c"example-tool"
45. 57:46-58:16 c"static-tool"
46. 58:16-60:15 c"dynamic-tool"
47. 60:15-60:42 c"static-tool"
48. 60:42-62:07 c"dynamic-tool"
49. 62:07-64:13 c"static-tool"
50. 64:13-64:44 c"dynamic-tool"
*** Transcript
1. 00:00-00:07 he starts DFlow. c"test" C"He does not write test cases because he does not know how. The Glamour framework is complex and he does not understand the problem in detail. Moreover, he evitate to play with threads."
2. 00:07-01:33 c"example" Q"Is there any exemplar that illustrates the problem?" Q4 he wants to write or find an example that illustrates the problem.
   1. 00:17-00:35 he browses ~Glamour-Examples~ package and he can see ~GLMExamples~ class. Q6
   2. 00:35-00:44 Q"Is there any example browser for Glamour examples? How can I open it?" Qx"(4) parent question" he says that there should be an example browser, but he does not know how to open it.
      1. 00:35-00:43 He observes a class side and class comments of ~GLMExamples~, ~GLMBasicExamples~, then ~GLMExamplesBrowser~. Q6
      2. 00:43-00:44 He finds the answer in the class comment of the last one. He executes the code and obtains a window with Glamour examples.
   3. 00:44-01:07 Q"Is there any example with list widget?" Qx"(4) parent question" He observes the examples and searches for an example with list; he expects that this example takes time. He finds it and copies it.
   4. 01:07-01:33 he pastes it to Workspace, and inspects it. He clicks on the all tabs, some of them takes time to compute, some of them even produce an error (c"debugger").
3. 01:33-02:40 c"prototype" Q"How can I inspect the ~finder~?" Q27 c"abandoned-question"
   1. 01:33-01:56 He says S"I do not know. What should I do?" He wants to have the builder in GT inspector. C"Actually I do not understand what he wants, because he has already inspected ~finder~." He writes =finder openOn: ...=, first for =42=, but it does not work, but immediately fixes it and writes =$a=. He closes the browser.
   2. 01:56-01:59 Q"Who implements ~openOn:~ message?" Q17 He browses implementors of ~openOn:~ C"I have an impression that he wants to see source code. Why does he not browse ~finder~?" He closes the Implementors window without deep observation.
   3. 01:59-02:06 Q"Who implements ~buildOn:~ method?" Q17 He asks who implements ~buildOn:~ method, there is only ~PPExpressionParser~ class. He close the browser.
   4. 02:06-02:27 Q"Who implements ~openOn:~ message?" Q17 He again observes ~openOn:~ implementors. He closes it.
   5. 02:27-02:40 He executes the script and observes inspected ~GLMSystemWindow~. Q27 He does not find anything interesting.
   6. 02:40-03:53 Q"How can I simplify the example code that fits my needs?" Q34 He decides to clean (simplify) the example script.
      1. 02:40-03:21 As he reads the code, he understands a bit more how it works. He executes it first with =finder openOn: $a=, then =finder openOn. $z=. Q"How does the exemplar works for different inputs?" Q34
      2. 03:21-03:35 He removes some lines of the exemplar and executes it. Q"Does it still works the way I need?" Q42 He closes the window.
      3. 03:35-03:53 He removes other parts of the code. Now he has about 6 lines of code instead of about 15. He executes it and seems to work as expected. Q42
      4. 03:53-04:14 he changes the code the way he can uses number instead of characters as the input. He also add factorial computation in order to obtain something that takes time to compute.
         1. 04:14-04:27 He executes it, clicks on a number =362880= and he is surprised that it takes so much time. He interrupts it and closes the c"debugger".
         2. 04:27-04:41 He reveals that this is exactly the code that illustrates the problem.
4. 04:41-08:12 c"prototype" C"Actually whole session is based on prototyping." Q"How can I solve the problem?" Q38
   1. 04:41-06:19 Q34
      1. 04:41-05:03 he observes the example code Q17 and
      2. after while he put an if-statement inside, he says S"I do it manually." in order to find out how to fix it.
      3. He executes it and observes how it works.
      4. Then he tries the exemplar with different if-statement.
   2. 06:19-07:41 he thinks about a new API, he writes new message ~if:display:~ in the exemplar. He copies the code into another Workspace in order to have the original working exemplar.
   3. 07:41-07:44 Q"Does the code works?" Q42 He executes the original code in order to check if it still works. It works.
   4. 07:44-08:12 c"observer" Observer asks him what he actually do. He says that the current proposal with ~if:display:~ is reasonable. C"I have an impression that he thinks of an API that is similar to Roassal2 framework - his main project. But I think this is not a good idea."
5. 08:12-21:38 Q"How can I implement the ~if:display:~ idea?" Q38 He implements the idea.
   1. 08:12-08:38 He decides to try this idea. He closes the old windows.
   2. 08:38-15:55 Q"Where I should implement the method ~if:display:~?" Q38
      1. 08:38-09:10 Q"Who implements ~display:~ method?" Q17
         1. 08:46-08:50 he asks for implementors of ~display:~ method; there are 3 implementors.
         2. 08:59-09:10 In order to ensure what implementor is the correct one Qe4,
            1. 08:59-09:10 he puts =a inspect= into the code. He expects it is a ~GLMPresentation~ Q"Who is ~a~ object?" Qe5 He executes the code. He can see that it is ~GLMCompositePresentation~ class.
      2. 09:10-09:22 Q"What is the return value of ~list~ method?" Qe5
         1. 09:10-09:22 He browses ~GLMCompositePresentation~ class and ~list~ method. Q17 It returns ~GLMListPresentation~.
      3. 09:22-09:30 He browses ~GLMListPresentation~ and he apparently has something in mind, because he makes a sound and observes class hierarchy. Q8
      4. 09:30-11:32 Q"Is there already something like ~if:display:~ method that I want to implement?" Q4 He says that maybe the problem is already solved, but he does not finish the idea.
         1. 09:41-10:11 Q"What is ~tagsFilter:~ method about?" Q17 c"abandoned-question" S"I have no idea." It is only setter. Then he thinks, S"no this is not what I want, I do no want to remove any element from the list."
         2. 10:11-11:32 Q6 he observes other methods of the ~GLMListPresentation~ class.
            1. 10:11-10:41 As he observes the messages he can see that some of them set element color and it is something he could use later.
            2. 10:41-11:32 he observes the methods. He looks for methods like ~condition~. Q5 He goes to super class ~GLMFormatedPresentation~. There are just a few methods. He goes to ~GLMPresentation~
      5. 11:32-11:40 He says that he does not have an idea where to put the ~if:display:~ method. He decides to put it in ~GLMListPresentation~ class.
      6. 11:40-15:55 Q"Is the ~GLMListPresentation~ class the right one where to implement ~if:display:~?" Q38
         1. 11:40-12:01 he creates empty ~if:display:~
         2. 12:01-14:25 he says that now he will have two displays and he asks Q"Does Glamour work with two displays?" Q34
            1. 12:01-13:01 He writes the exemplar code with two displays and apparently it does not work. He thinks that the second call takes precedence.
            2. 13:01-13:21 he switches the ~display:~ calls in order to check his thoughts. But it does not work as expected. S"That is strange. I do not know how the thing works."
            3. 13:21-13:25 He browse ~display:~ message using Implementors window Q"Who implements ~display:~?" Q17.
            4. 13:25-13:36 It call ~presentation:~ he asks for its implementation Q17 using Implementors. The method are only setters. He closes all the implementors windows.
            5. 13:36-14:25 Q"Why does it ignore the second ~display:~ call?" Q30 He removes the first call that was visible in both executions and as he tries to accept the code, he finds the issue: wrongly nested block-parenthesis. He tests it and it now works as expected. He concludes that he can have only one display. 
         3. 14:25-14:45 he thinks that now he will need two displays.
         4. 14:45-15:55 He browses ~display:~ method he thinks that he will need something like ~addTransformation:~ method. He says S"Now it is getting complex. ... My feelings are that if I try to change the ~transformation~ in ~GLMPresentation~, it will be a big mess." He thinks how to solve it.
   3. 15:55-17:30 Q"Can I solve it a different way?" Q38 he considers another approach
      1. 15:55-16:52 he considers that ~display:~ receives ~aBlock~ and he supposes there is a method like ~gtValue:~ Q"Is there a method called ~gtValue:~?" Q5 There is not such message, but he thinks there is another one like that.
         1. 16:23-16:52 He browses ~Object~ class and finds ~glamourValue:~ method. Q6
      2. 16:52-16:56 Q17 he asks who implements ~glamourValue:~; only ~Object~.
      3. 16:56-17:06 Q17 he asks who implements ~glamourValueWithArgs:~; there are 8 implementors.
      4. 17:06-17:13 Q6 he observes other method protocols of ~Object~. He does not find anything interesting.
      5. 17:13-17:30 He goes back to ~glamourValueWithArgs:~ implementors. He observes the one implemented on ~BlockClosure~ Q17 and says "I do not know."
   4. 17:30- He decides to implement ~if:display:~ idea and multi-display strategy
      1. 17:30-18:15 Q"What happens if everything breaks?" Q43 c"observer" C"Observer says something, but I do not hear it." He browses ~GLMPresentation~ and method ~display:~. C"The question is more narrative, no intention to deeply understand it." He cleans the spaces and closes not important windows.
      2. 18:15-18:39 Q"How the ~transformation~ is used?" Q15 c"abandoned-question" C"According to lazy initialisation he expects how it is used." C"He asks the same question later at 31:29."
         1. 18:21-18:30 Q"Who reference ~transformation~ instance variable?" Q12 there are two methods: accessor and setter.
         2. 18:30-18:39 Q"Who calls ~transformation~ method?" Q12 c"abandoned-question" he almost asks for it, but he can see that by default the value is ~#yourself~. He thinks that providing a block should work.
      3. 18:39-20:02 he writes ~if:display:else:~ method in ~GLMPresentation~ class.
      4. 20:02-21:38 he tries it. He copy-pastes the snippet into new workspace. c"save" It works as expected. Q42
6. 21:38-24:07 he states that it works and asks Q"What should I do now?" Q44 c"observer" C"Observer answers that this is an unexpected result. Observer explains what was the idea. Participant agree that this is pretty different. Then he says that it is likely not a solution, only a basic block (referring to ~if:display:else:~ method)."
7. 24:07-50:14 C"Extending or writing a new API that more fits to the assignment's expectation."
   1. 24:07-26:08 Q"How the snipped (API) could looks like to fit the assignment idea?" Q38 He writes new snippet with the initial existing API and uses ~Delay~ and tests if it works. c"observer" C"Observer says that it that moment it could display that it is computing."
   2. 26:08-33:44 he thinks of some method like ~displaySlow:~ instead of ~display:~. He starts to write it. c"failed-intention"
      1. 27:50-29:25 <<t8link1>> He thinks that he has to determine if the execution is slow. He wants to test if it slow by executing it. c"false-assumption" C"I think he does not want to play with threads." c"miss-opportunity"
         1. 29:25-29:29 Q"What does the ~timeToRun~ method return?" Qe5
            1. 29:25-29:29 He browses implementors; Q17 there is only one. He reads the answer in the method comment.
         2. 29:29-31:29 as he writes the if-statement he can see that this will not work. He states S"There is no way I can do that. ... I believe there is no way to solve the task."  C"Apparently the task is so complex, because it involves threads, Glamour complex framework; and he is not familiar with this." He states that he cannot have ~displaySlow:~ method. He thinks about it.
      2. 31:29-32:05 Q"How the ~transformation~ is used?" Q15 he asks for senders of ~transformation~ method. He says that he has seen a place that accepts a block with two arguments.
      3. 32:05-32:09 Q"What is the ~glamourValue:~ method about?" Q17.
      4. 32:09-32:14 Q"What is the ~glamourValueWithArgs:~ method about?" Q17.
      5. 32:14-32:29 he observes ~computeAnnouncerObjects~, ~value~. He closes the Users window saying S"I am stuck."
      6. 32:29-33:44 <<t8link2>> he observes the snippet and consider that he could compute it in another thread, but he says that it would not work. c"false-assumption" C"I think the only solution is to use threads, but likely in different class or method." He thinks that the user has to do something (like ~if:display:~), that the system cannot be too smart in order to work properly. He claims that ~displaySlow:~ cannot be done.
   3. 33:44-50:14 Q"How can I improve the current solution or is there a better solution?" Q38
      1. 33:44-34:05 he asks if we are done about it, there is still time to do something.
      2. 34:05-34:57 he says that he is not satisfied about current ~if:display:~ solution. He is not happy about it. He claims that the direction is likely good one; there has to be a condition somewhere. c"false-assumption" C"I think threads are solution. No condition." he says, if there are condition behinds, threads are necessary and it is complex. He writes in the snippet =really compute= string to demonstrate that this is what he does not like much.
      3. 34:57-35:30 He executes the code and considers that displaying 'really computer' instead of a value could be solution. Q42
      4. 35:30-35:56 he obtains a c"debugger" window ~MessageNotUnderstood~ Q"Why it does not understand message ~isByteString~?" He observes the stack. Qe8
      5. 35:56-36:17 he closes the c"debugger" and the example window.
      6. 36:17-37:04 he thinks to have kind of lazy-computation thing. He observes the snippet Q17 and thinks about a solution.
      7. 37:04-50:14 he says S"Let's try something." Q38
         1. 37:04-37:21 he opens browser and create class ~NamedHolder~.
         2. 37:21-37:36 writes ~initiliaze~ method.
         3. 37:36-37:57 he writes ~printOn:~ method.
         4. 37:57-38:37 He uses the ~NamedHolder~ in his snippet and he executes the code. There is an error in his new class: missing ~description~ method. He closes the c"debugger" and fixes it.
         5. 38:37-38:51 he tests it, and it works. Q42
         6. 38:51-39:07 he says that if he clicks on the ~NamedHolder~ object, it will complain, because it is not a number. He tries it and a c"debugger" appears. He closes it.
         7. 39:07-39:23 he changes the snippet and introduce ~forwardTo:~ message.
         8. 39:23-39:59 he defines ~forwardTo~ instance variable on ~NamedHolder~ class, ~doesNotUnderstand:~ message.
            1. 39:40-39:47 Q"How should I define the ~doesNotUnderstand:~ message?" Q4
               1. 39:40-39:47 He browses all implementors Q17, finds a one that fitst to his needs.
            2. 39:47-39:59 he writes the code and closes the Implementors window.
         9. 39:59-40:51 he explains the intention of this effort.
         10. 40:51-41:14 he executes the snippet. He clicks on 'compute!' string and he is surprised that it returns compute, instead of a factorial. Q42
         11. 41:14-42:25 Q"Why does it not work the way I expected?" Qe8 he observes the example window. c"observer" Observer asks him what he thinks about. He explains why it does not work.
         12. 42:25-42:29 c"observer" says that he can stop the session. He says that he is almost done, so he can continue five minutes more. He is convinced that this is the correct direction.
         13. 42:29-43:00 He observes ~doesNotUnderstand:~ method and changes it saying S"I am doing something dirty now." he changes the code. c"observer" C"Observer asks him what he is doing. This is the moment when the participant understand that he goes a wrong way and realizes it in the moment he tries to explain it."
         14. 43:00-44:25 He changes the snippet. He checks it by reading the code, but he is not sure about the if-statements. He is kind of lost (or tired of this session), so he decides to execute it.
         15. 44:25-44:40 he executes it and he sees that it does not work as expected.
         16. 44:40-46:00 Q"Why it does not work?" Qe8
             1. 44:40-45:09 he observes the snippet. He changes the snippet
             2. 45:09-46:00 and he executes it. He fixes an issue and executes it again. It works.
         17. 46:00-46:10 he says Q"Is this the thing I want to have? Is this the solution I want to have?" Q44 he decides to put the code into the ~if:display:else:~ method.
         18. 46:10-46:25 he browses the ~if:display:else:~
         19. 46:25-47:55 he defines new method ~slowDisplay:for:~. he copy-pastes parts of the snippet into that method.
         20. 47:55-49:01 he opens a new workspace and copy-pastes the old snippet and uses ~slowDisplay:for:~. As he checks it, he changes a bit ~slowDisplay:for:~ method.
         21. 49:01-49:13 he executes the snippet. He receives a c"debugger", and without reading he closes it.
         22. 49:13-49:24 Q"Why does it not work?" Qe8 He observes ~slowDisplay:for:~ code and changes it.
         23. 49:24-49:31 he executes the snippet. It still does not work because of another error. He closes the c"debugger" and fix it immediately, because he got the issue.
         24. 49:31-50:14 he fixes ~slowDisplay:for:~ method. It works and he is happy about it.
8. 50:14-53:26 he goes to another older snippet with ~displaySlow:~ message and decides to try it. He changes it, it takes time to him to write a right example. He tests it and it works. Q42
9. 53:26-64:41 Q"Does the solution fits to other presentations?" Q43 c"unfinished" 
   1. 53:26-54:19 c"observer" There is a discussion about applicability to other presentations. He browses ~painting:~ method and he things that he should offer ~slowPainting:~. Q38
   2. 54:19-54:32 He defines ~slowPainting:for:~ in ~GLMRoassal2Presentation~.
   3. 54:32-59:56 he copy-pastes the snippet to a new workspace and changes it.
      1. 55:15-55:18 Q"How should I use the Roassal2 presentation?" Q26
         1. 55:15-55:18 He browses implementors of ~roassal2~ message. Q12
      2. 55:18-56:15 he writes the snippet.
      3. 56:15-56:29 he executes it, but there is a not expected view.
      4. 56:29-59:56 Q"Why does it not work?" Qe8
         1. 56:30-56:32 he changes the snippet
         2. 56:32-56:35 and executes it, a c"debugger" appears. He closes it.
         3. 56:35-57:23 Q"Is the ~GLMFinder~ object the one I want to have in this example?" Q38 c"abandoned-question"
            1. 56:35-56:49 back in the workspace with his code snippet.
            2. 56:49-57:02 he browses ~roassal2~ implementors. Q12 c"unanswered-question" he closes the window.
            3. 57:02-57:23 he explains how he wants to solve it. He states that S"I do not know Glamour, I have to find out how to do that." he closes not used windows.
         4. 57:23-57:40 Q"Is there a Glamour browser somewhere?" Qx"It is question about IDE, not about code." c"lost-among-windows" he closes the unwanted windows. c"observer" C"Observer says that the session takes almost one hour, but the participant wants to follow, because he believes he is almost done." He opens the Glamour Examples window.
         5. 57:40-59:56 Q"How can I achieve that functionality I can see in the Glamour example browser?" Q26
            1. 57:40-57:47 he closes the example browser. C"I do not understand why he does not tried to find example code in the Example Browser."
            2. 57:47-58:14 he browses ~GLMExamplesBrowser~ and ~GLMBasicExamples~ classes Q6,
               1. 57:59-58:14 then ~treeWithTags~ method Q17, he finds usage of ~GLMTabulator~. He thinks that this is a object he should use.
            3. 58:14-59:56 he changes the snippet. He is surprised that the example says =transmit to: #one= and not =transmit to: #two=. He tries to execute the example, but he fails C"He does not select whole the method. And he could actually see it more comfortably from the Glamour Example browser."
               1. 59:07-59:12 Q"If I have just this simple code, how does it work?" GQ"(23) How does the application works?" he executes it and states that this is what he wants.
               2. 59:12-59:46 he changes the snippet.
               3. 59:46-59:56 and executes it. He says that this is what he wants.
   4. 59:56-64:41 Q"How can I use ~slowPainting:for:~ for that snippet? Do I need to change the method?" Q38 c"unfinished"
      1. 59:56-60:43 he now wants to use ~slowPainting:for:~ method, he browse it. Q17 He thinks that it is going to be different (comparing to ~slowDisplay:for:~).
      2. 60:43-61:29 he copy-pastes the snippet into the new workspace. C"He says that he keeps examples, this is why he has a lot of windows. So a playground with separated snippets, or history of snippets could be useful." c"playground" c"chatter" he writes the code.
      3. 61:29-61:38 he goes to ~slowPainting:for:~ and says S"I do not want... Does it work? Let's try."
      4. 61:38-61:46 Q"Does the current solution and snippet works?" Q42 he executes the snippet and receives an error ~MessageNotUnderstood~ c"debugger"
      5. 61:46-62:32 Q"Why does it not work?" Qe8 c"not-fixed-issue"
         1. 61:46-61:52 Q"What is the value of ~element~ variable?" Q27 C"It is displayed in the debugger but he inspect it anyway. Quite common in the most sessions." he inspects it and he can see that it is =nil=.
         2. 61:52-62:04 he browse the stack but apparently he is lost. Q31 He closes the c"debugger" and the snippet view.
         3. 62:03-62:32 he observes ~slowPainting:for:~ Q17 and finds the bug and uses a new message ~if:paint:else:~
      6. 62:32-62:50 He says that S"We are almost done. I know that I have said it a while ago."
      7. 62:50-62:59 he browses ~if:display:else:~, but as he cannot find a window with this and C"I suppose he neither remember where it was defined", he writes it and browses implementors Q17 C"Some kind of stored links (bookmarks) could be useful. Maybe as a part of Playground."
      8. 62:59-64:14 he copy-pastes the ~if:display:else:~ method and creates ~if:paint:else:~ method.
         1. 63:32-63:40 he browses ~glamourValue:~ method Q17 and copy-pastes ~glamourValueWithArgs:~ name.
         2. 63:40-64:14 he changes the method.
      9. 64:14-64:41  Q"Why does it not work?" Qe8 c"unfinished"
         1. 64:14-64:28 he executes the snippet. It does not work. he observes the stack. He close the c"debugger".
         2. 64:28-64:41 he observes the snippet.
10. 64:41-88:05 session stops. and discussion
** Session S9 with P5, unfamiliar (Temporary Variables Management)
   :PROPERTIES:
   :VideoFile: videos/S9-P5.m4v
   :FUEL: dflow/S9-P5.fuel
   :VIDEO-START-TIME: 2014-11-17T19:08:37.352996-04:00
   :Familiar: 0
   :SESSION-ID: S9
   :PARTICIPANT-ID: P5
   :END:
*** Tool Usage
1. 00:00-00:43 c"rest-time"
2. 00:43-04:46 c"dynamic-tool"
3. 04:46-08:30 c"static-tool" he uses Finder
4. 08:30-08:38 c"dynamic-tool"
5. 08:38-09:47 c"static-tool"
6. 09:47-11:50 c"dynamic-tool"
7. 11:50-12:15 c"static-tool"
8. 12:15-12:31 c"dynamic-tool"
9. 12:31-13:24 c"static-tool"
10. 13:24-13:30 c"dynamic-tool"
11. 13:30-16:11 c"static-tool"
12. 16:11-16:31 c"dynamic-tool"
13. 16:31-16:56 c"static-tool"
14. 16:56-22:36 c"dynamic-tool"
15. 22:36-23:11 c"dynamic-tool" process browser
16. 23:11-23:05 c"dynamic-tool"
17. 23:05-23:46 c"static-tool"
18. 23:46-42:21 c"dynamic-tool"
19. 42:21-44:21 c"static-tool"
20. 44:21-44:34 c"dynamic-tool"
21. 44:34-45:35 c"static-tool"
22. 45:35-55:00 c"dynamic-tool"
*** Transcript
1. 00:00-00:43 Task explanation. 
2. 00:43-47:25 Q"What clases are responsible for this behavior?" Q1 c"answered-question" C"He knows where the dialog is executed and processed."
   1. 00:43-01:21 C"he uses a paper for making notes." He says that he has two options how to answer the question: a) introduce an error, capture a dialog and this dialog could point him to a method that makes the verification. b) browse core clases and check if some of them are responsible for the feature.
   2. 01:21-47:25 He introduces an error in order to find a responsible method or class. Q3 C"He says error, but it is the behavior that he should change."
      1. 01:21-02:18 he opens a Transcript in order to make some logs. C"He is a Java developer and for that reason he usually uses a transcript for logging information. He is aware that in Pharo he can do it differently." he writes an example c"prototype", executes it and a dialog saying "OK to remove it?" appears. C"Actually he did not use the Transcript."
      2. 02:18-23:56 <<t9link4>> Q"Who is responsible for executing this dialog?" Q1 c"answered-question"
         1. 02:18-04:46 inspecting dialog approach Q27
            1. 02:18-02:31 <<t9link5>> c"halos" c"halo" inspects the dialog widget of ~ToggleMenuItemMorph~ class. c"miss-opportunity?" C"I think he would prefer to inspect a top-class of the dialog." 
            2. 02:31-03:38 <<t9link1>> he observes ~ToggleMenuItemMorph~ variables. c"miss-opportunity" C"I think the ~target~ variable is what he is interested in. But he says that ~target~ is something different." c"miss-opportunity-removed" C"Variable ~owner~ could also navigate him close to the answer. <- No. the target variable is the right one and more explicit."
            3. 03:38-04:04 He goes back to the dialog and thinks how to answer the question. He closes the dialog.
            4. 04:04-04:28 c"halos" he executes the code again and inspects the ~ToggleMenuItemMorph~ object of the dialog. He closes it saying he is wrong.
            5. 04:28-04:46 c"halos" then he inspects another part of the dialog and inspects ~PopupChoiceDialogWindow~. He does not observe the inspector much. c"miss-opportunity" C"He could search for the class references and put halt to only method in UITheme>>chooseIn:title:labels:values:lines:."
         2. 04:46-08:30 search string approach Q2
            1. 04:46-06:50 <<t9link41>> He opens Finder and search for the string 'appers to be unused in this method' that appears in the dialog. C"He has a typo in the search string." C"He says that he cannot uses the IDE while it search for the string." c"ide-impropper-behavior" c"miss-opportunity"
            2. 06:50-08:30 He tries to search for a shorter string with the same typo 'appers to be unused' While it is searching he thinks of question "What package is responsible for the dialog (behavior)?" He also thinks that another option is that the dialog occurs while it compiles the code. There is no answer. c"miss-opportunity" C"He is surprised that searching string does not work. But he does not check the written text."
         3. 08:30-08:51 <<t9link2>> Q"Is there a package called 'Class'?" Qx"It is unintended question. He wants to search for a class." he opens a browser and searches for package called 'Class' but he immediately stop this approach. C"Actually this was unintended question. He wanted to filter or search the class. Apparently the input fields should be more flexible then one can thoughts. The same feelings that this should also supports class searching/filtering expressed P6 in S10."
         4. 08:51-09:42 <<t9link3>> Instead he opens a workspace and writes ~Class~ and browses it. c"beginner" C"He could open search dialog in the browser and search for the class. He likely do not know about it." Q"Is there a method in the ~Class~ class that is responsible for the compilation? Something that contains word 'compile'?" Q5 He browses ~compileAll~ and ~compileAllFrom:~. c"spotter" C"Openning the class in the Spotter could be much faster." c"ide-impropper-behavior" c"abandoned-question" c"miss-opportunity" C"I have an impression that he could find it by looking at ~compile:~ method, but it is in a super class."
         5. 09:42-10:52 He thinks about an example with block. He is back in the workspace with the snippet code and executes it several times and cancels the dialog.
         6. 10:52-11:51 Q31
            1. 10:52-11:24 He writes =self halt= into ~compileAll~ method.
            2. 11:24-11:28 and executes the snippet. It does not produce any halt.
            3. 11:28-11:51 he removes the halt and executes the snippet again.
         7. 11:51-13:33 Q"Is the ~BlockClosure~ object responsible for a compilation? Does it contains a smell-method?" Q3
            1. 11:51-12:29 He thinks about a snippet with block closure. c"false-assumption" He browses ~BlockClosure~ and c"observer" asks him why he is interested in it. He changes the snippet writing a block.
            2. 12:29-13:33 he observes its methods Q6 and spots ~value~. He puts =self halt= into ~value~ method. He executes the snippet but no breakpoint appears. He removes the halt.
         8. 13:33-15:15 Q"Is there something about compilation of the snippet in ~Class~ class or around?" Q5
            1. 13:33-15:15 he thinks that the behavior has to be in the ~Class~ class. Q6 He browses it, then ~Behavior~, then ~Class~. Then he observes packages around. He browses ~compileAll~, ~compileAllFrom:~, ~possibleVariablesFor:continuedFrom:~ c"miss-opportunity" C"I think that this method could navigate him in to the desired method."
         9. 15:15-15:26 Q"Is there something about compilation of the snippet in ~Kernel-Methods~ package?" Q5
            1. 15:15-15:26 He browses ~Kernel-Methods~ package and observes its clases. Q6
         10. 15:26-16:04 Q"Is there something about compilation of the snippet in ~Kernel-Processes~ package?" Q5
             1. 15:26-16:04 He browses ~Kernel-Processes~ package and observes its clases. Q6 He browses ~Process~ class and reads its comment, then its methods ~debug~, ~debug:title:~. He clicks on ~MonitorDelay~ class, ~UserInterruptHandler~, ~Mutex~ but without a deep observation.
         11. 16:04-16:11 he browses ~Class~ class but immediately changes his idea.
         12. 16:11-16:31 c"halo" c"halos" he selects the snippet, and inspects ~RubEditingArea~ object. Q27 He observes slightly the instance variables, but apparently without a concrete idea what to search for.
         13. 16:31-16:39 he browses ~RubEditingArea~ class and asks Q"In which package is the ~RubEditingArea~ class?" Q7 It is in ~Rubric~ package.
         14. 16:39-16:40 Then he browses ~RubEditingArea~ class comment which is empty.
         15. 16:40-16:54 He browses its super class ~RubAbstractTestArea~ and reads its comment. Q6 He closes the browser.
         16. 16:54-17:14 <<t9link5>> c"halo" c"halos" Q"Can I inspect the thing that is selected?" Q27 C"I am not sure if he referes to the text or to a Morph that it keeps, because he wants to execute it. He is likely not aware of any execute: or compile: method." c"abandoned-question"
         17. 17:14-17:49 Q"Can I halt the snippet before the dialog appears?" Q31 he uses a halt =self halt= and a block in his snippet. He executes it and he concludes that he cannot use this technique.
         18. 17:49-18:22 Q"Is there any context menu item that can aid me to answer the question?" Q5 He removes =self halt=, selects the snippet and search for any interesting item in the context menu. He cannot find anything and chooses do-it item.
         19. 18:22-22:34 <<t9link6>> Q"Is there any event that is executed after answering the dialog question?" Q3 c"abandoned-question"
             1. 18:22-19:14 c"halo" c"halos" after a while he inspects ~PopupChoiceDialogWindow~ object Q27 and briefly observes the instance variables. c"miss-opportunity" C"There is 'appear to be unused' text at 19:12."
             2. 19:14-22:34 c"halos" he inspects Cancel button widget; it is ~PluggableButtonMorph~ object. Q27 He checks Morph tab in order to see if it is the widget he wants to inspect. Q"Is the inspected object the one I expect?" Qx"The question 27 is more concrete." Then he observes instance variables. c"miss-opportunity-removed" C"There is ~actionSelector~ instance variable. <- not useful information" c"miss-opportunity" C"There is 'appear to be unused' text at 20:56."
                1. 19:43-19:45 he raises question GQ"(12) What are the objects that references this object? Where is this object referenced?", but he abandones the question. He thinks it is not possible to answer it. c"abandoned-question" c"ide-not-used".
                2. 19:45-20:25 he browses ~owner~ chain and gets to ~PopupChoiceDialogWindow~ object. He asks Q"What is ~choicesMorph~ instance variable about?" Qx"Parent questions" He can see that it is yes/no button widget. c"miss-opportunity" C"He could see what the yes/no buttons do after mouse click."
                3. 20:25-21:33 He selects ~PopupChoiceDialogWindow~ and asks Q"Who call you?" GQ"(12) What are the objects that references this object? Where is this object referenced?" and observes instance variables. c"miss-opportunity" C"At 20:44 he could see 'appears to be unused' text."
                4. 21:33-21:47 he switch to Extension tab and here he can see ~ballonText~ with text 'Cancel changes and close the window'." c"miss-opportunity-removed" C"He could use this text to search it in the code. <- Actually it is quite hard to navigate to the right method."
                5. 21:47-21:48 he switches to Morph.
                6. 21:48-22:34 he switches to Extension, to Morph, to Submorphs, to Raw tab. He observes instance variables, chooses ~owner~. He search for some callback, someone who waits that this dialog terminates. c"miss-opportunity" C"He could spot labelString with appears to be unused string."
         20. 22:34-23:12 Q"Is there any process related to the modal dialog?" Q5 He opens Process browser but he does not understand it much and closes it. c"abandoned-question"
         21. 23:12-23:56 halting modal dialog when the object is created approach
             1. 23:12-23:22 he goes back into the inspector Q27 and opens context menu for ~owner~. c"miss-opportunity-removed" C"Here he could see menu item 'Open pointers to'. <- this is not an useful information. He cannot see where it is called." 
             2. 23:22-23:39 He browses ~PopupChoiceDialogWindow~ class. Q6
             3. 23:39-23:46 he browse ~initialize~ and puts =self halt=. Q17
             4. 23:46-23:56 he closes not used windows.
      3. 23:56-47:25 Q"How does it work? Where is the code that opens the dialog and handle the user answer?" Q3 c"debugger" he executes the snippet and debugger appears. C"I have an impression that he is not aware that his snippet is here represented as AST. He says that he does not know what does it mean OCAST. He likely does not separated it into OC and AST."
         1. 23:56-24:21 Q"Who calls ~PopupChoiceDialogWindow~?" Q14 A ~Pharo3Theme~ calls it.
         2. 24:21-29:43 He observes in the c"debugger" stack with ~handleSignal:~ Q31, then he can see ~OCUnusedVariableWarning~ objects and decides to browse it in order to have a bookmark about it. c"bookmark". He observes ~signal~ method in the debugger. He says that ~OCASTSemanticAnalyzer~ sounds like a state of compilation. He reads the code and he sees that ~aSequenceNode~ contains his code. He observes ~doSemanticAnalysis~ method. c"ide-error"
         3. 29:43-29:47 Q"What is returned object of =self compilationContext semanticAnalyzerClass new=?" Q27 He inspects it, reads the class name, and closes it. C"He could read it from the stack."
         4. 29:47-30:44 Q17 he goes to ~analyze:~ method, ~acceptVisitor:~ method, ~visitMethodNode:~ method.
         5. 30:44-30:51 he inspects ~aMethodNode~ temporary variable but it raises an error c"ide-error"
         6. 30:51-31:01 as he can inspect ~aMethodNode~ at the bottom of the debugger, he writes =self body= Q27 C"He could call it directly from the debugger." but it raises an error ~MessageNotUnderstood~ c"debugger".
         7. 31:01-33:11 c"ide-error" He browses ~acceptVisitor:~, ~visitMethodNode:~, ~visitSequenceNode:~. Q17
         8. 33:11-33:18 Q"What does =node binding= return?" Q27 It returns ~OCTempVariable~ object. He closes the inspector.
         9. 33:18-33:53 Q"What does =aSequenceNode temporaries= return?" Q27 It returns collection of ~RBTemporaryNode~. He understands that each node represents the variables he defined in the snippet. He closes the inspector. c"miss-opportunity" C"Here he could recognize that this the code he has to change." c"bookmark" c"playground" C"Anyway, if he could recognize it, there is no a simple way to bookmark it. Maybe a playground with bookmarks and with nodes could be useful."
         10. 33:53-35:16 Q"What is ~CompilationContext~ in ~compilationContext~ instance variable about?" Q25 He observes it in the inspector and he concludes that it is likely something important that keeps what is compiled.
         11. 35:16-35:31 He executes the code with ~OCUnusedVariableWarning~ object that opens the dialog. He receives a c"debugger" with the breakpoint in ~PopupChoiceDialogWindow~ object. He deletes the breakpoint. Closes the debugger.
         12. 35:31-35:34 He executes the code with ~OCUnusedVariableWarning~ object again and obtains the dialog.
         13. 35:34-36:29 he observes ~unusedVariable:~ method, then ~signal~ method Q17
         14. 36:29-36:59 Q"Where is the code responsible for the dialog (in the debugger stack)?" Q29 c"debugger" he expects that somewhere in the stack has to be a code that asks for removing the variable and the removing action. c"miss-opportunity" C"He could see it in the stack, it is called ~defaultAction~."
         15. 36:59-37:06 He browses ~defaultAction~ Q17 C"Unfortunately not all the source code is visible." c"miss-opportunity" c"ide-confusion"
         16. 37:06-37:13 he browses ~chooseFrom:lines:title:~ Q17 c"miss-opportunity" C"He is so close, there is ~aList~ with yes, no values. ~_stack top~ shows the 'v2 appears to unused...thod. OK to remove it?' string."
         17. 37:13-37:29 he browses ~newWithTheme:~, ~chooseIn:title:labels:values:lines:~ Q17 C"Here he can see the dialog creation."
         18. 37:29-38:21 he browses ~defaultAction~, ~handleSignal:~, Q17 c"observer" C"Observer asks him what does he search for. He explains that the part of code that is responsible for the dialog."
         19. 38:21-41:22 Q"What happens after handling the signal?" Q31 c"abandoned-question"
             1. 38:18-40:38 <<t9link1>> he writes =self halt= into ~handleSignal:~ method. c"false-assumption" C"He believes that the breakpoint will work, but there is a return statement before."
                1. 38:39-39:25 Q"If the object is instance of ~MethodContext~, why ~_self~ displays ~BlockClosure~?" Q23 c"abandoned-question" C"After cleaning windows he does not think about it."
                   1. 38:39-39:25 He closes all unused windows and saves the image. c"save" C"Actually he also close a 'bookmarked' class without using it. Apparently not all bookmarks are used. And he also closed his workspace with the snippet." c"bookmark"
                2. 39:25-40:08 he observes ~handleSignal:~ method. c"false-assumption?" C"I have an impression that he is confused about signification of the context and ifFalse: statement. He likely expectes that this is about yes-no user decision in the dialog."
                3. 40:08-40:38 Q"Does it halt in the ~handleSignal:~ method?" Q31 he goes to existing workspace and writes again his snippet and executes it, then closes it. C"He expected that it will halt in the ~handleSignal:~ method."
             2. 40:38-41:07 he is back in the ~handleSignal:~ method and puts =self halt= into other part of the code; the right one.
             3. 41:07-41:08 <<t9link2>> he accepts the code and receives a c"debugger". He closes it. c"false-assumption" C"He should accept it, because this is the compilation of the code he wants to change."
             4. 41:08-41:18 He accepts it several times and closes all the debuggers c"debugger".
             5. 41:18-41:22 he executes the code again and receives the dialog; he expected the halt.
         20. 41:22-41:59 he thinks to stop the session, but in the end he decides to do it other five minutes.
         21. 41:59-42:05 he closes other windows and keeps only the workspace.
         22. 42:05-47:25 GQ"(e8) How can I get into the code where I have been before?" C"The breakpoint does not work and he closed all windows. He lost information."
             1. 42:05-42:38 C"What is ~CompilationContext~ class about?" He browses ~CompilationContext~ class, and observes the class comment.
             2. 42:38-43:05 he observes packages around the ~OpalCompiler-Core~ package.
             3. 43:05-43:21 GQ"(e8) Can I reopen the recently closed windows?" c"lost" C"Apparently he closed all the windows and lost all the information. He does not remember where he was in the debugger." c"unanswered-question"
             4. 43:21-44:15 Q8 He clicks on the ~OCUknownSelectorWarning~ class, then ~OCUnusedVariableWarning~ class. c"miss-opportunity" C"He could check ~defaultAction~ method."
             5. 44:15-44:21 Q"What is ~Notification~ class about?" Q6 he browses it.
             6. 44:21-44:34 He writes in the workspace =Notification new= and inspects it. He does not find anything useful and closes it. Q27
             7. 44:34-45:35 <<t9link3>> He expects something like ~addEvent:~ or ~addListener:~ in ~Notification~ class. Q5 c"false-assumption" C"He searches for a Java API that does not exists in Pharo. Same as P4 used Roassal2 API strategy for Glamour, but it does not fit." he closes the browser.
             8. 45:35-45:55 he clicks on ~OCUnusedVariableWarning~ class, and then ~defaultAction~ method. Q17
             9. 45:55-46:14 He finds the 'appears to be unused...' string and asks why it did not find it. Q"Why the text was not found before?" Qx"Not related to source code, but rather to tool and human failure." C"First, there was a typo, then he searched for 'app...' but there is '<space>app'."
             10. 46:14-46:42 he writes =self halt= in the ~defaultAction~ method.
             11. 46:42-46:53 <<t9link4>> c"false-assumption-removed" C"He accepts the method, but he receives a debugger. He does not understand that the method contains unused variables and he should proceed it. <-- this is the breakpoint that he put at 40:38 into ~ContextPart>>handleSignal:~ method, but it does not affect the current breakpoint." c"debugger"
             12. 46:53-47:21 he puts =self halt= onto another line. He accepts it and receives the c"debugger". He closes it.
             13. 47:21-47:25 he executes the snippet and finally obtains the c"debugger".
3. 47:25-54:58 Q"How does it behave after answering the dialog question about removing a variable?" Q31
   1. 47:25-47:57 he proceeds the first =self halt= and expectes that it halts on the second breakpoint. It halts in the second breakpoint, but because of wrong slider position, he is confused and does not undrestand where he is. c"ide-confusion"
   2. 47:57-48:37 he goes to the workspace with the snippet and runs it. He discusses the code in ~defaultAction~ method. He believes that it has to halt in that line and writes =self halt= again and closes the c"debugger".
   3. 48:37-48:43 Q"Is the breakpoint well defined?" Q38 He checks the ~defaultAction~ method again in the browser.
   4. 48:43-49:05 he executes the snippet and obtains c"debugger" in ~defaultAction~ method. c"ide-confusion" C"again he does not understand that it is the desired method, but after a while he realizes it."
   5. 49:05-49:31 he steps in the ~defaultAction~ method but then he decides, that he wants to debug the version when he answers 'no'. He closes the c"debugger".
   6. 49:31-54:58 and executes the code again and traces it. Q31
      1. 50:13-50:31 he reads the rest of the code and then inspects ~node~ variable and asks Q"What does =node parent scope= returns?" Q27 He evaluates it inspects ~OCMethodScope~ object.
      2. 50:31-50:41 Q"What does =node parent= returns?" Q27 he inspects ~RBSequenceNode~ object. he closes the inspector.
      3. 50:41-51:27 Q"What does it want to remove?" Q25
         1. 50:58-51:00 Q"What does =self node parent scope lookupVar: (node name)= returns?" Qe5, it is ~OCTempVariable~ object. he closes the inspector.
         2. 51:00-51:27 he reads the code and concludes the behavior.
      4. 51:27-51:57 he steps in the method. he steps-in ~removeTemp:~ method.
      5. 51:57-53:47 Q"What is the behavior of ~removeTemp:~ method?" Q17
         1. 51:57-52:09 he observes variables in the c"debugger". He inspects ~tempVars~ variable and sees two variables.
         2. 52:09-52:34 he steps, and observes variables. He inspects ~tempVars~ that has only one variable now.
         3. 52:34-53:47 he steps and observes variables.
      6. 53:47-53:49 he steps out into ~defaultAction~ method.
      7. 53:49-54:06 he steps.
      8. 54:06-54:10 Q"What has happened with the node's parent?" Q27 He inspectes =self node parent= and receives ~RBSequenceNode~ objects where he can still see text with both variables. He closes the inspector.
      9. 54:10-54:19 he steps. he steps into ~removeTemporaryNamed:~ method.
      10. 54:19-54:58 he observes the method and aks Q"What does 'temporary' is?" Q27 C"He likely writes a note on the paper." c"unanswered-question"
4. 54:58-55:08 c"observer" C"Observer asks him to stop the session." session finished.
** Session S10 with P6, unfamiliar (Workspace and CMD+. and Tab keys)
   :PROPERTIES:
   :VideoFile: videos/S10-P6.m4v
   :NumberOfFuelFiles: 2
   :FUEL: dflow/S10-P6.fuel
   :FUEL-2: dflow/S10-P6b.fuel
   :VIDEO-START-TIME: 2014-12-01T10:25:05.946151-03:00
   :VIDEO-START-TIME-2: 2014-12-01T10:25:06.211376-03:00
   :Familiar: 0.5
   :SESSION-ID: S10
   :PARTICIPANT-ID: P6
   :END:
*** Tool Usage
1. 00:00-00:39 c"rest-time"
2. 00:39-02:59 c"dynamic-tool"
3. 02:59-03:20 c"static-tool"
4. 03:20-04:21 c"dynamic-tool"
5. 04:21-06:18 c"static-tool"
6. 06:18-07:44 c"dynamic-tool"
7. 07:44-07:56 c"static-tool"
8. 07:56-10:53 c"dynamic-tool"
9. 10:53-11:02 c"static-tool"
10. 11:02-11:31 c"static-tool"
11. 11:31-19:31 c"dynamic-tool"
12. 19:31-21:58 c"rest-time"
13. 21:58-23:34 c"dynamic-tool"
14. 23:34-24:29 c"static-tool"
15. 24:29-24:49 c"static-tool"
16. 24:49-25:04 c"dynamic-tool"
17. 25:04-27:09 c"static-tool"
18. 27:09-27:25 c"dynamic-tool"
19. 27:25-29:06 c"static-tool"
20. 29:06-43:18 c"dynamic-tool"
*** Transcript
1. 00:00-00:11 starts DFlow
2. 00:11-00:31 he opens browsers and arranges his working space.
3. 00:31-14:31 Q"How does it work now?" Qe8 S"Let's see what happens."
   1. 00:31-00:55 he opens workspace and writes =blah= and inspects it. c"ide-confusion" C"The inspector does not show anything for the nil object. It should show something; at least Meta tab." he closes it.
   2. 00:55-01:32 he press CMD+., it interrupts the code, but it also writes the dot into workspace. He thinks that everything happens in one thread, it first replaces the text with the dot, then it raises c"debugger" (interrupt).
   3. 01:32-14:31 Q"Can I verify this statement?" Q23
      1. 01:32-07:04 Q31
         1. 01:32-02:18 he observes in the c"debugger" ~Delay>>wait~ method, then ~doOneCycle~ and ~doOneCycleFor:~ method. He reads the method comment. He browses ~interCyclePause:~ method and reads the method comment. S"This is complicated." S"From here I am not sure [if I can verify the statement]."
         2. 02:18-02:59 He browses ~spawnNewProcess~. Q17 He sees that this is a UI process.
         3. 02:59-03:08 he browses implementors of ~doOneCycleFor:~. Q12 There is only one in ~WorldState~ class. C"He actually wants to browse the class."
         4. 03:08-03:20 he observes ~doOneCycleFor:~ and ~doOneCycleNowFor:~ in the browser. Q17
         5. 03:20-04:17 he switches to the c"debugger" and observes again ~doOneCycleFor~, ~doOneCycleFor:~, and ~interCyclePause:~ methods.
         6. 04:17-04:39 Q"How does the ~doOneCycleNowFor:~ looks like?" Q17 he browses it in the nautilus. C"He says that he did staff like this before. So he understands a bit the logic."
         7. 04:39-04:48 Q"Who implements ~processEvents~?" Q17 There is only one implementor in ~HandMorph~ class.
         8. 04:48-06:10 Q"How does the ~generateKeyboardEvent:~ method works?" Q17 he observes the ~generateKeyboardEvent:~ method. He identifies a part that is responsible for handling keystrokes and puts =self halt= there.
         9. 06:10-07:04 he closes the c"debugger", and now he finds out that it was a bad idea to put the breakpoint there because he cannot write anything. But he finds the way to remove the breakpoint without freezing image.
      2. 07:04-07:55 he prepares the workspace and writes =self haltOnce= into the ~generateKeyboardEvent:~.
      3. 07:55-09:04 he goes to the workspace, enables haltOnce and press CMD+. key. He obtains two debuggers c"debugger". He is surprised that he obtained two debuggers. He thinks which window debugger came up first. He closes a one debugger and realizes that he closed the wrong one. He closes the last one.
      4. 09:04-09:40 he wants write something in the Workspace, but it does not work because of the closed c"debugger" before. He enables the halt one and press CMD+., he obtains two debuggers.
      5. 09:40-14:31 Q"How does ~generateKeyboardEvent:~ method behave?" Q23
         1. 09:40-10:08 he observes ~generateKeyboardEvent:~ method in the c"debugger".
         2. 10:08-10:18 Q"What is the value of ~peekedEvent~ variable?" it is =nil=. Q27
         3. 10:18-10:23 Q"What is the value of ~evtBuf~ variable?" it is an array of numbers. Q27
         4. 10:23-10:35 Q"What is the value of ~modifiers~ variable?" it is 8. Q27
         5. 10:35-10:44 Q"What is the value of ~keyValue~ variable?" it is 46. Q27
         6. 10:44-12:00 Q"Does the number 46 represents dot character?" Q1
            1. 10:53-11:02 he opens workspace and inspects ~Character~ class. he closes it and browse the class Q6
            2. 11:02-12:00 Q"Can I instantiate character from a number?" Q21
               1. 11:02-11:31 he browses class side of ~Character~ class and observes methods ~codePoint:~, ~value:~, ~digitValue:~ He closes the browser. Q6
               2. 11:31-11:45 c"confidence" he writes and evaluates =Character digitValue: 46= and he obtains $e character. Q27
               4. 11:45-11:57 S"It does not makes any sense." he closes the inspector.
               5. 11:57-12:00 he closes the workspace.
         7. 12:00-12:05 he is back in the c"debugger".
         8. 12:05-12:10 Q"What is the value of ~keyEvent~ variable?" it is =nil=. Q27
         9. 12:10-12:34 Q"What are the values of method's variables?" He observes ~evtBuf~, ~buttons~, ~modifiers~, ~type~, ~pressType~, ~stamp~, ~charCode~, ~keyValue~, ~keyEvent~, ~peekedEvent~. Q27
         10. 12:34-13:08 he observes the method. c"ide-confusion" C"The parenthesis should be somehow better paired. Even P4 in T8 had the same problem with block parenthesis; it was hard to catch that he is outside of the outer block. Here it is the same. He in the end decides to step it."
         11. 13:08-13:26 he is surprised that it did not do any keystroke procedure at all.
         12. 13:26-13:43 he steps.
         13. 13:43-13:44 Q"What is the value of ~charCode~?" it is 46. Q27 c"ide-confusion" C"The annoying scrolling that is not necessary."
         14. 13:44-14:06 he realizes that it creates a ~KeyboardEvent~ object.
         15. 14:06-14:20 Q"How does it initialize the ~KeyboardEvent~?" Q21 he observes the code statically in the c"debugger".
         16. 14:20-14:31 Q"What other events can be created in the ~generateKeyboardEvent:~ method?" Q21 It can create ~MouseWheelEvent~, or nil.
4. 14:31-18:08 He decides to add a condition that checks if ~keyValue~ is 46, and ~modifiers~ is 8 and it will returns nil.
   1. 14:54-15:28 He says that this is high-level code and any CMD+. in the Pharo image will be ignored.
   2. 15:28-15:34 he writes part of the condition.
   3. 15:34-15:48 Q"Is there any exemplar that tests value of ~modifiers~ variable?" Q4 he looks for a code in the same method; no answer. c"unanswered-question"
   4. 15:48-17:03 he writes the rest of the condition. c"save"
   5. 17:03-17:59 he writes a comment that explains the new code.
   6. 18:00-18:05 he removes =self haltOnce= C"Quite organized guy. I have an impression that most of the people could forget it."
   7. 18:05-18:08 he proceeds the code.
5. 18:08-18:13 He can see that the text in the workspace is still there. S"That's cool!"
6. 18:13-18:23 he tests it and it works. Q42 He is done.
7. 18:23-18:37 He says that he does not know if it is the cleanest solution, but it works.
8. 18:37-19:30 He says S"Let's try something else." Q"What will happen if I put cursor here in the browser and press CMD+.?" Q43 he tries it and it works c"test"
   1. 18:56-19:13 He says that it is not necessary that it works on other operating system.
   2. 19:13-19:30 The other test we can do is Q"Does it works with both left and right CMD keys?" Qx"Same as parent question." c"test" yes, it works.
9. 19:30-20:18 assignment finished. Some chatting around, a rest.
10. 20:18 ------ Tab key assignment. -------
11. 20:18-20:24 he reads the assignment. S"He says that it is going to be painful. He does not know anything about GT Playground."
12. 20:24-21:30 he opens the image and starts DFlow.
13. 21:30-21:49 he reads the assignment
14. 21:49-43:16 Q"How does it work now?" Qe8
    1. 21:49-22:09 he opens workspace, writes a string and press tab key. Nothings happened.
    2. 22:09-22:13 he goes at the beginning of the string and press tab key. Nothings happened.
    3. 22:13-22:33 Q"Is this a GT-Playground issue?" Q34 He opens a browser and tests it in editing area. It works.
    4. 22:33-22:49 he arranges the windows.
    5. 22:49-22:55 <<t10link1>> c"halos" c"observer" C"He asks the observer how to raise the halos."
    6. 22:55-23:33 <<t10link2>> c"halo" c"halos" He uses halos and observes used Morphic objects that constructs the Playground. Q"How the Playground UI is constructed?" Q27 c"answered-question"
    7. 23:33-23:41 he goes to the browser, filter packages and selects ~GT-Playground~ package. Q6 It has 4 classes and 1 extension.
    8. 23:41-23:45 he browses ~GTPlayground~ class. Q6 C"That he says something I do not understand and goes back to the Playground. He likely realize that he needs a Morph object." 
    9. 23:45-24:01 c"halos" he observes again the used Morphic objects that constructs the Playground. Q27 He thinks that the Rubric framework is used and the problem could be here.
    10. 24:01-27:15 <<t10link3>> Q"Is this a Rubric issue?" Q34 c"answered-question"
        1. 24:01-24:03 Q"What Morphic object is used in the browser's code editor part?" Q27 c"halos" he uses halos to inspect it. He can see it is ~PluggableTextMorphWithLimits~ object. c"answered-question"
        2. 24:03-24:10 c"halo" c"halos" Q"What Morphic object is used in the Playground?" Q27 It is ~RubScrolledTextMorph~ object. c"answered-question"
        3. 24:10-24:35 He browses ~RubScrolledTextMorph~ class. Q6 C"He could browse it directly from halos."
        4. 24:35-25:04 He remembers that he uses Rubric framework in his application and the tab key works without any issues.
        5. 25:04-25:18 Q"Where ~RubScrolledTextMorph~ class is referenced?" Q12 there are 15 references.
        6. 25:18-26:09 He observes ~GLMMorphicRubricTextRenderer>>morph~ method. Q17
        7. 26:09-26:15 he observes ~GLMMorphicPharoPlaygroundRenderer>>morph~ method Q17, where he notices ~beForSmalltalkScripting~ message.
        8. 26:15-26:36 Q"Where is ~beForSmalltalkScripting~ method called?" Q12 there are 5 senders.
        9. 26:36-27:03 c"example" C"He searches for an example in order to isolate the issue." He observes ~RubScrolledTextMorph>>beForSmalltalkScripting~, ~RubSmalltalkScriptEditorModel>>newScrolledText~, ~RubSmalltalkScriptingMode>>updateTextAreaWhenPlugged~, ~RubTextAreaExamples class>>shoutedScriptingTextArea~. Q17
        10. 27:03-27:06 c"prototype" C"In order to isolate the issue." There is a method comment with a code =self shoutedScriptingTextArea= in the last method, that he executes. An Rubric text editor appears. Q25
        11. 27:06-27:15 Q"Does the tab key works in this Rubric editor?" Q34 Yes, it works. It is not rubric issue. He closes the example.
    11. 27:15-43:16 Q"What code is responsible for this issue?" Q3
        1. 27:50 He says that he could put breakpoint into the same method from the previous assignment and track how the tab is handled.
        2. 27:50-28:10 He browses ~HandMorph~ class. Q6 c"ide-confusion" C"The package filter should be also able to filter (find) classes."
        3. 28:10-28:20 he browses ~handleEvent:~ method. Q17
        4. 28:20-29:09 Q31
           1. 28:20-28:30 he identifies that it is not the method he used before.
           2. 28:30-28:37 he browses ~private events~ protocol and ~generateKeyboardEvent:~ method. Q17
           3. 28:37-28:52 he puts a =self haltOnce=.
           4. 28:52-29:02 he enables the haltOnce.
           5. 29:02-29:09 he presses tab key and a c"debugger" appears.
        5. 29:09-29:17 Q"What is the value of ~type~ variable?" Q27 it is =#keyDown=.
        6. 29:17-29:22 Q"What is the value of ~buttons~ variable?" Q27 it is 0.
        7. 29:22-29:55 Q"What is the =self position= return value?" Q27 he inspects it, it is a ~Point~ object.
        8. 29:55-29:59 Q"What is the value of ~keyValue~ variable?" Q27 it is 48.
        9. 29:59-30:11 Q"What is the value of ~lastKeyScanCode~ variable?" Q27 it is 125.
        10. 30:11-30:27 he steps ~generateKeyboardEvent:~ method.
        11. 30:27-43:16 Q"What happens with the created keyboard event?" Q23
            1. 30:27-30:55 he steps ~processEvents~ method.
            2. 30:55-31:22 he steps ~handleEvent:~ method.
            3. 31:22-31:23 Q"What is the value of ~captureBlock~ variable?" Q27 it is =nil=.
            4. 31:23-31:39 he steps the ~handleEvent:~ method.
            5. 31:39-31:51 Q"What is the return value of =self eventListeners=?" Q27 there is a one listener, he closes the inspector.
            6. 31:51-32:31 he steps in ~sendListenEvent:to:~ method.
            7. 32:31-32:42 he steps in ~handleListenEvent:~ method.
            8. 32:42-32:49 Q"Is the ~anEvent~ keystroke?" Qe5 He first suppose that yes, but it is not. He checks it by inspecting the code.
            9. 32:49-33:07 Q"Why is the ~anEvent~ not keystroke?" Q34 He checks that it is a =keyDown=. For him =keyDown= is keystroke.
            10. 33:07-33:18 he steps in ~sendListenEvent:to:~ method.
            11. 33:18-33:30 he steps in ~handleEvent:~ method.
            12. 33:30-33:39 Q"Is the ~evt~ event keyboard event?" Qe5 he evaluates the code; yes it is. c"ide-enhancement" C"He usually inspects evaluated code although printing representation could be enough for him. I think he behave like this, because it is inconvenient to dirty the code with printed strings. Perfect example for this new popup dialog."
            13. 33:39-33:48 Q"What is the return value of =self keyboardListeners=?" Q27 he inspects it and it is a =nil=; no one is listen to it.
            14. 33:48-34:01 he steps the ~handleEvent:~.
            15. 34:01-34:21 he steps the ~sendKeyboardEvent:~
            16. 34:21 he steps ~sendEvent:focus:clear:~.
            17. 34:21-34:23 Q"What is the value of ~focusHolder~ variable?" Q27 it is ~PluggableButtonMorph~ object.
            18. 34:23-34:42 He finds out, that the focus holder is wrongly set, because it asks in the moment of the debugging.
            19. 34:42-35:13 Q"What should I do in this situation? How can I solve this 'focus holder' debugging issue?" Q38 he decides to put =self haltOnce= in ~sendEvent:focus:clear:~ method.
            20. 35:13-35:56 Q"Where is the previous haltOnce breakpoint located?" Q12 he wants to remove the previous haltOnce, but he cannot find it on the stack. He closes the c"debugger". He removes the haltOnce from the ~generateKeyboardEvent:~ method in the browser. C"Good example of well organized workspace, because he found it right after closing the debugger window. Someone could simply call the method, remove the haltOnce, and call it again." he closes the browser.
            21. 35:56-36:36 He enables the haltOnce and he can see that the haltOnce does not work. It stops an event immediately.
            22. 36:36-36:47 Q"What is the ~anEvent~ about?" Q27 It is a mouse event.
            23. 36:47-37:12 Q"How can I make this haltOnce better?" Q38
                1. 36:47-36:53 He browses class of ~anEvent~ object called ~MouseEvent~.
                2. 36:53-37:12 he browses ~testing~ protocol and finds ~isMouse~ method. He closes the browser.
            24. 37:12-37:31 he writes the condition for the haltOnce breakpoint.
            25. 37:31-37:42 he proceeds the c"debugger".
            26. 37:42-37:54 he enables haltOnce and press tab key; a c"debugger" appears in ~sendEvent:focus:clear:~ method.
            27. 37:54-38:07 Q"What is the value of ~anEvent~ variable?" Q27 it is a keyDown.
            28. 38:07-38:09 Q"What is the value of ~focusHolder~ variable?" Q27 it is a ~RubEditingArea~ object.
            29. 38:09-38:25 he steps in ~sendEvent:focus:clear:~ method.
            30. 38:25-38:49 he steps in ~sendFocusEvent:to:clear:~ method and reads the method code.
            31. 38:49-38:54 he browses ~sendEvent:focus:clear:~, then ~sendFocusEvent:focus:clear:~. Q17
            32. 38:54-38:57 he steps ~sendFocusEvent:focus:clear:~.
            33. 38:57-39:02 Q"What is the value of ~aBlock~ variable?" Q27 it is a =[self keyboardFocus: nil ]= block closure.
            34. 39:02-39:27 he steps ~sendFocusEvent:focus:clear:~.
            35. 39:27-39:29 Q"What is the value of ~focusHolder~ variable?" Q27 it is a ~RubEditingArea~ object.
            36. 39:29-39:42 Q"What is the value of =focusHolder world=?" Q27 he inspects it, it is a ~WorldMorph~ object. He closes the inspector.
            37. 39:42-39:47 he steps ~sendFocusEvent:focus:clear:~.
            38. 39:47-39:50 Q"What is the value of ~w~ variable?" Q27 it is a ~WorldMorph~ object.
            39. 39:50-40:47 he steps ~becomeActiveDuring:~ method and reads the code, he steps it.
            40. 40:47-41:11 he steps in ~sendFocusEvent:to:clear:~ method, he steps it.
            41. 41:11-41:21 he steps in ~handleFocusEvent:~ method, then steps in ~handleEvent:~
            42. 41:21-43:16 he steps in ~sentTo:~ and observes it.
                1. 41:22-41:31 Q"Is the value of ~type~ variable =#keystroke=?" Q27 No, it is not. It is =#keyDown=.
                2. 41:31-41:45 he steps
                3. 41:45-41:55 he steps in ~handleKeyDown:~ method and reads it.
                   1. 41:55-42:16 <<t10link4>> he steps in. He observes =self handlesKeyDown: anEvent= line. Q25 He says that it is like a test C"correct", but it is going to do something c"false-assumption". C"It is a test. But the code is really confusing. It likely does some activities in other cases."
                   2. 42:16-42:31 he steps in ~handlesKeyDown:~, then ~handlesKeyboard:~. It returns true. S"So, it is a test!"
                   3. 42:31-42:54 He says that it is a really a test case.
                   4. 42:54 c"observer" C"Observer says that we reached 40 minutes. He ignores it."
                   5. 42:54-43:02 he steps in ~keyDown:~ method.
                      1. 43:02-43:16 it does not do anything. S"I give up!"
15. 43:16-65:44 session finished, the rest is interview.
